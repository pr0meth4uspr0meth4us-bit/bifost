from flask import Blueprint, request, jsonify, current_app
from datetime import datetime
from zoneinfo import ZoneInfo
import jwt
from werkzeug.security import check_password_hash
import logging
from bson import ObjectId  # <--- FIX: Import ObjectId directly

# Use Relative Imports
from .. import mongo
from ..models import BifrostDB
from ..utils.telegram import verify_telegram_data
from ..services.email_service import send_otp_email

auth_api_bp = Blueprint('auth_api', __name__, url_prefix='/auth/api')
UTC_TZ = ZoneInfo("UTC")
log = logging.getLogger(__name__)


# =========================================================
#  SECTION 1: EMAIL OTP ENDPOINTS (NEW)
# =========================================================

@auth_api_bp.route('/request-email-otp', methods=['POST'])
def request_email_otp():
    """
    Generates an OTP for an email address and sends it via SMTP.
    Payload: { "email": "user@example.com", "client_id": "..." }
    """
    data = request.json
    email = data.get('email')
    # Default to the finance bot client ID if none provided (simplifies frontend dev)
    client_id = data.get('client_id')

    if not email:
        return jsonify({"error": "Missing email"}), 400

    db = BifrostDB(mongo.cx, current_app.config['DB_NAME'])

    # 1. Validate Client & Get App Name for Branding
    app_name = "Savvify"
    if client_id:
        app_config = db.get_app_by_client_id(client_id)
        if app_config:
            app_name = app_config.get('app_name', 'Savvify')

    # 2. Generate Code
    code, verification_id = db.create_otp(email, channel="email")

    # 3. Send Email with Dynamic Branding
    if send_otp_email(to_email=email, otp=code, app_name=app_name):
        return jsonify({
            "message": "OTP sent successfully",
            "verification_id": verification_id
        })
    else:
        return jsonify({"error": "Failed to send email. Check server logs."}), 500


@auth_api_bp.route('/verify-email-otp', methods=['POST'])
def verify_email_otp():
    """
    Verifies the code and returns a 'Proof Token'.
    Payload: { "verification_id": "...", "code": "123456" }
    """
    data = request.json
    verification_id = data.get('verification_id')
    code = data.get('code')

    if not verification_id or not code:
        return jsonify({"error": "Missing verification_id or code"}), 400

    db = BifrostDB(mongo.cx, current_app.config['DB_NAME'])

    # 1. Fetch the record first to get the email (identifier)
    try:
        # FIX: Use the imported ObjectId class correctly
        oid = ObjectId(verification_id)
        # Access the collection directly via pymongo to avoid the wrapper logic hiding data
        otp_record = mongo.db.verification_codes.find_one({"_id": oid})
    except Exception as e:
        log.error(f"OTP Lookup Error: {e}")
        return jsonify({"error": "Invalid verification ID format"}), 400

    if not otp_record:
        return jsonify({"error": "Invalid or expired verification session"}), 400

    email = otp_record['identifier']

    # 2. Verify and Consume (Delete) the OTP
    # Note: verify_otp expects string ID if using verification_id param logic in models.py
    # or we can pass the identifier found above.
    if not db.verify_otp(verification_id=verification_id, code=code):
        return jsonify({"error": "Invalid code"}), 401

    # 3. Issue Proof Token (Short lived 5-min token for setting credentials)
    proof_payload = {
        "email": email,
        "scope": "credential_reset",
        "verified": True,
        "iss": "bifrost",
        "exp": datetime.now(UTC_TZ).timestamp() + 300
    }

    proof_token = jwt.encode(
        proof_payload,
        current_app.config['JWT_SECRET_KEY'],
        algorithm="HS256"
    )

    return jsonify({
        "success": True,
        "proof_token": proof_token
    })


# =========================================================
#  SECTION 2: EXISTING LOGIN ENDPOINTS
# =========================================================

@auth_api_bp.route('/verify-otp', methods=['POST'])
def verify_otp_login():
    """
    Verifies a code generated by the Bot (via /internal/generate-otp).
    Payload: { "client_id": "...", "code": "123456" }
    """
    data = request.json
    client_id = data.get('client_id')
    code = data.get('code')

    if not client_id or not code:
        return jsonify({"error": "Missing client_id or code"}), 400

    db = BifrostDB(mongo.cx, current_app.config['DB_NAME'])
    app_config = db.get_app_by_client_id(client_id)

    if not app_config:
        return jsonify({"error": "Invalid client_id"}), 401

    if "telegram" not in app_config.get("allowed_auth_methods", []):
        return jsonify({"error": "Telegram auth not enabled for this application"}), 403

    # Verify Code
    telegram_id = db.verify_and_consume_code(code)

    if not telegram_id:
        return jsonify({"error": "Invalid or expired code"}), 401

    # Find or Create Account
    user = db.find_account_by_telegram(telegram_id)

    if not user:
        user_id = db.create_account({
            "telegram_id": telegram_id,
            "display_name": "Telegram User",
            "auth_providers": ["telegram"]
        })
    else:
        user_id = user['_id']

    # Link User to App
    db.link_user_to_app(user_id, app_config['_id'])

    # Issue JWT
    token_payload = {
        "sub": str(user_id),
        "iss": "bifrost",
        "aud": client_id,
        "iat": datetime.now(UTC_TZ),
        "exp": datetime.now(UTC_TZ).timestamp() + 3600 * 24 * 7
    }

    encoded_jwt = jwt.encode(
        token_payload,
        current_app.config['JWT_SECRET_KEY'],
        algorithm="HS256"
    )

    return jsonify({
        "jwt": encoded_jwt,
        "account_id": str(user_id),
        "display_name": "Telegram User" if not user else user.get('display_name')
    })


@auth_api_bp.route('/telegram-login', methods=['POST'])
def telegram_login():
    """
    Legacy/Widget Telegram Login.
    """
    data = request.json
    client_id = data.get('client_id')
    tg_data = data.get('telegram_data')

    if not client_id or not tg_data:
        return jsonify({"error": "Missing client_id or telegram_data"}), 400

    app_config = mongo.db.applications.find_one({"client_id": client_id})

    if not app_config:
        return jsonify({"error": "Invalid client_id"}), 401

    if "telegram" not in app_config.get("allowed_auth_methods", []):
        return jsonify({"error": "Telegram auth not enabled for this application"}), 403

    bot_token = app_config.get("telegram_bot_token")
    if not bot_token:
        return jsonify({"error": "Server misconfiguration: No Bot Token found"}), 500

    if not verify_telegram_data(tg_data, bot_token):
        return jsonify({"error": "Authentication verification failed"}), 401

    telegram_id = str(tg_data['id'])
    user = mongo.db.accounts.find_one({"telegram_id": telegram_id})

    if not user:
        user = {
            "telegram_id": telegram_id,
            "display_name": tg_data.get('first_name', 'Unknown'),
            "created_at": datetime.now(UTC_TZ),
            "is_active": True,
            "auth_providers": ["telegram"]
        }
        result = mongo.db.accounts.insert_one(user)
        user['_id'] = result.inserted_id

    user_id = user['_id']

    # Link User to App
    link = mongo.db.app_links.find_one({
        "account_id": user_id,
        "app_id": app_config['_id']
    })

    if not link:
        mongo.db.app_links.insert_one({
            "account_id": user_id,
            "app_id": app_config['_id'],
            "role": "user",
            "linked_at": datetime.now(UTC_TZ)
        })

    token_payload = {
        "sub": str(user_id),
        "iss": "bifrost",
        "aud": client_id,
        "iat": datetime.now(UTC_TZ),
        "exp": datetime.now(UTC_TZ).timestamp() + 3600
    }

    encoded_jwt = jwt.encode(
        token_payload,
        current_app.config['JWT_SECRET_KEY'],
        algorithm="HS256"
    )

    return jsonify({
        "jwt": encoded_jwt,
        "account_id": str(user_id),
        "display_name": user.get('display_name')
    })


@auth_api_bp.route('/login', methods=['POST'])
def login():
    """
    Standard Email/Password Login.
    """
    data = request.json
    client_id = data.get('client_id')
    email = data.get('email')
    password = data.get('password')

    if not client_id or not email or not password:
        return jsonify({"error": "Missing credentials"}), 400

    db = BifrostDB(mongo.cx, current_app.config['DB_NAME'])
    app_config = db.get_app_by_client_id(client_id)

    if not app_config:
        return jsonify({"error": "Invalid client_id"}), 401

    user = db.find_account_by_email(email)

    if not user or not user.get('password_hash') or not check_password_hash(user['password_hash'], password):
        return jsonify({"error": "Invalid email or password"}), 401

    # Link & Issue JWT
    db.link_user_to_app(user['_id'], app_config['_id'])

    token_payload = {
        "sub": str(user['_id']),
        "iss": "bifrost",
        "aud": client_id,
        "iat": datetime.now(UTC_TZ),
        "exp": datetime.now(UTC_TZ).timestamp() + 3600 * 24 * 7
    }

    encoded_jwt = jwt.encode(
        token_payload,
        current_app.config['JWT_SECRET_KEY'],
        algorithm="HS256"
    )

    return jsonify({
        "jwt": encoded_jwt,
        "account_id": str(user['_id']),
        "display_name": user.get('display_name')
    })