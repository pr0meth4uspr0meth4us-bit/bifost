# bifrost/auth/api.py

from flask import Blueprint, request, jsonify, current_app
from datetime import datetime
from zoneinfo import ZoneInfo
import jwt
from werkzeug.security import check_password_hash

# Use Relative Imports
from .. import mongo
from ..models import BifrostDB
from ..utils.telegram import verify_telegram_data

auth_api_bp = Blueprint('auth_api', __name__, url_prefix='/auth/api')
UTC_TZ = ZoneInfo("UTC")


@auth_api_bp.route('/verify-otp', methods=['POST'])
def verify_otp_login():
    """
    Verifies a code generated by the Bot (via /internal/generate-otp).
    Payload: { "client_id": "...", "code": "123456" }
    """
    data = request.json
    client_id = data.get('client_id')
    code = data.get('code')

    if not client_id or not code:
        return jsonify({"error": "Missing client_id or code"}), 400

    # 1. Validate Client
    db = BifrostDB(mongo.cx, current_app.config['DB_NAME'])
    app_config = db.get_app_by_client_id(client_id)

    if not app_config:
        return jsonify({"error": "Invalid client_id"}), 401

    if "telegram" not in app_config.get("allowed_auth_methods", []):
        return jsonify({"error": "Telegram auth not enabled for this application"}), 403

    # 2. Verify Code
    telegram_id = db.verify_and_consume_code(code)

    if not telegram_id:
        return jsonify({"error": "Invalid or expired code"}), 401

    # 3. Find or Create Account
    user = db.find_account_by_telegram(telegram_id)

    if not user:
        # Create new Telegram-first user
        user_id = db.create_account({
            "telegram_id": telegram_id,
            "display_name": "Telegram User",  # Placeholder, they can update later
            "auth_providers": ["telegram"]
        })
    else:
        user_id = user['_id']

    # 4. Link User to App
    db.link_user_to_app(user_id, app_config['_id'])

    # 5. Issue JWT
    token_payload = {
        "sub": str(user_id),
        "iss": "bifrost",
        "aud": client_id,
        "iat": datetime.now(UTC_TZ),
        "exp": datetime.now(UTC_TZ).timestamp() + 3600 * 24 * 7  # 7 days
    }

    encoded_jwt = jwt.encode(
        token_payload,
        current_app.config['JWT_SECRET_KEY'],
        algorithm="HS256"
    )

    return jsonify({
        "jwt": encoded_jwt,
        "account_id": str(user_id),
        "display_name": "Telegram User" if not user else user.get('display_name')
    })


@auth_api_bp.route('/telegram-login', methods=['POST'])
def telegram_login():
    """
    Legacy/Widget Telegram Login.
    Kept for backward compatibility if needed, but OTP is preferred.
    """
    data = request.json
    client_id = data.get('client_id')
    tg_data = data.get('telegram_data')

    if not client_id or not tg_data:
        return jsonify({"error": "Missing client_id or telegram_data"}), 400

    app_config = mongo.db.applications.find_one({"client_id": client_id})

    if not app_config:
        return jsonify({"error": "Invalid client_id"}), 401

    if "telegram" not in app_config.get("allowed_auth_methods", []):
        return jsonify({"error": "Telegram auth not enabled for this application"}), 403

    bot_token = app_config.get("telegram_bot_token")
    if not bot_token:
        return jsonify({"error": "Server misconfiguration: No Bot Token found"}), 500

    if not verify_telegram_data(tg_data, bot_token):
        return jsonify({"error": "Authentication verification failed"}), 401

    telegram_id = str(tg_data['id'])
    user = mongo.db.accounts.find_one({"telegram_id": telegram_id})

    if not user:
        user = {
            "telegram_id": telegram_id,
            "display_name": tg_data.get('first_name', 'Unknown'),
            "created_at": datetime.now(UTC_TZ),
            "is_active": True,
            "auth_providers": ["telegram"]
        }
        result = mongo.db.accounts.insert_one(user)
        user['_id'] = result.inserted_id

    user_id = user['_id']

    # Link User to App
    link = mongo.db.app_links.find_one({
        "account_id": user_id,
        "app_id": app_config['_id']
    })

    if not link:
        mongo.db.app_links.insert_one({
            "account_id": user_id,
            "app_id": app_config['_id'],
            "role": "user",
            "linked_at": datetime.now(UTC_TZ)
        })

    token_payload = {
        "sub": str(user_id),
        "iss": "bifrost",
        "aud": client_id,
        "iat": datetime.now(UTC_TZ),
        "exp": datetime.now(UTC_TZ).timestamp() + 3600
    }

    encoded_jwt = jwt.encode(
        token_payload,
        current_app.config['JWT_SECRET_KEY'],
        algorithm="HS256"
    )

    return jsonify({
        "jwt": encoded_jwt,
        "account_id": str(user_id),
        "display_name": user.get('display_name')
    })


@auth_api_bp.route('/login', methods=['POST'])
def login():
    """
    Standard Email/Password Login.
    """
    data = request.json
    client_id = data.get('client_id')
    email = data.get('email')
    password = data.get('password')

    if not client_id or not email or not password:
        return jsonify({"error": "Missing credentials"}), 400

    db = BifrostDB(mongo.cx, current_app.config['DB_NAME'])
    app_config = db.get_app_by_client_id(client_id)

    if not app_config:
        return jsonify({"error": "Invalid client_id"}), 401

    user = db.find_account_by_email(email)

    if not user or not user.get('password_hash') or not check_password_hash(user['password_hash'], password):
        return jsonify({"error": "Invalid email or password"}), 401

    # Link & Issue JWT
    db.link_user_to_app(user['_id'], app_config['_id'])

    token_payload = {
        "sub": str(user['_id']),
        "iss": "bifrost",
        "aud": client_id,
        "iat": datetime.now(UTC_TZ),
        "exp": datetime.now(UTC_TZ).timestamp() + 3600 * 24 * 7
    }

    encoded_jwt = jwt.encode(
        token_payload,
        current_app.config['JWT_SECRET_KEY'],
        algorithm="HS256"
    )

    return jsonify({
        "jwt": encoded_jwt,
        "account_id": str(user['_id']),
        "display_name": user.get('display_name')
    })