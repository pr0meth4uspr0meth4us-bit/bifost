================================================================================
Directory: /Users/nicksng/Desktop/school/aupp/code/finance-bot
Total files: 44
================================================================================

==================== FILE: .gitignore ====================
.env
*.xml

============================================================

==================== FILE: docker-compose.yml ====================
# docker-compose.yml  (no version key)
services:
  web:
    build:
      context: .
      dockerfile: ./web_service/Dockerfile
    container_name: finance-bot-web
    ports:
      - "8000:8000"
    env_file:
      - .env
    restart: unless-stopped
    develop:
      watch:
        - action: sync
          path: ./web_service
          target: /app
          ignore:
            - "**/__pycache__/**"
            - "**/*.pyc"

  telegram:
    build:
      context: .
      dockerfile: ./telegram_bot/Dockerfile
    container_name: finance-bot-telegram
    env_file:
      - .env
    restart: unless-stopped
    develop:
      watch:
        - action: sync
          path: ./telegram_bot
          target: /app
          ignore:
            - "**/__pycache__/**"
            - "**/*.pyc"

============================================================

==================== FILE: telegram_bot/Dockerfile ====================
# --- telegram_bot/Dockerfile (FULL) ---
FROM python:3.11-slim

ENV TZ=Asia/Phnom_Penh
RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ > /etc/timezone

WORKDIR /app

# Ensure relative imports like `import api_client` work
ENV PYTHONPATH=/app

# Install deps from project root copy
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy bot sources
COPY ./telegram_bot .

CMD ["python", "bot.py"]

============================================================

==================== FILE: telegram_bot/api_client.py ====================
# --- Start of modified file: telegram_bot/api_client.py ---
import os
import requests
from dotenv import load_dotenv
import urllib.parse
import logging

log = logging.getLogger(__name__)

load_dotenv()
BASE_URL = os.getenv("WEB_SERVICE_URL")


def find_or_create_user(telegram_id):
    url = f"{BASE_URL}/auth/find_or_create"
    data = {"telegram_user_id": str(telegram_id)}
    try:
        res = requests.post(url, json=data, timeout=10)

        if res.status_code == 200:
            return res.json()
        if res.status_code == 403:
            return res.json()

        log.error(f"[AUTH] HTTP {res.status_code}: {res.text}")
        return {"error": f"Auth API error ({res.status_code})"}
    except requests.exceptions.RequestException as e:
        log.error(f"[AUTH] Network error reaching Auth API: {e}", exc_info=True)
        return {"error": "Network error reaching Auth API"}


def get_detailed_summary(user_id):
    """Fetches detailed summary for a specific user."""
    try:
        res = requests.get(
            f"{BASE_URL}/summary/detailed",
            params={'user_id': user_id},
            timeout=10
        )
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(f"API Error fetching detailed summary: {e}", exc_info=True)
        return None


def add_debt(data, user_id):
    """Adds a new debt for a specific user."""
    try:
        data['user_id'] = user_id
        res = requests.post(f"{BASE_URL}/debts/", json=data, timeout=10)
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(f"API Error adding debt: {e}", exc_info=True)
        return None


def add_reminder(data, user_id):
    """Adds a new reminder for a specific user."""
    try:
        data['user_id'] = user_id
        res = requests.post(f"{BASE_URL}/reminders/", json=data, timeout=10)
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(f"API Error adding reminder: {e}", exc_info=True)
        return None


def get_open_debts(user_id):
    """Fetches open debts for a specific user."""
    try:
        res = requests.get(
            f"{BASE_URL}/debts/", params={'user_id': user_id}, timeout=10
        )
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(f"API Error fetching debts: {e}", exc_info=True)
        return []


def get_open_debts_export(user_id):
    """Fetches a flat list of all open debts for export."""
    try:
        res = requests.get(
            f"{BASE_URL}/debts/export/open",
            params={'user_id': user_id},
            timeout=15
        )
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(f"API Error fetching debts for export: {e}", exc_info=True)
        return []


def get_settled_debts_grouped(user_id):
    """Fetches settled debts for a specific user."""
    try:
        res = requests.get(
            f"{BASE_URL}/debts/list/settled",
            params={'user_id': user_id},
            timeout=10
        )
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(f"API Error fetching settled debts: {e}", exc_info=True)
        return []


def get_debts_by_person_and_currency(person_name, currency, user_id):
    """Fetches debts by person/currency for a specific user."""
    try:
        encoded_name = urllib.parse.quote(person_name)
        res = requests.get(
            f"{BASE_URL}/debts/person/{encoded_name}/{currency}",
            params={'user_id': user_id},
            timeout=10
        )
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(
            f"API Error fetching debts for {person_name} ({currency}): {e}", exc_info=True
        )
        return []


def get_all_debts_by_person(person_name, user_id):
    """Fetches all open debts for a person, for a specific user."""
    try:
        encoded_name = urllib.parse.quote(person_name)
        res = requests.get(
            f"{BASE_URL}/debts/person/{encoded_name}/all",
            params={'user_id': user_id},
            timeout=10
        )
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(f"API Error fetching all debts for {person_name}: {e}", exc_info=True)
        return []


def get_all_settled_debts_by_person(person_name, user_id):
    """Fetches all settled debts for a person, for a specific user."""
    try:
        encoded_name = urllib.parse.quote(person_name)
        res = requests.get(
            f"{BASE_URL}/debts/person/{encoded_name}/all/settled",
            params={'user_id': user_id},
            timeout=10
        )
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(
            f"API Error fetching all settled debts for {person_name}: {e}", exc_info=True
        )
        return []


def get_debt_details(debt_id, user_id):
    """Fetches debt details for a specific user."""
    try:
        res = requests.get(
            f"{BASE_URL}/debts/{debt_id}",
            params={'user_id': user_id},
            timeout=10
        )
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(f"API Error fetching debt details: {e}", exc_info=True)
        return None


def cancel_debt(debt_id, user_id):
    """Cancels a debt for a specific user."""
    try:
        res = requests.post(
            f"{BASE_URL}/debts/{debt_id}/cancel",
            json={'user_id': user_id},
            timeout=15
        )
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(f"API Error canceling debt: {e}", exc_info=True)
        try:
            return e.response.json()
        except Exception:
            return {'error': 'A network error occurred.'}


def update_debt(debt_id, data, user_id):
    """Updates a debt for a specific user."""
    try:
        data['user_id'] = user_id
        res = requests.put(
            f"{BASE_URL}/debts/{debt_id}", json=data, timeout=10
        )
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(f"API Error updating debt: {e}", exc_info=True)
        try:
            return e.response.json()
        except Exception:
            return {'error': 'A network error occurred.'}


def record_lump_sum_repayment(
        person_name, currency, amount, debt_type, user_id, timestamp=None
):
    """Records a lump sum repayment for a specific user."""
    try:
        encoded_currency = urllib.parse.quote(currency)
        url = f"{BASE_URL}/debts/person/{encoded_currency}/repay"
        payload = {
            'amount': amount,
            'type': debt_type,
            'person': person_name,
            'user_id': user_id
        }
        if timestamp:
            payload['timestamp'] = timestamp

        res = requests.post(url, json=payload, timeout=15)
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(f"API Error recording lump-sum repayment: {e}", exc_info=True)
        try:
            return e.response.json()
        except Exception:
            return {'error': 'A network error occurred.'}


def update_exchange_rate(rate, user_id):
    """Updates the *user's* fixed rate preference."""
    try:
        res = requests.post(
            f"{BASE_URL}/settings/rate",
            json={'rate': rate, 'user_id': user_id},
            timeout=10
        )
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(f"API Error updating rate: {e}", exc_info=True)
        return None


def get_exchange_rate(user_id):
    """Fetches the exchange rate based on user's preference."""
    try:
        res = requests.get(
            f"{BASE_URL}/settings/rate",
            params={'user_id': user_id},
            timeout=10
        )
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(f"API Error fetching rate: {e}", exc_info=True)
        return None


def add_transaction(data, user_id):
    """Adds a transaction for a specific user."""
    try:
        data['user_id'] = user_id
        res = requests.post(
            f"{BASE_URL}/transactions/", json=data, timeout=10
        )
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(f"API Error adding transaction: {e}", exc_info=True)
        return None


def get_recent_transactions(user_id):
    """Fetches recent transactions for a specific user."""
    try:
        res = requests.get(
            f"{BASE_URL}/transactions/recent",
            params={'user_id': user_id},
            timeout=10
        )
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(f"API Error fetching recent transactions: {e}", exc_info=True)
        return []


def get_transaction_details(tx_id, user_id):
    """Fetches transaction details for a specific user."""
    try:
        res = requests.get(
            f"{BASE_URL}/transactions/{tx_id}",
            params={'user_id': user_id},
            timeout=10
        )
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(f"API Error fetching transaction details: {e}", exc_info=True)
        return None


def update_transaction(tx_id, data, user_id):
    """Updates a transaction for a specific user."""
    try:
        data['user_id'] = user_id
        res = requests.put(
            f"{BASE_URL}/transactions/{tx_id}", json=data, timeout=10
        )
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(f"API Error updating transaction: {e}", exc_info=True)
        return None


def delete_transaction(tx_id, user_id):
    """Deletes a transaction for a specific user."""
    try:
        res = requests.delete(
            f"{BASE_URL}/transactions/{tx_id}",
            json={'user_id': user_id},
            timeout=10
        )
        res.raise_for_status()
        return True
    except requests.exceptions.RequestException as e:
        log.error(f"API Error deleting transaction: {e}", exc_info=True)
        return False


def get_detailed_report(user_id, start_date=None, end_date=None):
    """Fetches a detailed report for a specific user."""
    try:
        params = {'user_id': user_id}
        if start_date and end_date:
            params['start_date'] = start_date.isoformat()
            params['end_date'] = end_date.isoformat()

        res = requests.get(
            f"{BASE_URL}/analytics/report/detailed",
            params=params,
            timeout=15
        )
        if res.status_code == 200:
            return res.json()

        log.error(f"API Error fetching detailed report (HTTP {res.status_code}): {res.text}")
        return None
    except requests.exceptions.RequestException as e:
        log.error(f"API Error fetching detailed report: {e}", exc_info=True)
        return None


def get_spending_habits(user_id, start_date, end_date):
    """Fetches spending habits for a specific user."""
    try:
        params = {
            'user_id': user_id,
            'start_date': start_date.isoformat(),
            'end_date': end_date.isoformat()
        }
        res = requests.get(
            f"{BASE_URL}/analytics/habits", params=params, timeout=20
        )
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(f"API Error fetching spending habits: {e}", exc_info=True)
        return None


def get_debt_analysis(user_id):
    """Fetches debt analysis for a specific user."""
    try:
        res = requests.get(
            f"{BASE_URL}/debts/analysis",
            params={'user_id': user_id},
            timeout=15
        )
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(f"API Error fetching debt analysis: {e}", exc_info=True)
        return None


def search_transactions_for_management(params, user_id):
    """Searches transactions for a specific user."""
    try:
        params['user_id'] = user_id
        res = requests.post(
            f"{BASE_URL}/transactions/search", json=params, timeout=20
        )
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(f"API Error searching transactions for management: {e}", exc_info=True)
        return []


def sum_transactions_for_analytics(params, user_id):
    """Sums transactions for a specific user."""
    try:
        params['user_id'] = user_id
        res = requests.post(
            f"{BASE_URL}/analytics/search", json=params, timeout=20
        )
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(f"API Error summing transactions: {e}", exc_info=True)
        return None


# --- NEW SETTINGS FUNCTIONS ---

def get_user_settings(user_id):
    """Fetches all settings for a user."""
    try:
        res = requests.get(
            f"{BASE_URL}/settings/", params={'user_id': user_id}, timeout=10
        )
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(f"API Error fetching settings: {e}", exc_info=True)
        return None


def update_initial_balance(user_id, currency, amount):
    """Updates the user's initial balance for one currency."""
    try:
        payload = {
            'user_id': user_id,
            'currency': currency,
            'amount': amount
        }
        res = requests.post(
            f"{BASE_URL}/settings/balance", json=payload, timeout=10
        )
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(f"API Error updating initial balance: {e}", exc_info=True)
        return None


def update_user_mode(user_id, mode, language=None, name_en=None, name_km=None, primary_currency=None):
    """Sets the user's currency mode and language during onboarding."""
    try:
        payload = {
            'user_id': user_id,
            'mode': mode,
            'name_en': name_en
        }
        if language:
            payload['language'] = language
        if name_km:
            payload['name_km'] = name_km
        if primary_currency:
            payload['primary_currency'] = primary_currency

        res = requests.post(
            f"{BASE_URL}/settings/mode", json=payload, timeout=10
        )
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(f"API Error updating user mode: {e}", exc_info=True)
        return None


def complete_onboarding(user_id):
    """Marks the user's onboarding as complete."""
    try:
        payload = {'user_id': user_id}
        res = requests.post(
            f"{BASE_URL}/settings/complete_onboarding", json=payload, timeout=10
        )
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(f"API Error completing onboarding: {e}", exc_info=True)
        return None


def add_category(user_id, cat_type, cat_name):
    """Adds a custom category for a user."""
    try:
        payload = {
            'user_id': user_id,
            'type': cat_type,
            'name': cat_name
        }
        res = requests.post(
            f"{BASE_URL}/settings/category", json=payload, timeout=10
        )
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(f"API Error adding category: {e}", exc_info=True)
        return None


def remove_category(user_id, cat_type, cat_name):
    """Removes a custom category for a user."""
    try:
        payload = {
            'user_id': user_id,
            'type': cat_type,
            'name': cat_name
        }
        res = requests.delete(
            f"{BASE_URL}/settings/category", json=payload, timeout=10
        )
        res.raise_for_status()
        return res.json()
    except requests.exceptions.RequestException as e:
        log.error(f"API Error removing category: {e}", exc_info=True)
        return None

# --- End of modified file ---

============================================================

==================== FILE: telegram_bot/bot.py ====================
# --- telegram_bot/bot.py (FULL) ---
import os
import logging
import asyncio
from telegram import Update
from telegram.ext import Application, CommandHandler, CallbackQueryHandler
from dotenv import load_dotenv

from handlers import (
    # start, # <-- REMOVED
    quick_check, cancel,
    tx_conversation_handler,
    iou_conversation_handler,
    repay_lump_conversation_handler,
    forgot_conversation_handler,
    reminder_conversation_handler,
    report_conversation_handler,
    edit_tx_conversation_handler,
    habits_conversation_handler,
    search_conversation_handler,
    history_menu, manage_transaction, delete_transaction_prompt,
    delete_transaction_confirm,
    iou_menu, iou_view, iou_person_detail, iou_detail, debt_analysis,
    iou_view_settled, iou_person_detail_settled, iou_manage_list,
    iou_manage_menu, iou_cancel_prompt, iou_cancel_confirm,
    iou_edit_conversation_handler,
    get_current_rate
)
# --- NEW IMPORTS ---
from handlers.analytics import download_report_csv
from handlers.iou import download_debt_analysis_csv
# --- END NEW IMPORTS ---
from handlers.command_handler import unified_message_conversation_handler
from handlers.onboarding import onboarding_conversation_handler
from handlers.settings import settings_conversation_handler
from utils.i18n import load_translations

load_dotenv()

# --- MODIFIED: More detailed logging ---
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO,
)
# Set httpx logger to WARNING to reduce noise, unless DEBUG is needed
logging.getLogger("httpx").setLevel(logging.WARNING)
logging.getLogger("apscheduler").setLevel(logging.WARNING)

logger = logging.getLogger("finance-bot")
# --- END MODIFICATION ---


async def on_error(update: object, context):
    """
    Logs errors caused by updates.
    This is the most important function for debugging production issues.
    """
    logger.error(
        "--- Unhandled error processing update ---",
        exc_info=context.error
    )

    # Log the update object itself to see what caused the error
    if isinstance(update, Update):
        logger.error(f"Update: {update}")
    else:
        logger.error(f"Update object (type {type(update)}): {update}")

    # Log user data if available, to trace user state
    if context and context.user_data:
        logger.error(f"User Data: {context.user_data}")


# --- NEW: post_init function ---
async def post_init(app: Application):
    """
    Runs after the Application is built, but before polling starts.
    Used to delete any existing webhook to prevent 409 Conflict errors.
    """
    try:
        logger.info("Running post_init: Attempting to delete webhook...")
        await app.bot.delete_webhook(drop_pending_updates=True)
        logger.info("post_init: Webhook deleted successfully.")
    except Exception as e:
        logger.error(f"post_init: Error deleting webhook: {e}", exc_info=True)
# --- END NEW FUNCTION ---


def main():  # <-- MODIFICATION: Changed back to synchronous
    # Load translations into memory on boot
    load_translations()

    # --- DEBUG TRACING ---
    logger.info("--- Starting Bot ---")
    logger.info(f"WEB_SERVICE_URL: {os.getenv('WEB_SERVICE_URL')}")
    logger.info(f"MONGODB_URI (Bot check, not used directly): {os.getenv('MONGODB_URI', 'NOT SET')[:15]}...")
    # --- END DEBUG TRACING ---

    token = os.getenv("TELEGRAM_TOKEN")
    if not token:
        logger.critical("âŒ TELEGRAM_TOKEN not found. Bot cannot start.")
        return

    # --- MODIFICATION: Added post_init hook ---
    app = Application.builder().token(token).post_init(post_init).build()

    app.add_error_handler(on_error)

    # System commands
    # app.add_handler(CommandHandler("start", start)) # <-- REMOVED
    app.add_handler(CommandHandler("cancel", cancel))


    # Conversations
    app.add_handler(tx_conversation_handler)
    app.add_handler(iou_conversation_handler)
    app.add_handler(repay_lump_conversation_handler)
    app.add_handler(forgot_conversation_handler)
    app.add_handler(reminder_conversation_handler)
    app.add_handler(report_conversation_handler)
    app.add_handler(edit_tx_conversation_handler)
    app.add_handler(habits_conversation_handler)
    app.add_handler(search_conversation_handler)
    app.add_handler(iou_edit_conversation_handler)
    app.add_handler(settings_conversation_handler)

    # --- THIS IS THE FIX ---
    # This handler is now the main entry for /start AND all onboarding
    # It MUST be registered before the unified_message_conversation_handler
    app.add_handler(onboarding_conversation_handler)
    # --- END FIX ---

    # IMPORTANT: The !command handler must be LAST
    app.add_handler(unified_message_conversation_handler)

    # Callback-only handlers
    # app.add_handler(CallbackQueryHandler(start, pattern="^start$")) # <-- REMOVED
    app.add_handler(CallbackQueryHandler(quick_check, pattern="^quick_check$"))
    app.add_handler(CallbackQueryHandler(history_menu, pattern="^history$"))
    app.add_handler(CallbackQueryHandler(manage_transaction, pattern="^manage_tx_"))
    app.add_handler(CallbackQueryHandler(delete_transaction_prompt, pattern="^delete_tx_"))
    app.add_handler(CallbackQueryHandler(delete_transaction_confirm, pattern="^confirm_delete_"))
    app.add_handler(CallbackQueryHandler(get_current_rate, pattern="^get_live_rate$"))

    app.add_handler(CallbackQueryHandler(iou_menu, pattern="^iou_menu$"))
    app.add_handler(CallbackQueryHandler(iou_view, pattern="^iou_view$"))
    app.add_handler(CallbackQueryHandler(iou_view_settled, pattern="^iou_view_settled$"))
    app.add_handler(CallbackQueryHandler(iou_person_detail, pattern="^iou:person:open:"))
    app.add_handler(CallbackQueryHandler(iou_person_detail_settled, pattern="^iou:person:settled:"))
    app.add_handler(CallbackQueryHandler(iou_detail, pattern="^iou:detail:"))
    app.add_handler(CallbackQueryHandler(iou_manage_list, pattern="^iou:manage:list:"))
    app.add_handler(CallbackQueryHandler(iou_manage_menu, pattern="^iou:manage:detail:"))
    app.add_handler(CallbackQueryHandler(iou_cancel_prompt, pattern="^iou:cancel:prompt:"))
    app.add_handler(CallbackQueryHandler(iou_cancel_confirm, pattern="^iou:cancel:confirm:"))
    app.add_handler(CallbackQueryHandler(debt_analysis, pattern="^debt_analysis$"))

    # --- NEW CSV EXPORT HANDLERS ---
    app.add_handler(CallbackQueryHandler(download_report_csv, pattern="^report_csv:"))
    app.add_handler(CallbackQueryHandler(download_debt_analysis_csv, pattern="^debt_analysis_csv$"))
    # --- END NEW HANDLERS ---

    logger.info("ðŸš€ Bot is starting polling...")

    # --- MODIFICATION: This is now a blocking, synchronous call ---
    # It will run forever until a stop signal is received.
    app.run_polling(
        drop_pending_updates=True,
        allowed_updates=Update.ALL_TYPES,
        stop_signals=None,  # Let container orchestrator send SIGTERM
    )


if __name__ == "__main__":
    # --- MODIFICATION: Call the synchronous main() function directly ---
    try:
        main()
    except (KeyboardInterrupt, SystemExit):
        logger.info("Bot shutting down...")
    except Exception as e:
        logger.critical(f"Bot failed to start: {e}", exc_info=True)

# --- End of modified file ---

============================================================

==================== FILE: telegram_bot/decorators.py ====================
# --- telegram_bot/decorators.py (FULL) ---
from functools import wraps
from telegram import Update
from telegram.ext import ContextTypes, ConversationHandler
import api_client
# from handlers.onboarding import onboarding_start # --- REMOVED
import logging

log = logging.getLogger(__name__)


def authenticate_user(func):
    @wraps(func)
    async def wrapped(update: Update, context: ContextTypes.DEFAULT_TYPE, *args, **kwargs):
        if not update.effective_user:
            log.warning("Decorator received update with no effective_user.")
            return ConversationHandler.END

        user_id = update.effective_user.id
        cached = context.user_data.get("user_profile")

        if not cached:
            log.info(f"User {user_id}: No profile in cache. Fetching from API.")
            profile = api_client.find_or_create_user(user_id)
            if not profile or profile.get("error"):
                msg = profile.get("error", "Auth failed.")
                log.error(f"User {user_id}: Auth failed or API error: {msg}")
                if update.message:
                    await update.message.reply_text(f"ðŸš« {msg}")
                elif update.callback_query:
                    await context.bot.answer_callback_query(
                        callback_query_id=update.callback_query.id,
                        text=f"ðŸš« {msg}",
                        show_alert=True,
                    )
                return ConversationHandler.END
            context.user_data["user_profile"] = profile
            log.info(f"User {user_id}: Profile fetched and cached.")
        else:
            log.info(f"User {user_id}: Profile found in cache.")

        # --- MODIFIED ONBOARDING REDIRECT ---
        is_complete = context.user_data["user_profile"].get("onboarding_complete")
        if not is_complete:
            # Don't redirect. Just block the handler and tell the user what to do.
            # This prevents the decorator from returning a state to the wrong handler.
            log.info(f"User {user_id}: Onboarding_complete=False. Blocking handler '{func.__name__}'.")

            if update.message:
                await update.message.reply_text("Please complete the setup first. Type /start to begin.")
            elif update.callback_query:
                await context.bot.answer_callback_query(
                    callback_query_id=update.callback_query.id,
                    text="Please complete the setup first. Type /start to begin.",
                    show_alert=True,
                )

            # Cleanly end the current conversation/handler
            return ConversationHandler.END
        # --- END MODIFICATION ---

        return await func(update, context, *args, **kwargs)

    return wrapped

============================================================

==================== FILE: telegram_bot/handlers/__init__.py ====================
# --- Start of modified file: telegram_bot/handlers/__init__.py ---

from telegram.ext import (
    ConversationHandler,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    filters
)

from .common import start, quick_check, cancel
from .analytics import (
    report_menu, process_report_choice, received_report_start_date,
    received_report_end_date,
    habits_menu, process_habits_choice,
    CHOOSE_REPORT_PERIOD, REPORT_ASK_START_DATE, REPORT_ASK_END_DATE,
    CHOOSE_HABITS_PERIOD
)
from .iou import (
    iou_menu, iou_view, iou_person_detail, iou_detail, debt_analysis,
    iou_start, iou_received_date_choice, iou_received_custom_date,
    iou_received_person,
    iou_received_amount, iou_received_currency, iou_received_purpose,
    repay_lump_start, received_lump_repayment_amount,
    iou_view_settled, iou_person_detail_settled, iou_manage_list,
    iou_manage_menu, iou_cancel_prompt, iou_cancel_confirm,
    iou_edit_start, iou_edit_received_value,
    IOU_ASK_DATE, IOU_CUSTOM_DATE, IOU_PERSON, IOU_AMOUNT, IOU_CURRENCY,
    IOU_PURPOSE, REPAY_LUMP_AMOUNT,
    IOU_EDIT_GET_VALUE
)
from .transaction import (
    add_transaction_start,
    forgot_log_start, received_forgot_day, received_forgot_custom_date,
    received_forgot_type, received_amount, received_currency, received_category,
    received_custom_category, ask_remark, received_remark,
    save_transaction_and_end,
    history_menu, manage_transaction, delete_transaction_prompt,
    delete_transaction_confirm,
    edit_transaction_start, edit_choose_field, edit_received_new_value,
    edit_received_new_category,
    edit_received_custom_category,
    edit_received_new_date, EDIT_GET_NEW_DATE,
    AMOUNT, CURRENCY, CATEGORY, CUSTOM_CATEGORY, ASK_REMARK, REMARK,
    FORGOT_DATE, FORGOT_CUSTOM_DATE, FORGOT_TYPE,
    EDIT_CHOOSE_FIELD, EDIT_GET_NEW_VALUE, EDIT_GET_NEW_CATEGORY,
    EDIT_GET_CUSTOM_CATEGORY
)
# Utility handlers are now just for reminders and 'get_rate'
from .utility import (
    set_reminder_start, received_reminder_purpose,
    received_reminder_date_choice, received_reminder_custom_date,
    received_reminder_time,
    get_current_rate,
    REMINDER_PURPOSE, REMINDER_ASK_DATE, REMINDER_CUSTOM_DATE,
    REMINDER_ASK_TIME
)
from .search import (
    search_menu_entry,
    search_start, received_period_choice, received_custom_start,
    received_custom_end,
    received_type_choice, received_categories, received_keywords,
    received_keyword_logic,
    CHOOSE_PERIOD, GET_CUSTOM_START, GET_CUSTOM_END, CHOOSE_TYPE,
    GET_CATEGORIES, GET_KEYWORDS, GET_KEYWORD_LOGIC,
    CHOOSE_ACTION
)
# NEW: Import settings and onboarding handlers
from .settings import settings_conversation_handler
from .onboarding import onboarding_conversation_handler


# --- Build Conversation Handlers ---

tx_conversation_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(
        add_transaction_start, pattern='^(add_expense|add_income)$'
    )],
    states={
        AMOUNT: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, received_amount
        )],
        CURRENCY: [CallbackQueryHandler(
            received_currency, pattern='^curr_'
        )],
        CATEGORY: [CallbackQueryHandler(
            received_category, pattern='^cat_'
        )],
        CUSTOM_CATEGORY: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, received_custom_category
        )],
        ASK_REMARK: [CallbackQueryHandler(
            ask_remark, pattern='^remark_'
        )],
        REMARK: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, received_remark
        )],
    },
    fallbacks=[
        CommandHandler('cancel', cancel),
        CommandHandler('start', start),
        CallbackQueryHandler(start, pattern='^start$')
    ],
    per_message=False
)

forgot_conversation_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(
        forgot_log_start, pattern='^forgot_log_start$'
    )],
    states={
        FORGOT_DATE: [CallbackQueryHandler(
            received_forgot_day, pattern='^forgot_day_'
        )],
        FORGOT_CUSTOM_DATE: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, received_forgot_custom_date
        )],
        FORGOT_TYPE: [CallbackQueryHandler(
            received_forgot_type, pattern='^forgot_type_'
        )],
        AMOUNT: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, received_amount
        )],
        CURRENCY: [CallbackQueryHandler(
            received_currency, pattern='^curr_'
        )],
        CATEGORY: [CallbackQueryHandler(
            received_category, pattern='^cat_'
        )],
        CUSTOM_CATEGORY: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, received_custom_category
        )],
        ASK_REMARK: [CallbackQueryHandler(
            ask_remark, pattern='^remark_'
        )],
        REMARK: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, received_remark
        )],
    },
    fallbacks=[
        CommandHandler('cancel', cancel),
        CommandHandler('start', start),
        CallbackQueryHandler(start, pattern='^start$')
    ],
    per_message=False
)

edit_tx_conversation_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(
        edit_transaction_start, pattern='^edit_tx_'
    )],
    states={
        EDIT_CHOOSE_FIELD: [CallbackQueryHandler(
            edit_choose_field, pattern='^edit_field_'
        )],
        EDIT_GET_NEW_VALUE: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, edit_received_new_value
        )],
        EDIT_GET_NEW_CATEGORY: [CallbackQueryHandler(
            edit_received_new_category, pattern='^cat_'
        )],
        EDIT_GET_CUSTOM_CATEGORY: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, edit_received_custom_category
        )],
        EDIT_GET_NEW_DATE: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, edit_received_new_date
        )],
    },
    fallbacks=[
        CommandHandler('cancel', cancel),
        CommandHandler('start', start),
        CallbackQueryHandler(start, pattern='^start$')
    ],
    per_message=False
)

iou_conversation_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(
        iou_start, pattern='^(iou_lent|iou_borrowed)$'
    )],
    states={
        IOU_ASK_DATE: [CallbackQueryHandler(
            iou_received_date_choice, pattern='^iou_date_'
        )],
        IOU_CUSTOM_DATE: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, iou_received_custom_date
        )],
        IOU_PERSON: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, iou_received_person
        )],
        IOU_AMOUNT: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, iou_received_amount
        )],
        IOU_CURRENCY: [CallbackQueryHandler(
            iou_received_currency, pattern='^curr_'
        )],
        IOU_PURPOSE: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, iou_received_purpose
        )],
    },
    fallbacks=[
        CommandHandler('cancel', cancel),
        CommandHandler('start', start),
        CallbackQueryHandler(start, pattern='^start$')
    ],
    per_message=False
)

iou_edit_conversation_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(
        iou_edit_start, pattern='^iou:edit:'
    )],
    states={
        IOU_EDIT_GET_VALUE: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, iou_edit_received_value
        )]
    },
    fallbacks=[
        CommandHandler('cancel', cancel),
        CommandHandler('start', start),
        CallbackQueryHandler(start, pattern='^start$')
    ],
    per_message=False
)

repay_lump_conversation_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(
        repay_lump_start, pattern='^iou:repay:'
    )],
    states={
        REPAY_LUMP_AMOUNT: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, received_lump_repayment_amount
        )],
    },
    fallbacks=[
        CommandHandler('cancel', cancel),
        CommandHandler('start', start),
        CallbackQueryHandler(start, pattern='^start$')
    ],
    per_message=False
)

# This handler is now much smaller
reminder_conversation_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(
        set_reminder_start, pattern='^set_reminder_start$'
    )],
    states={
        REMINDER_PURPOSE: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, received_reminder_purpose
        )],
        REMINDER_ASK_DATE: [CallbackQueryHandler(
            received_reminder_date_choice, pattern='^remind_date_'
        )],
        REMINDER_CUSTOM_DATE: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, received_reminder_custom_date
        )],
        REMINDER_ASK_TIME: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, received_reminder_time
        )],
    },
    fallbacks=[
        CommandHandler('cancel', cancel),
        CommandHandler('start', start),
        CallbackQueryHandler(start, pattern='^start$')
    ],
    per_message=False
)

report_conversation_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(
        report_menu, pattern='^report_menu$'
    )],
    states={
        CHOOSE_REPORT_PERIOD: [CallbackQueryHandler(
            process_report_choice, pattern='^report_period_'
        )],
        REPORT_ASK_START_DATE: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, received_report_start_date
        )],
        REPORT_ASK_END_DATE: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, received_report_end_date
        )],
    },
    fallbacks=[
        CommandHandler('cancel', cancel),
        CommandHandler('start', start),
        CallbackQueryHandler(start, pattern='^start$')
    ],
    per_message=False
)

habits_conversation_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(
        habits_menu, pattern='^habits_menu$'
    )],
    states={
        CHOOSE_HABITS_PERIOD: [CallbackQueryHandler(
            process_habits_choice, pattern='^report_period_'
        )]
    },
    fallbacks=[
        CommandHandler('cancel', cancel),
        CommandHandler('start', start),
        CallbackQueryHandler(start, pattern='^start$')
    ],
    per_message=False
)

search_conversation_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(
        search_menu_entry, pattern='^search_menu$'
    )],
    states={
        CHOOSE_ACTION: [CallbackQueryHandler(
            search_start, pattern='^start_search_(manage|sum)$'
        )],
        CHOOSE_PERIOD: [CallbackQueryHandler(
            received_period_choice, pattern='^report_period_'
        )],
        GET_CUSTOM_START: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, received_custom_start
        )],
        GET_CUSTOM_END: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, received_custom_end
        )],
        CHOOSE_TYPE: [CallbackQueryHandler(
            received_type_choice, pattern='^search_type_'
        )],
        GET_CATEGORIES: [
            MessageHandler(
                filters.TEXT & ~filters.COMMAND, received_categories
            ),
            CallbackQueryHandler(
                received_categories, pattern='^search_skip_categories$'
            )
        ],
        GET_KEYWORDS: [
            MessageHandler(
                filters.TEXT & ~filters.COMMAND, received_keywords
            ),
            CallbackQueryHandler(
                received_keywords, pattern='^search_skip_keywords$'
            )
        ],
        GET_KEYWORD_LOGIC: [CallbackQueryHandler(
            received_keyword_logic, pattern='^search_logic_'
        )],
    },
    fallbacks=[
        CommandHandler('cancel', cancel),
        CommandHandler('start', start),
        CallbackQueryHandler(start, pattern='^start$')
    ],
    per_message=False
)
# --- End of modified file ---

============================================================

==================== FILE: telegram_bot/handlers/analytics.py ====================
# --- Start of modified file: telegram_bot/handlers/analytics.py ---

from telegram import Update
from telegram.ext import ContextTypes, ConversationHandler
import keyboards
import api_client
from decorators import authenticate_user
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo
from .helpers import (
    _format_report_summary_message,
    _create_income_expense_chart,
    _create_expense_pie_chart,
    _format_habits_message,
    _create_spending_line_chart,
    _create_csv_from_transactions  # <-- NEW IMPORT
)
from utils.i18n import t

(
    CHOOSE_REPORT_PERIOD, REPORT_ASK_START_DATE, REPORT_ASK_END_DATE,
    CHOOSE_HABITS_PERIOD
) = range(4)

PHNOM_PENH_TZ = ZoneInfo("Asia/Phnom_Penh")
REPORT_PERIOD_REGEX = '^(Today|This Week|Last Week|This Month|Last Month|Custom Range)$'


@authenticate_user
async def report_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Displays the menu for selecting a report period."""
    query = update.callback_query
    await query.answer()

    # --- THIS IS THE FIX ---
    # Preserve the user_profile, clear everything else, then restore it.
    user_profile = context.user_data.get('user_profile')
    context.user_data.clear()
    context.user_data['user_profile'] = user_profile
    # --- END FIX ---

    await query.edit_message_text(
        t("analytics.report_ask_period", context),
        reply_markup=keyboards.report_period_keyboard(context)
    )
    return CHOOSE_REPORT_PERIOD


@authenticate_user
async def process_report_choice(update: Update,
                                context: ContextTypes.DEFAULT_TYPE):
    """Handles standard period selection or transitions to custom date entry."""
    query = update.callback_query
    await query.answer()
    period = query.data.replace('report_period_', '')

    if period == "custom":
        await query.edit_message_text(t("analytics.report_ask_start", context))
        return REPORT_ASK_START_DATE

    today = datetime.now(PHNOM_PENH_TZ).date()
    end_of_last_month = today.replace(day=1) - timedelta(days=1)
    start_of_last_month = end_of_last_month.replace(day=1)
    date_ranges = {
        "today": (today, today),
        "this_week": (today - timedelta(days=today.weekday()),
                      today - timedelta(days=today.weekday()) +
                      timedelta(days=6)),
        "last_week": (today - timedelta(days=today.weekday() + 7),
                      today - timedelta(days=today.weekday() + 1)),
        "this_month": (today.replace(day=1),
                       (today.replace(day=28) +
                        timedelta(days=4)).replace(day=1) -
                       timedelta(days=1)),
        "last_month": (start_of_last_month, end_of_last_month)
    }

    date_pair = date_ranges.get(period)
    if date_pair:
        start_date, end_date = date_pair
        await _generate_report(update, context, start_date, end_date)
    else:
        await query.edit_message_text(
            t("analytics.habits_invalid_period", context),
            reply_markup=keyboards.main_menu_keyboard(context)
        )

    return ConversationHandler.END


@authenticate_user
async def received_report_start_date(update: Update,
                                     context: ContextTypes.DEFAULT_TYPE):
    """Receives and validates the custom start date."""
    try:
        start_date = datetime.strptime(update.message.text, "%Y-%m-%d").date()
        context.user_data['report_start_date'] = start_date
        await update.message.reply_text(
            t("analytics.report_ask_end", context, date=start_date)
        )
        return REPORT_ASK_END_DATE
    except ValueError:
        await update.message.reply_text(
            t("analytics.report_invalid_date", context)
        )
        return REPORT_ASK_START_DATE


@authenticate_user
async def received_report_end_date(update: Update,
                                   context: ContextTypes.DEFAULT_TYPE):
    """Receives, validates end date, and generates the report."""
    try:
        end_date = datetime.strptime(update.message.text, "%Y-%m-%d").date()
        start_date = context.user_data.get('report_start_date')
        if not start_date or end_date < start_date:
            await update.message.reply_text(
                t("analytics.report_invalid_range", context)
            )
            return REPORT_ASK_END_DATE
        await _generate_report(update, context, start_date, end_date)
        return ConversationHandler.END
    except ValueError:
        await update.message.reply_text(
            t("analytics.report_invalid_date", context)
        )
        return REPORT_ASK_END_DATE
    finally:
        context.user_data.pop('report_start_date', None)


async def _generate_report(update: Update,
                           context: ContextTypes.DEFAULT_TYPE,
                           start_date, end_date):
    """Shared logic to generate and send report summary and charts."""
    chat_id = update.effective_chat.id
    user_id = context.user_data['user_profile']['_id']

    loading_text = t("analytics.report_generating", context,
                     start_date=start_date, end_date=end_date)

    loading_message = await context.bot.send_message(
        chat_id=chat_id, text=loading_text
    )
    if update.callback_query:
        await update.callback_query.message.delete()

    report_data = api_client.get_detailed_report(user_id, start_date, end_date)
    await loading_message.delete()

    if report_data:
        summary_message = _format_report_summary_message(report_data)
        await context.bot.send_message(
            chat_id=chat_id, text=summary_message, parse_mode='HTML'
        )

        if bar_chart := _create_income_expense_chart(
                report_data, start_date, end_date):
            await context.bot.send_photo(chat_id=chat_id, photo=bar_chart)
        if line_chart := _create_spending_line_chart(
                report_data, start_date, end_date):
            await context.bot.send_photo(chat_id=chat_id, photo=line_chart)
        if pie_chart := _create_expense_pie_chart(
                report_data, start_date, end_date):
            await context.bot.send_photo(chat_id=chat_id, photo=pie_chart)

        await context.bot.send_message(
            chat_id=chat_id,
            text=t("analytics.report_success", context),
            # --- MODIFICATION: Use new keyboard ---
            reply_markup=keyboards.report_actions_keyboard(
                start_date, end_date, context
            )
        )
    else:
        await context.bot.send_message(
            chat_id=chat_id,
            text=t("analytics.report_fail", context),
            reply_markup=keyboards.main_menu_keyboard(context)
        )


@authenticate_user
async def habits_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Displays menu to choose a period for habits analysis."""
    query = update.callback_query
    await query.answer()

    # --- THIS IS THE FIX ---
    # Preserve the user_profile, clear everything else, then restore it.
    user_profile = context.user_data.get('user_profile')
    context.user_data.clear()
    context.user_data['user_profile'] = user_profile
    # --- END FIX ---

    await query.edit_message_text(
        t("analytics.habits_ask_period", context),
        reply_markup=keyboards.report_period_keyboard(context)
    )
    return CHOOSE_HABITS_PERIOD


@authenticate_user
async def process_habits_choice(update: Update,
                                context: ContextTypes.DEFAULT_TYPE):
    """Generates and sends the habits report for the selected period."""
    query = update.callback_query
    await query.answer()
    period = query.data.replace('report_period_', '')

    if period == "custom":
        await query.edit_message_text(
            t("analytics.habits_no_custom", context),
            reply_markup=keyboards.report_period_keyboard(context)
        )
        return CHOOSE_HABITS_PERIOD

    today = datetime.now(PHNOM_PENH_TZ).date()
    end_of_last_month = today.replace(day=1) - timedelta(days=1)
    start_of_last_month = end_of_last_month.replace(day=1)
    date_ranges = {
        "today": (today, today),
        "this_week": (today - timedelta(days=today.weekday()),
                      today - timedelta(days=today.weekday()) +
                      timedelta(days=6)),
        "last_week": (today - timedelta(days=today.weekday() + 7),
                      today - timedelta(days=today.weekday() + 1)),
        "this_month": (today.replace(day=1),
                       (today.replace(day=28) +
                        timedelta(days=4)).replace(day=1) -
                       timedelta(days=1)),
        "last_month": (start_of_last_month, end_of_last_month)
    }

    date_pair = date_ranges.get(period)
    if date_pair:
        start_date, end_date = date_pair
        await query.edit_message_text(
            t("analytics.habits_generating", context)
        )

        user_id = context.user_data['user_profile']['_id']
        habits_data = api_client.get_spending_habits(
            user_id, start_date, end_date
        )

        if habits_data:
            message = _format_habits_message(habits_data)
            await query.edit_message_text(
                text=message,
                parse_mode='HTML',
                reply_markup=keyboards.main_menu_keyboard(context)
            )
        else:
            await query.edit_message_text(
                t("analytics.habits_fail", context),
                reply_markup=keyboards.main_menu_keyboard(context)
            )
    else:
        await query.edit_message_text(
            t("analytics.habits_invalid_period", context),
            reply_markup=keyboards.main_menu_keyboard(context)
        )

    return ConversationHandler.END


# --- NEW HANDLER FOR CSV EXPORT ---
@authenticate_user
async def download_report_csv(update: Update,
                              context: ContextTypes.DEFAULT_TYPE):
    """Handles the 'Download Report CSV' button press."""
    query = update.callback_query
    await query.answer(t("search.searching", context))

    try:
        user_id = context.user_data['user_profile']['_id']
        _, start_date_str, end_date_str = query.data.split(':')
        start_date = datetime.fromisoformat(start_date_str).date()
        end_date = datetime.fromisoformat(end_date_str).date()

        search_params = {
            'start_date': start_date.isoformat(),
            'end_date': end_date.isoformat()
        }

        # Use the existing search API to get all raw transactions
        transactions = api_client.search_transactions_for_management(
            search_params, user_id
        )

        if not transactions:
            await query.message.reply_text(t("search.no_results", context))
            return

        # Generate CSV
        csv_buffer = _create_csv_from_transactions(transactions)
        file_name = f"report_{start_date.isoformat()}_to_{end_date.isoformat()}.csv"

        await context.bot.send_document(
            chat_id=update.effective_chat.id,
            document=csv_buffer,
            filename=file_name,
            caption=f"Here is your transaction export for {start_date} to {end_date}."
        )

    except Exception as e:
        print(f"Error generating report CSV: {e}")
        await query.message.reply_text(t("common.error_generic", context, error=str(e)))

# --- End of modified file ---

============================================================

==================== FILE: telegram_bot/handlers/command_handler.py ====================
# --- Start of modified file: telegram_bot/handlers/command_handler.py ---

from telegram import Update
from telegram.ext import (
    ContextTypes, ConversationHandler, CallbackQueryHandler,
    MessageHandler, filters, CommandHandler
)
import api_client
import keyboards
from decorators import authenticate_user
from .helpers import format_summary_message
from .common import cancel, start
from datetime import datetime
from zoneinfo import ZoneInfo
import logging
import shlex
from asteval import Interpreter
import re  # <-- NEW IMPORT
from utils.i18n import t

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

PHNOM_PENH_TZ = ZoneInfo("Asia/Phnom_Penh")
SELECT_CATEGORY, GET_CUSTOM_CATEGORY = range(2)
aeval = Interpreter()

COMMAND_MAP = {
    'coffee': {'categoryId': 'Drink', 'description': 'Coffee',
               'type': 'expense'},
    'lunch': {'categoryId': 'Food', 'description': 'Lunch',
              'type': 'expense'},
    'dinner': {'categoryId': 'Food', 'description': 'Dinner',
               'type': 'expense'},
    'gas': {'categoryId': 'Transport', 'description': 'Gas',
            'type': 'expense'},
    'parking': {'categoryId': 'Transport', 'description': 'Parking',
                'type': 'expense'},
    'taxi': {'categoryId': 'Transport', 'description': 'Taxi/Tuktuk',
             'type': 'expense'},
    'movie': {'categoryId': 'Entertainment', 'description': 'Movie',
              'type': 'expense'},
    'groceries': {'categoryId': 'Shopping', 'description': 'Groceries',
                  'type': 'expense'},
    'shopping': {'categoryId': 'Shopping', 'description': 'Shopping',
                 'type': 'expense'},
    'bills': {'categoryId': 'Bills', 'description': 'Bills',
              'type': 'expense'},
    'pizza': {'categoryId': 'Food', 'description': 'Pizza',
              'type': 'expense'},
    'others': {'categoryId': 'For Others', 'description': 'For Others',
               'type': 'expense'},
    'alcohol': {'categoryId': 'Alcohol', 'description': 'Alcohol',
                'type': 'expense'},
    'investment': {'categoryId': 'Investment', 'description': 'Investment',
                   'type': 'expense'},
    'salary': {'categoryId': 'Salary', 'description': 'Salary',
               'type': 'income'},
    'bonus': {'categoryId': 'Bonus', 'description': 'Bonus',
              'type': 'income'},
    'commission': {'categoryId': 'Commission', 'description': 'Commission',
                   'type': 'income'},
    'allowance': {'categoryId': 'Allowance', 'description': 'Allowance',
                  'type': 'income'},
    'gift': {'categoryId': 'Gift', 'description': 'Gift',
             'type': 'income'},
}


def _get_user_settings_for_command(context: ContextTypes.DEFAULT_TYPE):
    """Helper to get currency mode and primary currency."""
    profile = context.user_data.get('user_profile', {})
    settings = profile.get('settings', {})
    mode = settings.get('currency_mode', 'dual')

    if mode == 'single':
        primary_currency = settings.get('primary_currency', 'USD')
        return mode, primary_currency

    return 'dual', 'USD'  # Default primary for dual is USD


def parse_amount_and_currency_dual(amount_str: str):
    """Original v1 parser for dual-currency mode."""
    amount_str = amount_str.lower().strip()
    if 'khr' in amount_str:
        amount_val = float(amount_str.replace('khr', '').strip())
        return amount_val, 'KHR'

    amount_val = float(amount_str)
    return amount_val, 'USD'


def parse_amount_and_currency_for_mode(amount_str: str, mode: str, primary_currency: str):
    """
    Parses an amount string based on the user's currency mode.
    - dual: Detects 'khr' or defaults to 'USD'.
    - single: Ignores currency tags, always uses primary_currency.
    """
    if mode == 'single':
        try:
            # In single mode, just strip all non-numeric characters
            amount_val = float(re.sub(r"[^0-9.]", "", amount_str))
            return amount_val, primary_currency
        except ValueError:
            raise ValueError("Invalid amount for single currency mode")
    else:
        # Use the original dual-currency logic
        return parse_amount_and_currency_dual(amount_str)


def parse_date_from_args(args):
    """Extracts an optional date (MM-DD or DD-MM) from the end of an arg list."""
    if not args:
        return None, args

    date_str = args[-1]
    parsed_date = None
    today = datetime.now(PHNOM_PENH_TZ)

    try:
        parsed_date = datetime.strptime(date_str, '%m-%d')
    except (ValueError, TypeError):
        try:
            parsed_date = datetime.strptime(date_str, '%d-%m')
        except (ValueError, TypeError):
            return None, args # Last arg wasn't a date

    # It was a date, so return it and the args *without* it
    tx_datetime = today.replace(
        month=parsed_date.month, day=parsed_date.day,
        hour=12, minute=0, second=0, microsecond=0
    )
    return tx_datetime.isoformat(), args[:-1]


def _format_success_message(data, context: ContextTypes.DEFAULT_TYPE):
    """Formats a detailed success message for logged items."""
    lines = [t("command.success_header", context)]

    # --- THIS IS THE FIX for "Expense" ---
    type_key = "common.expense_word" if data['type'] == 'expense' else "common.income_word"
    type_val = t(type_key, context)
    lines.append(t("command.success_type", context, type=type_val))
    # --- END FIX ---

    amount = data.get('amount') or data.get('iou_amount')
    currency = data.get('currency') or data.get('iou_currency')

    if currency:
        amount_format = ",.0f" if currency == 'KHR' else ",.2f"
        amount_display = f"{amount:{amount_format}} {currency}"
        lines.append(t("command.success_amount", context, amount_display=amount_display))
    else:
        lines.append(t("command.success_amount", context, amount_display=str(amount)))

    if 'categoryId' in data:
        # Also translate the category name from the map
        category_text = t(f"categories.{data['categoryId']}", context)
        lines.append(t("command.success_category", context, category=category_text))

        if data.get('description'):
            lines.append(t("command.success_description", context, description=data['description']))

    elif 'person' in data:
        lines.append(t("command.success_person", context, person=data['person']))
        if data.get('purpose'):
            lines.append(t("command.success_purpose", context, purpose=data['purpose']))

    if data.get('timestamp'):
        date_obj = datetime.fromisoformat(data['timestamp'])
        date_str = date_obj.strftime('%Y-%m-%d')
        lines.append(t("command.success_date", context, date=date_str))
    else:
        date_str = datetime.now(PHNOM_PENH_TZ).strftime('%Y-%m-%d')
        lines.append(t("command.success_date", context, date=date_str))

    return "\n".join(lines)


# --- MODIFICATION: Decorator added ---
@authenticate_user
async def handle_generic_transaction(update: Update,
                                     context: ContextTypes.DEFAULT_TYPE,
                                     command, args):
    """Handles parsing !expense and !income commands."""
    error_message = t("command.invalid_format_generic", context, command=command)
    try:
        if len(args) < 2:
            await update.message.reply_text(error_message, parse_mode='Markdown')
            return None, None

        mode, primary_curr = _get_user_settings_for_command(context)

        parsed_args = args
        tx_date, remaining_args = parse_date_from_args(parsed_args)

        amount_str = remaining_args[-1]
        amount, currency = parse_amount_and_currency_for_mode(amount_str, mode, primary_curr)

        # --- THIS IS THE FIX for "categories.utilities" ---
        category = remaining_args[0].strip().title()
        # --- END FIX ---

        description = " ".join(remaining_args[1:-1])

        tx_data = {
            "type": command, "amount": amount, "currency": currency,
            "accountName": f"{currency} Account", "categoryId": category,
            "description": description, "timestamp": tx_date
        }
        return tx_data, _format_success_message(tx_data, context)
    except Exception as e:
        logger.error(f"Error parsing generic transaction: {e}", exc_info=True)
        await update.message.reply_text(error_message, parse_mode='Markdown')
        return None, None


# --- MODIFICATION: Decorator added ---
@authenticate_user
async def handle_generic_debt(update: Update,
                              context: ContextTypes.DEFAULT_TYPE,
                              command, args):
    """Handles parsing !lent and !borrowed commands."""
    error_message = t("command.invalid_format_debt", context, command=command)
    try:
        if len(args) < 2:
            await update.message.reply_text(error_message, parse_mode='Markdown')
            return None, None

        mode, primary_curr = _get_user_settings_for_command(context)

        parsed_args = args
        tx_date, remaining_args = parse_date_from_args(parsed_args)

        person = remaining_args[0]
        amount_str = remaining_args[1]
        amount, currency = parse_amount_and_currency_for_mode(amount_str, mode, primary_curr)

        purpose = " ".join(remaining_args[2:])
        debt_data = {
            "type": command, "person": person, "amount": amount,
            "currency": currency, "purpose": purpose, "timestamp": tx_date
        }
        return debt_data, _format_success_message(debt_data, context)
    except Exception as e:
        logger.error(f"Error parsing generic debt: {e}", exc_info=True)
        await update.message.reply_text(error_message, parse_mode='Markdown')
        return None, None


# --- MODIFICATION: Decorator added ---
@authenticate_user
async def handle_quick_command(update: Update,
                               context: ContextTypes.DEFAULT_TYPE,
                               command, args):
    """Handles parsing predefined quick commands like !coffee."""
    try:
        mode, primary_curr = _get_user_settings_for_command(context)

        parsed_args = args
        tx_date, remaining_args = parse_date_from_args(parsed_args)

        if not remaining_args:
            await update.message.reply_text(
                t("command.invalid_format_missing_amount", context),
                parse_mode='Markdown'
            )
            return None, None

        amount_str = remaining_args[-1]
        amount, currency = parse_amount_and_currency_for_mode(amount_str, mode, primary_curr)

        description_parts = remaining_args[:-1]
        details = COMMAND_MAP[command]
        description = (" ".join(description_parts) if description_parts
                       else details['description'])

        tx_data = {
            "type": details['type'], "amount": amount, "currency": currency,
            "accountName": f"{currency} Account",
            "categoryId": details['categoryId'],
            "description": description, "timestamp": tx_date
        }
        return tx_data, _format_success_message(tx_data, context)
    except Exception as e:
        logger.error(f"Error in quick_command_handler: {e}", exc_info=True)
        await update.message.reply_text(
            t("command.error_generic", context)
        )
        return None, None


# --- MODIFICATION: Decorator added ---
@authenticate_user
async def handle_repayment(update: Update, context: ContextTypes.DEFAULT_TYPE,
                           args, debt_type: str):
    """Handles parsing !paid and !repaid by commands."""
    try:
        user_id = context.user_data['user_profile']['_id']
        mode, primary_curr = _get_user_settings_for_command(context)

        command_example = (
            "`!repaid by <Person> <Amount>[khr] [MM-DD]`"
            if debt_type == 'lent'
            else "`!paid <Person> <Amount>[khr] [MM-DD]`"
        )
        parsed_args = args
        tx_date, remaining_args = parse_date_from_args(parsed_args)

        if len(remaining_args) < 2:
            await update.message.reply_text(
                t("command.invalid_format_repayment",
                  context, example=command_example),
                parse_mode='Markdown'
            )
            return

        person = remaining_args[0]
        amount_str = remaining_args[1]
        amount, currency = parse_amount_and_currency_for_mode(amount_str, mode, primary_curr)

        response = api_client.record_lump_sum_repayment(
            person, currency, amount, debt_type, user_id, tx_date
        )
        base_text = response.get('message', 'âŒ An error occurred.')
        if response.get('error'):
            base_text = t("command.repayment_error",
                          context, error=response.get('error'))

    except Exception as e:
        logger.error(f"Error in handle_repayment: {e}", exc_info=True)
        base_text = t("command.repayment_fail", context)

    summary_text = format_summary_message(
        api_client.get_detailed_summary(user_id), context
    )
    await update.message.reply_text(
        base_text + summary_text,
        parse_mode='HTML',
        reply_markup=keyboards.main_menu_keyboard(context)
    )


# --- MODIFICATION: Decorator REMOVED from this entry point ---
async def unified_message_router(update: Update,
                                 context: ContextTypes.DEFAULT_TYPE):
    """The main router for all text messages, now authenticated."""
    full_text = update.message.text
    logger.info(f"--- Message router received text: '{full_text}' ---")

    if not full_text.startswith('!'):
        if '=' in full_text:
            expression = full_text.split('=')[0].strip()
            try:
                result = aeval.eval(expression)
                await update.message.reply_text(
                    t("command.calculating", context, result=result),
                    parse_mode='Markdown'
                )
            except Exception:
                logger.error(f"Calculator error for '{expression}'")
                await update.message.reply_text(
                    t("command.calculator_fail", context)
                )
        else:
            logger.info("Ignoring message, no '!' prefix or '=' found.")
        return ConversationHandler.END

    full_text = full_text[1:].strip()
    full_text_fixed = full_text.replace(
        'â€œ', '"').replace('â€', '"').replace("â€˜", "'").replace("â€™", "'")

    try:
        parts = shlex.split(full_text_fixed)
    except ValueError as e:
        logger.warning(f"Shlex parsing error: {e}. Likely an unclosed quote.")
        await update.message.reply_text(
            t("command.parse_error", context, error=e)
        )
        return ConversationHandler.END

    if not parts:
        return ConversationHandler.END

    command = parts[0].lower()
    args = parts[1:]

    # --- MODIFICATION: We must get the user_id *here* to pass it down,
    # but we can't block. We rely on the called functions to be decorated.
    # We fetch it manually ONLY for the final summary.
    user_profile = context.user_data.get('user_profile')
    if not user_profile:
        # This can happen if the user's first message is a command
        # The decorated functions will handle the auth flow
        logger.info("No user profile in context, decorated function will auth.")
    # ---

    try:
        if full_text.lower().startswith("repaid by") or \
                full_text.lower().startswith("paid by"):
            args = parts[2:]
            # This function is now decorated, it will handle auth
            await handle_repayment(update, context, args, debt_type='lent')
            return ConversationHandler.END

        if command in ["paid", "repaid"]:
            # This function is now decorated, it will handle auth
            await handle_repayment(update, context, args, debt_type='borrowed')
            return ConversationHandler.END

        tx_data, debt_data, base_text = None, None, None

        if command in ["expense", "income"]:
            # This function is now decorated, it will handle auth
            tx_data, base_text = await handle_generic_transaction(
                update, context, command, args
            )
        elif command in ["lent", "borrowed"]:
            # This function is now decorated, it will handle auth
            debt_data, base_text = await handle_generic_debt(
                update, context, command, args
            )
        elif command in COMMAND_MAP:
            # This function is now decorated, it will handle auth
            tx_data, base_text = await handle_quick_command(
                update, context, command, args
            )
        else:
            context.user_data['unknown_command_data'] = {
                'command': command, 'args': args
            }
            # This function is now decorated, it will handle auth
            return await unknown_command_entry_point(update, context)

        # If any of the above functions returned, it means auth is in progress
        # or an error was sent. If they return data, we proceed.
        if (tx_data or debt_data) and base_text:
            user_id = context.user_data['user_profile']['_id']
            if tx_data:
                response = api_client.add_transaction(tx_data, user_id)
                if not response:
                    base_text = t("command.tx_fail", context)
            elif debt_data:
                response = api_client.add_debt(debt_data, user_id)
                if not response:
                    base_text = t("command.debt_fail", context)

            summary_text = format_summary_message(
                api_client.get_detailed_summary(user_id), context
            )
            await update.message.reply_text(
                base_text + summary_text,
                parse_mode='HTML',
                reply_markup=keyboards.main_menu_keyboard(context)
            )

        return ConversationHandler.END

    except Exception as e:
        # This will catch errors if auth failed and context.user_data['user_profile'] is missing
        if "user_profile" not in context.user_data:
            logger.info("Action blocked, user is being onboarded.")
            return ConversationHandler.END # Onboarding is active

        logger.error(f"Error in unified_message_router: {e}", exc_info=True)
        await update.message.reply_text(t("command.error_parsing", context))
        return ConversationHandler.END


# --- UNKNOWN ITEM CONVERSATION ---
# --- MODIFICATION: Decorator added ---
@authenticate_user
async def unknown_command_entry_point(update: Update,
                                      context: ContextTypes.DEFAULT_TYPE):
    """Entry point for handling unknown commands as potential expenses."""
    try:
        data = context.user_data['unknown_command_data']
        command, args = data['command'], data['args']
        tx_date, args_without_date = parse_date_from_args(args)

        if not args_without_date:
            await update.message.reply_text(
                t("command.unknown_fail", context)
            )
            return ConversationHandler.END

        amount_str = args_without_date[-1]
        description_parts = args_without_date[:-1]

        mode, primary_curr = _get_user_settings_for_command(context)

        try:
            amount, currency = parse_amount_and_currency_for_mode(amount_str, mode, primary_curr)
        except ValueError:
            await update.message.reply_text(t("command.unknown_fail", context))
            return ConversationHandler.END

        description = command.replace('_', ' ').title()
        if description_parts:
            description += f" {' '.join(description_parts)}"

        context.user_data['new_tx'] = {
            "type": "expense", "amount": amount, "currency": currency,
            "accountName": f"{currency} Account", "description": description,
            "timestamp": tx_date
        }

        if currency == 'KHR':
            amount_display = f"{amount:,.0f} {currency}"
        elif currency:
            amount_display = f"{amount:,.2f} {currency}"
        else: # Fallback for single mode with no symbol
            amount_display = f"{amount:,.2f}"

        # Get user's dynamic categories
        profile = context.user_data['user_profile']
        all_categories = profile.get('settings', {}).get('categories', {})
        user_categories = all_categories.get('expense', [])
        keyboard = keyboards.expense_categories_keyboard(user_categories,
                                                         context)

        await update.message.reply_text(
            t("command.unknown_prompt", context,
              description=description, amount_display=amount_display),
            reply_markup=keyboard
        )
        return SELECT_CATEGORY
    except Exception as e:
        logger.error(f"Error starting unknown command flow: {e}", exc_info=True)
        return ConversationHandler.END


async def received_category_for_unknown(update: Update,
                                        context: ContextTypes.DEFAULT_TYPE):
    """Handles category selection for the unknown command."""
    query = update.callback_query
    await query.answer()
    category = query.data.split('_')[1]

    if category == 'other':
        await query.edit_message_text(
            t("command.unknown_ask_custom", context)
        )
        return GET_CUSTOM_CATEGORY

    tx_data = context.user_data.get('new_tx')
    if not tx_data:
        return ConversationHandler.END

    tx_data['categoryId'] = category
    return await save_and_end_unknown(query.message, context)


async def received_text_for_custom_category(update: Update,
                                            context: ContextTypes.DEFAULT_TYPE):
    """Handles custom category text for the unknown command."""
    tx_data = context.user_data.get('new_tx')
    if not tx_data:
        return ConversationHandler.END

    tx_data['categoryId'] = update.message.text.strip().title()
    return await save_and_end_unknown(update.message, context)


async def save_and_end_unknown(message, context: ContextTypes.DEFAULT_TYPE):
    """Saves the transaction from the unknown command flow."""
    user_id = context.user_data['user_profile']['_id']
    tx_data = context.user_data.get('new_tx')
    if not tx_data:
        return ConversationHandler.END

    response = api_client.add_transaction(tx_data, user_id)

    base_text = (_format_success_message(tx_data, context)
                 if response else t("command.tx_fail", context))
    summary_text = format_summary_message(
        api_client.get_detailed_summary(user_id), context
    )

    await message.reply_text(
        base_text + summary_text,
        parse_mode='HTML',
        reply_markup=keyboards.main_menu_keyboard(context)
    )
    return ConversationHandler.END


unified_message_conversation_handler = ConversationHandler(
    entry_points=[MessageHandler(
        filters.TEXT & ~filters.COMMAND, unified_message_router
    )],
    states={
        SELECT_CATEGORY: [CallbackQueryHandler(
            received_category_for_unknown, pattern='^cat_'
        )],
        GET_CUSTOM_CATEGORY: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, received_text_for_custom_category
        )],
    },
    fallbacks=[
        CommandHandler('cancel', cancel),
        CommandHandler('start', start),
        CallbackQueryHandler(start, pattern='^start$')
    ],
    per_message=False,
    conversation_timeout=60
)
# --- End of modified file ---

============================================================

==================== FILE: telegram_bot/handlers/common.py ====================
# --- Start of modified file: telegram_bot/handlers/common.py ---

from telegram import Update
from telegram.ext import ContextTypes, ConversationHandler
import keyboards
import api_client
from decorators import authenticate_user
from .helpers import format_summary_message
from utils.i18n import t


@authenticate_user
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Displays the main menu and forcibly ends any active conversation."""

    user_profile = context.user_data['user_profile']
    user_id = user_profile['_id']

    # Get preferred name based on language
    lang = user_profile.get('settings', {}).get('language', 'en')
    user_name = user_profile.get('name_en', 'User')
    if lang == 'km' and user_profile.get('name_km'):
        user_name = user_profile.get('name_km')

    text = t("common.welcome", context, name=user_name)
    keyboard = keyboards.main_menu_keyboard(context)
    chat_id = update.effective_chat.id

    summary_data = api_client.get_detailed_summary(user_id)
    summary_text = format_summary_message(summary_data, context)

    if update.callback_query:
        await update.callback_query.answer()
        try:
            await update.callback_query.edit_message_text(
                text + summary_text,
                parse_mode='HTML',
                reply_markup=keyboard
            )
        except Exception:
            # Message might be identical, which throws an error
            pass
    else:
        await context.bot.send_message(
            chat_id=chat_id,
            text=text + summary_text,
            parse_mode='HTML',
            reply_markup=keyboard
        )

    return ConversationHandler.END


@authenticate_user
async def quick_check(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Fetches and displays a quick summary of balances and debts."""
    query = update.callback_query
    await query.answer("Fetching summary...")

    user_id = context.user_data['user_profile']['_id']

    summary_data = api_client.get_detailed_summary(user_id)
    summary_text = format_summary_message(summary_data, context)
    text = t("common.quick_check_header", context) + summary_text

    await query.edit_message_text(
        text=text,
        parse_mode='HTML',
        reply_markup=keyboards.main_menu_keyboard(context)
    )


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Cancels any active conversation."""

    # Preserve the user profile, clear everything else
    user_profile = context.user_data.get('user_profile')
    context.user_data.clear()
    if user_profile:
        context.user_data['user_profile'] = user_profile

    message = t("common.cancel", context)
    keyboard = keyboards.main_menu_keyboard(context)
    chat_id = update.effective_chat.id

    if update.callback_query:
        await update.callback_query.answer()
        try:
            await update.callback_query.edit_message_text(
                text=message, reply_markup=keyboard
            )
        except Exception:
            await context.bot.send_message(
                chat_id=chat_id, text=message, reply_markup=keyboard
            )
    else:
        await context.bot.send_message(
            chat_id=chat_id, text=message, reply_markup=keyboard
        )

    return ConversationHandler.END
# --- End of modified file ---

============================================================

==================== FILE: telegram_bot/handlers/helpers.py ====================
# --- Start of modified file: telegram_bot/handlers/helpers.py ---

from datetime import datetime
import io
import csv
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from zoneinfo import ZoneInfo
import pandas as pd
from telegram.ext import ContextTypes
from utils.i18n import t

PHNOM_PENH_TZ = ZoneInfo("Asia/Phnom_Penh")


def _get_user_settings(context: ContextTypes.DEFAULT_TYPE):
    """Helper to safely get user settings and currency mode."""
    profile = context.user_data.get('user_profile', {})
    settings = profile.get('settings', {})
    mode = settings.get('currency_mode', 'dual')

    if mode == 'single':
        primary_currency = settings.get('primary_currency', 'USD')
        return mode, (primary_currency,)

    # Default to dual if not set
    return 'dual', ('USD', 'KHR')


def format_summary_message(summary_data,
                           context: ContextTypes.DEFAULT_TYPE):
    """Formats the detailed summary data into a readable string."""
    if not summary_data:
        return ""

    mode, currencies = _get_user_settings(context)

    # 1. Balances
    balance_lines = [f"{t('summary.balances', context)}"]
    balances = summary_data.get('balances', {})

    if mode == 'dual':
        usd_bal = balances.get('USD', 0)
        khr_bal = balances.get('KHR', 0)
        balance_lines.append(f"ðŸ’µ {usd_bal:,.2f} USD")
        balance_lines.append(f"áŸ› {khr_bal:,.0f} KHR")
    else:
        currency = currencies[0]
        bal = balances.get(currency, 0)
        # Apply currency-specific formatting
        amount_format = ",.0f" if currency == 'KHR' else ",.2f"
        balance_lines.append(f"<b>{bal:{amount_format}} {currency}</b>")

    balance_text = "\n".join(balance_lines)

    # 2. Debts
    debt_lines = [f"{t('summary.debts', context)}"]

    # Owed To You
    debt_lines.append(f"{t('summary.you_are_owed', context)}")
    owed_to_you_data = summary_data.get('debts_owed_to_you', [])
    found_debt_to_you = False
    for currency in currencies:
        total = next((item['total'] for item in owed_to_you_data
                      if item['_id'] == currency), 0)
        if total > 0:
            amount_format = ",.0f" if currency == 'KHR' else ",.2f"
            symbol = "áŸ›" if currency == 'KHR' else "ðŸ’µ"
            debt_lines.append(f"    {symbol} {total:{amount_format}} {currency}")
            found_debt_to_you = True
    if not found_debt_to_you:
        debt_lines.append("    -")

    # Owed By You
    debt_lines.append(f"{t('summary.you_owe', context)}")
    owed_by_you_data = summary_data.get('debts_owed_by_you', [])
    found_debt_by_you = False
    for currency in currencies:
        total = next((item['total'] for item in owed_by_you_data
                      if item['_id'] == currency), 0)
        if total > 0:
            amount_format = ",.0f" if currency == 'KHR' else ",.2f"
            symbol = "áŸ›" if currency == 'KHR' else "ðŸ’µ"
            debt_lines.append(f"    {symbol} {total:{amount_format}} {currency}")
            found_debt_by_you = True
    if not found_debt_by_you:
        debt_lines.append("    -")

    debt_text = "\n".join(debt_lines)

    # 3. Activity Periods
    def format_period_line(period_data):
        income = period_data.get('income', {})
        expense = period_data.get('expense', {})

        income_parts = []
        for currency in currencies:
            if income.get(currency, 0) > 0:
                amount_format = ",.0f" if currency == 'KHR' else ",.2f"
                income_parts.append(f"{income[currency]:{amount_format}} {currency}")
        income_str = ' & '.join(income_parts) if income_parts else "0"

        expense_parts = []
        for currency in currencies:
            if expense.get(currency, 0) > 0:
                amount_format = ",.0f" if currency == 'KHR' else ",.2f"
                expense_parts.append(f"{expense[currency]:{amount_format}} {currency}")
        expense_str = ' & '.join(expense_parts) if expense_parts else "0"

        return (
            f"{t('summary.in', context, value=income_str)}\n"
            f"{t('summary.out', context, value=expense_str)}"
        )

    periods = summary_data.get('periods', {})
    activity_text = ""
    if periods:
        this_month_net = periods.get('this_month', {}).get('net_usd', 0)
        net_emoji = 'âœ…' if this_month_net >= 0 else 'ðŸ”»'

        today_text = (
            f"{t('summary.today', context)}\n"
            f"{format_period_line(periods.get('today', {}))}"
        )
        this_week_text = (
            f"{t('summary.this_week', context)}\n"
            f"{format_period_line(periods.get('this_week', {}))}"
        )
        last_week_text = (
            f"{t('summary.last_week', context)}\n"
            f"{format_period_line(periods.get('last_week', {}))}"
        )
        this_month_text = (
            f"{t('summary.this_month', context)}\n"
            f"{format_period_line(periods.get('this_month', {}))}"
        )

        activity_text = (
            f"{t('summary.activity_header', context)}\n{today_text}\n"
            f"{this_week_text}\n{last_week_text}\n{this_month_text}"
        )

        # Only show Net USD if in dual mode
        if mode == 'dual':
            this_month_net_text = t(
                'summary.net',
                context,
                value=this_month_net,
                emoji=net_emoji
            )
            activity_text += f"\n{this_month_net_text}"

    return (
        f"{t('summary.status_header', context)}\n{balance_text}\n"
        f"\n{debt_text}\n\n{activity_text}"
    )


def format_summation_results(params, results,
                             context: ContextTypes.DEFAULT_TYPE):
    """Formats the results from the summation analytics API."""
    if not results or results.get('total_count', 0) == 0:
        return t('search.no_results', context)

    header = "<b>ðŸ“ˆ Search Totals</b>\n\n"

    query_summary = []
    if params.get('period'):
        query_summary.append(
            f"<b>Period:</b> {params['period'].replace('_', ' ').title()}"
        )
    elif params.get('start_date'):
        start = datetime.fromisoformat(params['start_date'])
        end = datetime.fromisoformat(params['end_date'])
        query_summary.append(
            f"<b>Period:</b> {start:%b %d, %Y} to {end:%b %d, %Y}"
        )

    if params.get('transaction_type'):
        query_summary.append(
            f"<b>Type:</b> {params['transaction_type'].title()}"
        )

    if params.get('categories'):
        query_summary.append(
            f"<b>Categories:</b> {', '.join(params['categories'])}"
        )

    if params.get('keywords'):
        logic = params.get('keyword_logic', 'OR')
        query_summary.append(
            f"<b>Keywords:</b> {', '.join(params['keywords'])} "
            f"(Logic: {logic})"
        )

    header += "\n".join(query_summary) + "\n\n"

    # Date Range
    date_text = ""
    if results.get('earliest_log_utc') and results.get('latest_log_utc'):
        earliest = (
            datetime.fromisoformat(results['earliest_log_utc'])
            .astimezone(PHNOM_PENH_TZ)
            .strftime('%b %d, %Y')
        )
        latest = (
            datetime.fromisoformat(results['latest_log_utc'])
            .astimezone(PHNOM_PENH_TZ)
            .strftime('%b %d, %Y')
        )
        if earliest == latest:
            date_text = f"<b>Date:</b> {earliest}\n"
        else:
            date_text = f"<b>Date Range:</b> {earliest} to {latest}\n"

    # Totals & Stats
    total_count = results['total_count']
    count_text = f"Found <b>{total_count}</b> matching transaction(s).\n"

    stats_lines = []
    for item in results.get('totals_by_currency', []):
        currency = item['currency']
        amount_format = ",.0f" if currency == 'KHR' else ",.2f"
        symbol = "áŸ›" if currency == 'KHR' else "ðŸ’µ"

        stats_lines.append(f"\n--- <b>Stats for {currency}</b> ---")
        stats_lines.append(
            f"  {symbol} <b>Total Sum:</b> {item['total']:{amount_format}} "
            f"{currency}"
        )
        stats_lines.append(f"  <b>Count:</b> {item['count']} transactions")
        stats_lines.append(
            f"  <b>Average:</b> {item['avg']:{amount_format}} {currency}"
        )
        stats_lines.append(
            f"  <b>Highest:</b> {item['max']:{amount_format}} {currency}"
        )
        stats_lines.append(
            f"  <b>Lowest:</b> {item['min']:{amount_format}} {currency}"
        )

    return header + date_text + count_text + "\n".join(stats_lines)


def _format_report_summary_message(data):
    """Formats the detailed report data into a readable string."""
    summary = data.get('summary', {})
    start_date = datetime.fromisoformat(data['startDate']).strftime('%b %d, %Y')
    end_date = datetime.fromisoformat(data['endDate']).strftime('%b %d, %Y')

    start_balance = summary.get('balanceAtStartUSD', 0)
    end_balance = summary.get('balanceAtEndUSD', 0)

    header = f"ðŸ“Š <b>Financial Report</b>\n" \
             f"ðŸ—“ï¸ <i>{start_date} to {end_date}</i>\n\n"
    balance_overview_text = (
        f"<b>Balance Overview (in USD):</b>\n"
        f"â–«ï¸ Starting Balance: ${start_balance:,.2f}\n"
        f"â–«ï¸ Ending Balance: ${end_balance:,.2f}\n\n"
    )

    income = summary.get('totalIncomeUSD', 0)
    expense = summary.get('totalExpenseUSD', 0)
    net = summary.get('netSavingsUSD', 0)
    summary_text = (
        f"<b>Operational Summary (in USD):</b>\n"
        f"â¬†ï¸ Total Income: ${income:,.2f}\n"
        f"â¬‡ï¸ Total Expense: ${expense:,.2f}\n"
        f"<b>Net Savings: ${net:,.2f}</b> {'âœ…' if net >= 0 else 'ðŸ”»'}\n\n"
    )

    insights = data.get('expenseInsights', {})
    insights_text = "<b>Expense Insights:</b>\n"

    top_item = insights.get('topExpenseItem')
    if top_item:
        top_desc = top_item.get('description') or top_item.get('category', 'N/A')
        insights_text += (
            f"    - <b>Top Expense:</b> ${top_item['amount_usd']:,.2f} "
            f"({top_desc}) on {top_item['date']}\n"
        )

    most_day = insights.get('mostExpensiveDay')
    if most_day:
        insights_text += (
            f"    - <b>Busiest Day:</b> {most_day['_id']} "
            f"(${most_day['total_spent_usd']:,.2f})\n"
        )

    least_day = insights.get('leastExpensiveDay')
    if least_day and (not most_day or least_day['_id'] != most_day['_id']):
        insights_text += (
            f"    - <b>Quietest Day:</b> {least_day['_id']} "
            f"(${least_day['total_spent_usd']:,.2f})\n"
        )

    insights_text += "\n"

    expense_breakdown = data.get('expenseBreakdown', [])
    major_expenses = []
    minor_expenses = []
    other_text = ""
    threshold = 4.0

    if expense > 0:
        for item in expense_breakdown:
            percentage = (item['totalUSD'] / expense) * 100
            if percentage < threshold:
                minor_expenses.append(item)
            else:
                major_expenses.append(item)

    expense_text = "<b>Major Expenses:</b>\n"
    if major_expenses:
        for item in major_expenses:
            expense_text += (
                f"    - {item['category']}: ${item['totalUSD']:,.2f}\n"
            )
    else:
        expense_text += "    - No major expenses recorded.\n"

    if minor_expenses:
        other_text = "\n<b>Other Expenses (grouped in chart):</b>\n"
        for item in minor_expenses:
            other_text += (
                f"    - {item['category']}: ${item['totalUSD']:,.2f}\n"
            )

    income_breakdown = data.get('incomeBreakdown', [])
    income_text = "\n<b>Income Sources:</b>\n"
    if income_breakdown:
        for item in income_breakdown[:5]:
            income_text += (
                f"    - {item['category']}: ${item['totalUSD']:,.2f}\n"
            )
    else:
        income_text += "    - No income recorded.\n"

    fin_summary = data.get('financialSummary', {})
    financial_text = "\n<b>Loan & Debt Activity (in USD):</b>\n"
    financial_lines = [
        f"    - Lent to others: ${fin_summary['totalLentUSD']:,.2f}"
        if fin_summary.get('totalLentUSD', 0) > 0 else None,
        f"    - Borrowed from others: ${fin_summary['totalBorrowedUSD']:,.2f}"
        if fin_summary.get('totalBorrowedUSD', 0) > 0 else None,
        f"    - Repayments received: ${fin_summary['totalRepaidToYouUSD']:,.2f}"
        if fin_summary.get('totalRepaidToYouUSD', 0) > 0 else None,
        f"    - Repayments made: ${fin_summary['totalYouRepaidUSD']:,.2f}"
        if fin_summary.get('totalYouRepaidUSD', 0) > 0 else None
    ]
    active_lines = [line for line in financial_lines if line]
    financial_text += "\n".join(
        active_lines
    ) if active_lines else "    - No loan or debt activity."
    return (
            header + balance_overview_text + summary_text + insights_text +
            expense_text + other_text + income_text + financial_text
    )


def _create_income_expense_chart(data, start_date, end_date):
    """Creates a simple bar chart comparing income and expense."""
    summary = data.get('summary', {})
    income = summary.get('totalIncomeUSD', 0)
    expense = summary.get('totalExpenseUSD', 0)
    if income == 0 and expense == 0:
        return None

    date_range_str = f"{start_date.strftime('%b %d, %Y')} to " \
                     f"{end_date.strftime('%b %d, %Y')}"

    labels = ['Income', 'Expense']
    values = [income, expense]
    colors = ['#4CAF50', '#F44336']
    fig, ax = plt.subplots(figsize=(6, 5))

    ax.set_title('Operational Income vs. Expense', pad=20)
    plt.suptitle(date_range_str, y=0.93, fontsize=10)

    bars = ax.bar(labels, values, color=colors)
    ax.set_ylabel('Amount (USD)')
    ax.spines[['top', 'right']].set_visible(False)

    for bar in bars:
        yval = bar.get_height()
        plt.text(bar.get_x() + bar.get_width() / 2.0, yval,
                 f'${yval:,.2f}', va='bottom', ha='center')

    buf = io.BytesIO()
    plt.savefig(buf, format='png', bbox_inches='tight')
    plt.close(fig)
    buf.seek(0)
    return buf.getvalue()


def _create_spending_line_chart(data, start_date, end_date):
    """Creates a line chart for spending over time."""
    spending_data = data.get('spendingOverTime', [])
    if not spending_data:
        return None

    df = pd.DataFrame(spending_data)
    df['date'] = pd.to_datetime(df['date'])
    df = df.set_index('date')

    full_date_range = pd.date_range(start=start_date, end=end_date)
    df = df.reindex(full_date_range, fill_value=0)

    if df['total_spent_usd'].sum() == 0:
        return None

    fig, ax = plt.subplots(figsize=(10, 5))
    ax.plot(df.index, df['total_spent_usd'],
            marker='o', linestyle='-', markersize=4)
    ax.fill_between(df.index, df['total_spent_usd'], color='skyblue', alpha=0.3)

    date_range_str = f"{start_date.strftime('%b %d, %Y')} to " \
                     f"{end_date.strftime('%b %d, %Y')}"
    ax.set_title('Spending Over Time (USD)', pad=20)
    plt.suptitle(date_range_str, y=0.93, fontsize=10)
    ax.set_ylabel('Amount Spent (USD)')
    ax.spines[['top', 'right']].set_visible(False)
    ax.grid(axis='y', linestyle='--', alpha=0.7)

    num_days = len(df)
    if num_days <= 10:
        date_fmt = mdates.DateFormatter('%b %d')
        ax.xaxis.set_major_locator(mdates.DayLocator(interval=1))
    elif num_days <= 90:
        date_fmt = mdates.DateFormatter('%b %d')
        ax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=1,
                                                         byweekday=mdates.MO))
    else:
        date_fmt = mdates.DateFormatter('%b %Y')
        ax.xaxis.set_major_locator(mdates.MonthLocator(interval=1))

    ax.xaxis.set_major_formatter(date_fmt)
    fig.autofmt_xdate()

    buf = io.BytesIO()
    plt.savefig(buf, format='png', bbox_inches='tight')
    plt.close(fig)
    buf.seek(0)
    return buf.getvalue()


def _create_expense_pie_chart(data, start_date, end_date):
    """Creates a pie chart for the expense breakdown."""
    expense_breakdown = data.get('expenseBreakdown', [])
    total_expense = data.get('summary', {}).get('totalExpenseUSD', 0)
    if not expense_breakdown or total_expense == 0:
        return None

    threshold = 4.0
    new_labels = []
    new_sizes = []
    other_total = 0

    if total_expense > 0:
        for item in expense_breakdown:
            percentage = (item['totalUSD'] / total_expense) * 100
            if percentage < threshold:
                other_total += item['totalUSD']
            else:
                new_labels.append(item['category'])
                new_sizes.append(item['totalUSD'])

    if other_total > 0:
        new_labels.append('Other')
        new_sizes.append(other_total)

    labels = new_labels
    sizes = new_sizes

    date_range_str = f"{start_date.strftime('%b %d, %Y')} to " \
                     f"{end_date.strftime('%b %d, %Y')}"

    explode = [0] * len(labels)
    if sizes:
        explode[sizes.index(max(sizes))] = 0.05

    fig, ax = plt.subplots(figsize=(7, 6))
    ax.set_title('Expense Breakdown', pad=20)
    plt.suptitle(date_range_str, y=0.93, fontsize=10)

    ax.pie(sizes, labels=labels, autopct='%1.1f%%',
           startangle=90, pctdistance=0.85, explode=explode)
    ax.axis('equal')
    fig.gca().add_artist(plt.Circle((0, 0), 0.70, fc='white'))

    buf = io.BytesIO()
    plt.savefig(buf, format='png', bbox_inches='tight')
    plt.close(fig)
    buf.seek(0)
    return buf.getvalue()


def _format_habits_message(data):
    """Formats the spending habits data into a readable string."""
    if not data:
        return "Could not analyze spending habits."

    day_text = "\n<b>ðŸ“… Spending by Day of Week:</b>\n"
    by_day = sorted(data.get('byDayOfWeek', []),
                    key=lambda x: x.get('total', 0), reverse=True)
    day_text += "\n".join([
        f"    - {item['day']}s: ${item['total']:,.2f}" for item in by_day
    ]) or "    - Not enough data.\n"

    keyword_text = "\n<b>ðŸ·ï¸ Common Spending Keywords:</b>\n"
    by_keyword = data.get('keywordsByCategory', [])
    if by_keyword:
        for item in by_keyword:
            if item.get('topKeywords'):
                keywords = ", ".join(item['topKeywords'])
                keyword_text += f"    - <b>{item['category']}:</b> {keywords}\n"
    else:
        keyword_text += "    - No descriptions found to analyze.\n"

    return day_text + keyword_text


def _format_debt_analysis_message(analysis_data,
                                  context: ContextTypes.DEFAULT_TYPE):
    """Formats the text summary for the debt analysis."""
    lent_by = [d for d in analysis_data.get('concentration', [])
               if d['type'] == 'lent']
    borrow_from = [d for d in analysis_data.get('concentration', [])
                   if d['type'] == 'borrowed']

    lent_text = t('iou.analysis_lent_header', context)
    lent_text += "\n".join([
        t('iou.analysis_item', context,
          person=item['person'], total=item['total'])
        for item in lent_by[:3]
    ]) or t('iou.analysis_lent_none', context)

    borrow_text = t('iou.analysis_borrow_header', context)
    borrow_text += "\n".join([
        t('iou.analysis_item', context,
          person=item['person'], total=item['total'])
        for item in borrow_from[:3]
    ]) or t('iou.analysis_borrow_none', context)

    aging_text = t('iou.analysis_aging_header', context)
    aging_data = analysis_data.get('aging', [])
    aging_text += "\n".join([
        t('iou.analysis_aging_item', context,
          person=item['_id'], days=item['averageAgeDays'],
          count=item['count'])
        for item in aging_data[:3]
    ]) or t('iou.analysis_aging_none', context)

    return (
        f"{t('iou.analysis_header', context)}\n"
        f"{lent_text}\n{borrow_text}\n{aging_text}"
    )


def _create_debt_overview_pie(analysis_data):
    """Creates a pie chart for total owed vs. total lent in USD."""
    overview = analysis_data.get('overview_usd', {})
    lent_usd = overview.get('total_lent_usd', 0)
    borrowed_usd = overview.get('total_borrowed_usd', 0)

    if lent_usd == 0 and borrowed_usd == 0:
        return None

    labels = ['You Are Owed', 'You Owe']
    sizes = [lent_usd, borrowed_usd]
    colors = ['#4CAF50', '#F44336']
    explode = (0.05, 0)

    fig, ax = plt.subplots(figsize=(7, 6))
    ax.set_title('Debt Overview (USD Equivalent)', pad=20)

    wedges, texts, autotexts = ax.pie(
        sizes,
        labels=labels,
        autopct=lambda p: f'${p * sum(sizes) / 100:,.2f}\n({p:.1f}%)',
        startangle=90,
        pctdistance=0.75,
        explode=explode,
        colors=colors
    )
    plt.setp(autotexts, size=10, weight="bold", color="white")
    ax.axis('equal')
    fig.gca().add_artist(plt.Circle((0, 0), 0.60, fc='white'))

    buf = io.BytesIO()
    plt.savefig(buf, format='png', bbox_inches='tight')
    plt.close(fig)
    buf.seek(0)
    return buf.getvalue()


def _create_debt_concentration_bar(analysis_data):
    """Creates a horizontal bar chart for debt concentration by person."""
    concentration = analysis_data.get('concentration', [])
    if not concentration:
        return None

    lent_data = sorted(
        [d for d in concentration if d['type'] == 'lent'],
        key=lambda x: x['total'], reverse=True
    )[:5]
    borrow_data = sorted(
        [d for d in concentration if d['type'] == 'borrowed'],
        key=lambda x: x['total'], reverse=True
    )[:5]

    if not lent_data and not borrow_data:
        return None

    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6), sharey=False)

    # Plot 1: You Are Owed (Lent)
    if lent_data:
        people_lent = [d['person'] for d in lent_data]
        amounts_lent = [d['total'] for d in lent_data]
        ax1.barh(people_lent, amounts_lent, color='#4CAF50')
        ax1.set_title('You Are Owed (Top 5)')
        ax1.set_xlabel('Amount (USD Equivalent)')
        ax1.invert_yaxis()
        for i, v in enumerate(amounts_lent):
            ax1.text(v + 1, i, f' ${v:,.2f}', va='center', color='black')
    else:
        ax1.set_title('You Are Owed')
        ax1.text(0.5, 0.5, 'No data',
                 horizontalalignment='center', verticalalignment='center',
                 transform=ax1.transAxes)
    ax1.spines[['top', 'right']].set_visible(False)

    # Plot 2: You Owe (Borrowed)
    if borrow_data:
        people_borrow = [d['person'] for d in borrow_data]
        amounts_borrow = [d['total'] for d in borrow_data]
        ax2.barh(people_borrow, amounts_borrow, color='#F44336')
        ax2.set_title('You Owe (Top 5)')
        ax2.set_xlabel('Amount (USD Equivalent)')
        ax2.invert_yaxis()
        for i, v in enumerate(amounts_borrow):
            ax2.text(v + 1, i, f' ${v:,.2f}', va='center', color='black')
    else:
        ax2.set_title('You Owe')
        ax2.text(0.5, 0.5, 'No data',
                 horizontalalignment='center', verticalalignment='center',
                 transform=ax2.transAxes)
    ax2.spines[['top', 'right']].set_visible(False)

    plt.suptitle('Debt Concentration', fontsize=16, y=1.02)
    plt.tight_layout(pad=2.0)

    buf = io.BytesIO()
    plt.savefig(buf, format='png', bbox_inches='tight')
    plt.close(fig)
    buf.seek(0)
    return buf.getvalue()


# --- NEW CSV EXPORT HELPERS ---

def _create_csv_from_transactions(transactions_data: list) -> io.BytesIO:
    """Converts a list of transaction dicts into an in-memory CSV file."""
    output = io.StringIO()
    writer = csv.writer(output)

    # Write Header
    headers = [
        "Date (Local)", "Type", "Amount", "Currency",
        "Category", "Description", "Transaction ID"
    ]
    writer.writerow(headers)

    # Write Data
    for tx in transactions_data:
        dt_utc = datetime.fromisoformat(tx['timestamp'])
        dt_local = dt_utc.astimezone(PHNOM_PENH_TZ)
        writer.writerow([
            dt_local.strftime('%Y-%m-%d %H:%M:%S'),
            tx.get('type'),
            tx.get('amount'),
            tx.get('currency'),
            tx.get('categoryId'),
            tx.get('description', ''),
            tx.get('_id')
        ])

    # Convert to BytesIO
    buffer = io.BytesIO()
    buffer.write(output.getvalue().encode('utf-8'))
    buffer.seek(0)
    output.close()
    return buffer


def _create_csv_from_debts(debts_data: list) -> io.BytesIO:
    """Converts a list of debt dicts into an in-memory CSV file."""
    output = io.StringIO()
    writer = csv.writer(output)

    # Write Header
    headers = [
        "Date Created (Local)", "Type", "Person", "Original Amount",
        "Remaining Amount", "Currency", "Status", "Purpose", "Debt ID"
    ]
    writer.writerow(headers)

    # Write Data
    for debt in debts_data:
        dt_utc = datetime.fromisoformat(debt['created_at'])
        dt_local = dt_utc.astimezone(PHNOM_PENH_TZ)
        writer.writerow([
            dt_local.strftime('%Y-%m-%d %H:%M:%S'),
            debt.get('type'),
            debt.get('person'),
            debt.get('originalAmount'),
            debt.get('remainingAmount'),
            debt.get('currency'),
            debt.get('status'),
            debt.get('purpose', ''),
            debt.get('_id')
        ])

    # Convert to BytesIO
    buffer = io.BytesIO()
    buffer.write(output.getvalue().encode('utf-8'))
    buffer.seek(0)
    output.close()
    return buffer

# --- End of modified file ---

============================================================

==================== FILE: telegram_bot/handlers/iou.py ====================
# --- Start of file: telegram_bot/handlers/iou.py ---

from telegram import Update
from telegram.ext import ContextTypes, ConversationHandler
import keyboards
import api_client
from decorators import authenticate_user
from datetime import datetime, timedelta, time
from zoneinfo import ZoneInfo
from .helpers import (
    format_summary_message,
    _format_debt_analysis_message,
    _create_debt_overview_pie,
    _create_debt_concentration_bar,
    _create_csv_from_debts
)
from .command_handler import parse_amount_and_currency_for_mode
from utils.i18n import t
import re

# Conversation states
(
    IOU_ASK_DATE, IOU_CUSTOM_DATE, IOU_PERSON, IOU_AMOUNT, IOU_CURRENCY, IOU_PURPOSE,
    REPAY_LUMP_AMOUNT,
    IOU_EDIT_GET_VALUE
) = range(8)

PHNOM_PENH_TZ = ZoneInfo("Asia/Phnom_Penh")


def _get_user_settings_for_iou(context: ContextTypes.DEFAULT_TYPE):
    """Helper to get currency mode and primary currency."""
    profile = context.user_data.get('user_profile', {})
    settings = profile.get('settings', {})
    mode = settings.get('currency_mode', 'dual')

    if mode == 'single':
        primary_currency = settings.get('primary_currency', 'USD')
        return mode, (primary_currency,)

    return 'dual', ('USD', 'KHR')


def _format_debt_details(debt, context: ContextTypes.DEFAULT_TYPE):
    """Helper to format the full details of a debt, including repayments."""
    direction = t("iou.debt_direction_lent", context) if debt['type'] == 'lent' else t("iou.debt_direction_borrowed", context)
    purpose_text = t("iou.debt_purpose", context, purpose=debt['purpose']) if debt.get('purpose') else ""
    created_date = datetime.fromisoformat(debt['created_at'].replace('Z', '+00:00')).astimezone(PHNOM_PENH_TZ).strftime(
        '%d %b %Y, %I:%M %p')

    currency = debt.get('currency', 'USD')
    amount_format = ",.0f" if currency == 'KHR' else ",.2f"

    text_lines = [
        t("iou.debt_details_header", context, status=debt['status'].title()),
        t("iou.debt_person", context, person=debt['person'], direction=direction),
        t("iou.debt_created", context, date=created_date),
        purpose_text,
        t("iou.debt_original", context, amount=f"{debt['originalAmount']:{amount_format}}", currency=currency),
        t("iou.debt_remaining", context, amount=f"{debt['remainingAmount']:{amount_format}}", currency=currency)
    ]

    repayments = debt.get('repayments', [])
    if repayments:
        text_lines.append(t("iou.debt_repayments", context))
        for rep in repayments:
            rep_date = datetime.fromisoformat(rep['date'].replace('Z', '+00:00')).astimezone(PHNOM_PENH_TZ).strftime('%d %b %Y')
            text_lines.append(t("iou.debt_repayment_item", context, amount=f"{rep['amount']:{amount_format}}", currency=currency, date=rep_date))

    return "\n".join(text_lines)


def _format_person_ledger(person_debts, context: ContextTypes.DEFAULT_TYPE, is_settled=False):
    """Formats all debts and repayments for one person into a single chronological list."""

    if not person_debts:
        return t("iou.person_fail", context, person="this person")

    mode, currencies = _get_user_settings_for_iou(context)
    ledger_items = []

    totals_remaining = {curr: 0 for curr in currencies}

    for debt in person_debts:
        created_dt = datetime.fromisoformat(debt['created_at'].replace('Z', '+00:00'))
        currency = debt.get('currency', 'USD')

        # Only process debts that match the user's currency mode
        if currency not in currencies:
            continue

        amount_format = ",.0f" if currency == 'KHR' else ",.2f"

        if currency in totals_remaining:
            totals_remaining[currency] += debt['remainingAmount']

        purpose = debt.get('purpose') or "No purpose"
        amount = debt['originalAmount']
        status_icon = "âœ…" if debt['status'] == 'settled' else ("âŒ" if debt['status'] == 'canceled' else "ðŸ”¹")

        debt_text = f"{status_icon} <b>{amount:{amount_format}} {currency}</b> ({purpose})"
        ledger_items.append((created_dt, debt_text, currency))

        for rep in debt.get('repayments', []):
            rep_dt = datetime.fromisoformat(rep['date'].replace('Z', '+00:00'))
            rep_text = f"  <i>- Repaid {rep['amount']:{amount_format}} {currency}</i>"
            ledger_items.append((rep_dt, rep_text, currency))

    ledger_items.sort(key=lambda x: x[0])

    date_format = '%d %b %Y'
    last_date = None
    ledger_lines = []

    if not is_settled:
        header_lines = [t("iou.ledger_total_remaining", context)]
        found_remaining = False

        if mode == 'dual':
            if totals_remaining.get('USD', 0) > 0:
                header_lines.append(f"  ðŸ’µ {totals_remaining['USD']:,.2f} USD")
                found_remaining = True
            if totals_remaining.get('KHR', 0) > 0:
                header_lines.append(f"  áŸ› {totals_remaining['KHR']:,.0f} KHR")
                found_remaining = True
        else:
            currency = currencies[0]
            if totals_remaining.get(currency, 0) > 0:
                amount_format = ",.0f" if currency == 'KHR' else ",.2f"
                header_lines.append(f"  <b>{totals_remaining[currency]:{amount_format}} {currency}</b>")
                found_remaining = True

        if not found_remaining:
            header_lines.append(t("iou.ledger_none", context))

        ledger_lines.append("\n".join(header_lines) + "\n")

    ledger_lines.append(t("iou.ledger_header", context))

    for item_dt, item_text, item_currency in ledger_items:
        current_date_str = item_dt.astimezone(PHNOM_PENH_TZ).strftime(date_format)
        if current_date_str != last_date:
            ledger_lines.append(f"\n<u>{current_date_str}</u>")
            last_date = current_date_str
        ledger_lines.append(item_text)

    return "\n".join(ledger_lines)


# --- IOU Menu & Standalone Handlers ---
@authenticate_user
async def iou_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Displays the IOU management menu."""
    query = update.callback_query
    await query.answer()
    await query.edit_message_text(
        text=t("iou.menu_header", context),
        reply_markup=keyboards.iou_menu_keyboard(context)
    )


@authenticate_user
async def iou_view(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows a summary list of all open debts, grouped by person."""
    query = update.callback_query
    await query.answer()

    user_id = context.user_data['user_profile']['_id']
    grouped_debts = api_client.get_open_debts(user_id)

    text = t("iou.view_header_open", context)
    keyboard = keyboards.iou_list_keyboard(grouped_debts, context, is_settled=False)
    if not grouped_debts:
        text = t("iou.view_no_open", context)
        keyboard = keyboards.iou_menu_keyboard(context)
    await query.edit_message_text(text=text, reply_markup=keyboard, parse_mode='Markdown')


@authenticate_user
async def iou_view_settled(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows a summary list of all settled debts, grouped by person."""
    query = update.callback_query
    await query.answer()

    user_id = context.user_data['user_profile']['_id']
    grouped_debts = api_client.get_settled_debts_grouped(user_id)

    text = t("iou.view_header_settled", context)
    keyboard = keyboards.iou_list_keyboard(grouped_debts, context, is_settled=True)
    if not grouped_debts:
        text = t("iou.view_no_settled", context)
        keyboard = keyboards.iou_menu_keyboard(context)
    await query.edit_message_text(text=text, reply_markup=keyboard, parse_mode='Markdown')


@authenticate_user
async def iou_person_detail(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows a unified ledger of all open debts for a specific person."""
    query = update.callback_query
    await query.answer()
    _, _, _, person_name = query.data.split(':')

    user_id = context.user_data['user_profile']['_id']
    person_debts = api_client.get_all_debts_by_person(person_name, user_id)

    if not person_debts:
        await query.edit_message_text(
            t("iou.person_fail", context, person=person_name),
            reply_markup=keyboards.iou_menu_keyboard(context)
        )
        return

    debt_type = person_debts[0]['type']
    direction = t("iou.person_direction_lent", context) if debt_type == 'lent' else t("iou.person_direction_borrowed", context)

    header = t("iou.person_header_open", context, person=person_name, direction=direction)
    ledger_text = _format_person_ledger(person_debts, context, is_settled=False)

    await query.edit_message_text(
        text=header + ledger_text,
        parse_mode='HTML',
        reply_markup=keyboards.iou_person_actions_keyboard(person_name, debt_type, context, is_settled=False)
    )


@authenticate_user
async def iou_person_detail_settled(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows a unified ledger of all settled debts for a specific person."""
    query = update.callback_query
    await query.answer()
    _, _, _, person_name = query.data.split(':')

    user_id = context.user_data['user_profile']['_id']
    person_debts = api_client.get_all_settled_debts_by_person(person_name, user_id)

    if not person_debts:
        await query.edit_message_text(
            t("iou.person_fail_settled", context, person=person_name),
            reply_markup=keyboards.iou_menu_keyboard(context)
        )
        return

    debt_type = person_debts[0]['type']
    direction = t("iou.person_direction_lent_past", context) if debt_type == 'lent' else t("iou.person_direction_borrowed_past", context)

    header = t("iou.person_header_settled", context, person=person_name, direction=direction)
    ledger_text = _format_person_ledger(person_debts, context, is_settled=True)

    await query.edit_message_text(
        text=header + ledger_text,
        parse_mode='HTML',
        reply_markup=keyboards.iou_person_actions_keyboard(person_name, debt_type, context, is_settled=True)
    )


@authenticate_user
async def iou_manage_list(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Displays a list of individual debts for management (Edit/Cancel)."""
    query = update.callback_query
    await query.answer()
    _, _, _, person_name, debt_type, is_settled_str = query.data.split(':')
    is_settled = is_settled_str == 'True'

    user_id = context.user_data['user_profile']['_id']
    if is_settled:
        person_debts = api_client.get_all_settled_debts_by_person(person_name, user_id)
    else:
        person_debts = api_client.get_all_debts_by_person(person_name, user_id)

    if not person_debts:
        await query.edit_message_text(
            t("iou.manage_fail", context),
            reply_markup=keyboards.iou_menu_keyboard(context)
        )
        return

    await query.edit_message_text(
        t("iou.manage_header", context),
        reply_markup=keyboards.iou_manage_list_keyboard(person_debts, person_name, debt_type, is_settled, context)
    )


@authenticate_user
async def iou_detail(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows details for a single debt, open or settled."""
    query = update.callback_query
    await query.answer()
    _, _, debt_id, person_name, is_settled_str = query.data.split(':')
    is_settled = is_settled_str == 'True'

    user_id = context.user_data['user_profile']['_id']
    debt = api_client.get_debt_details(debt_id, user_id)

    if not debt:
        await query.edit_message_text(
            t("iou.detail_fail", context),
            reply_markup=keyboards.iou_menu_keyboard(context)
        )
        return

    text = _format_debt_details(debt, context)
    keyboard = keyboards.iou_detail_actions_keyboard(debt_id, person_name, debt['type'], is_settled, debt['status'], context)
    await query.edit_message_text(text=text, parse_mode='HTML', reply_markup=keyboard)


@authenticate_user
async def debt_analysis(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Fetches, displays debt analysis text, and sends charts."""
    query = update.callback_query
    await query.answer(t("iou.analysis_loading", context))
    chat_id = update.effective_chat.id

    user_id = context.user_data['user_profile']['_id']
    analysis_data = api_client.get_debt_analysis(user_id)

    if not analysis_data:
        await query.edit_message_text(
            t("iou.analysis_fail", context),
            reply_markup=keyboards.iou_menu_keyboard(context)
        )
        return

    final_text = _format_debt_analysis_message(analysis_data, context)
    await query.edit_message_text(
        text=final_text,
        parse_mode='HTML',
        reply_markup=keyboards.debt_analysis_actions_keyboard(context)
    )

    if overview_pie := _create_debt_overview_pie(analysis_data):
        await context.bot.send_photo(chat_id=chat_id, photo=overview_pie)
    if concentration_bar := _create_debt_concentration_bar(analysis_data):
        await context.bot.send_photo(chat_id=chat_id, photo=concentration_bar)


# --- NEW HANDLER FOR DEBT CSV EXPORT ---
@authenticate_user
async def download_debt_analysis_csv(update: Update,
                                     context: ContextTypes.DEFAULT_TYPE):
    """Handles the 'Download Open Debts CSV' button press."""
    query = update.callback_query
    await query.answer(t("search.searching", context))

    try:
        user_id = context.user_data['user_profile']['_id']
        debts = api_client.get_open_debts_export(user_id)

        if not debts:
            await query.message.reply_text(t("iou.view_no_open", context))
            return

        csv_buffer = _create_csv_from_debts(debts)
        file_name = f"open_debts_export_{datetime.now(PHNOM_PENH_TZ).strftime('%Y%m%d')}.csv"

        await context.bot.send_document(
            chat_id=update.effective_chat.id,
            document=csv_buffer,
            filename=file_name,
            caption="Here is your export of all open debts."
        )

    except Exception as e:
        print(f"Error generating debt CSV: {e}")
        await query.message.reply_text(t("common.error_generic", context, error=str(e)))


# --- IOU Add Conversation ---
@authenticate_user
async def iou_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Starts the IOU conversation by asking for the date."""
    query = update.callback_query
    await query.answer()

    user_profile = context.user_data.get('user_profile')
    context.user_data.clear()
    context.user_data['user_profile'] = user_profile

    context.user_data['iou_type'] = 'lent' if query.data == 'iou_lent' else 'borrowed'
    await query.message.reply_text(
        t("iou.ask_date", context),
        reply_markup=keyboards.iou_date_keyboard(context)
    )
    return IOU_ASK_DATE


async def iou_received_date_choice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the date choice for an IOU."""
    query = update.callback_query
    await query.answer()
    choice = query.data

    prompt = (t("iou.ask_person_lent", context)
              if context.user_data['iou_type'] == 'lent'
              else t("iou.ask_person_borrowed", context))

    if choice == 'iou_date_today':
        await query.message.reply_text(prompt)
        return IOU_PERSON
    elif choice == 'iou_date_yesterday':
        yesterday = datetime.now(PHNOM_PENH_TZ).date() - timedelta(days=1)
        context.user_data['timestamp'] = datetime.combine(yesterday, time(12, 0), tzinfo=PHNOM_PENH_TZ).isoformat()
        await query.message.reply_text(prompt)
        return IOU_PERSON
    elif choice == 'iou_date_custom':
        await query.message.reply_text(t("iou.ask_date_custom", context))
        return IOU_CUSTOM_DATE


async def iou_received_custom_date(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the custom date input for an IOU."""
    try:
        custom_date = datetime.strptime(update.message.text, "%Y-%m-%d").date()
        context.user_data['timestamp'] = datetime.combine(custom_date, time(12, 0), tzinfo=PHNOM_PENH_TZ).isoformat()
        prompt = (t("iou.ask_person_lent", context)
                  if context.user_data['iou_type'] == 'lent'
                  else t("iou.ask_person_borrowed", context))
        await update.message.reply_text(prompt)
        return IOU_PERSON
    except ValueError:
        await update.message.reply_text(t("forgot.invalid_date", context))
        return IOU_CUSTOM_DATE


async def iou_received_person(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['iou_person'] = update.message.text.strip().title()
    await update.message.reply_text(t("iou.ask_amount", context))
    return IOU_AMOUNT


async def iou_received_amount(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Receives IOU amount, parses it, and asks for purpose or currency."""
    try:
        mode, currencies = _get_user_settings_for_iou(context)
        primary_currency = currencies[0] if mode == 'single' else 'USD'

        amount_str = update.message.text
        amount, currency, is_ambiguous = parse_amount_and_currency_for_mode(
            amount_str, mode, primary_currency
        )

        context.user_data['iou_amount'] = amount

        if mode == 'single' or not is_ambiguous:
            # Single mode OR Dual mode with explicit currency (e.g., "10khr")
            context.user_data['iou_currency'] = currency

            if currency == 'KHR':
                amount_display = f"{amount:,.0f} {currency}"
            else:
                amount_display = f"{amount:,.2f} {currency}"

            await update.message.reply_text(
                t("iou.ask_purpose", context, amount_display=amount_display),
                parse_mode='HTML'
            )
            return IOU_PURPOSE

        else:
            # Dual mode and ambiguous (e.g., "10")
            await update.message.reply_text(
                t("iou.ask_currency", context),
                reply_markup=keyboards.currency_keyboard(context)
            )
            return IOU_CURRENCY

    except ValueError:
        await update.message.reply_text(t("iou.invalid_amount", context))
        return IOU_AMOUNT


async def iou_received_currency(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    currency = query.data.split('_')[1]
    context.user_data['iou_currency'] = currency
    await query.message.reply_text(
        t("iou.ask_purpose_curr", context, currency=currency),
        parse_mode='HTML'
    )
    return IOU_PURPOSE


async def iou_received_purpose(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Receives the purpose and saves the new IOU."""
    user_id = context.user_data['user_profile']['_id']
    debt_data = {
        "type": context.user_data.get('iou_type'),
        "person": context.user_data.get('iou_person'),
        "amount": context.user_data.get('iou_amount'),
        "currency": context.user_data.get('iou_currency'),
        "purpose": update.message.text.strip(),
        "timestamp": context.user_data.get('timestamp')
    }

    response = api_client.add_debt(debt_data, user_id)
    base_text = t("iou.success", context) if response else t("iou.fail", context)

    summary_text = format_summary_message(
        api_client.get_detailed_summary(user_id), context
    )

    await update.message.reply_text(
        base_text + summary_text,
        parse_mode='HTML',
        reply_markup=keyboards.main_menu_keyboard(context)
    )
    context.user_data.clear()
    return ConversationHandler.END


# --- Lump-Sum Repayment Conversation (from button) ---
@authenticate_user
async def repay_lump_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Starts the lump-sum repayment conversation."""
    query = update.callback_query
    await query.answer()

    user_profile = context.user_data.get('user_profile')
    context.user_data.clear()
    context.user_data['user_profile'] = user_profile

    _, _, person, debt_type = query.data.split(':')
    context.user_data.update({
        'lump_repay_person': person,
        'lump_repay_debt_type': debt_type
    })

    prompt_key = "iou.repay_ask_amount_lent" if debt_type == 'lent' else "iou.repay_ask_amount_borrowed"
    prompt = t(prompt_key, context, person=person)

    await query.message.reply_text(prompt)
    return REPAY_LUMP_AMOUNT


async def received_lump_repayment_amount(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Receives and processes the lump-sum repayment amount."""
    try:
        user_id = context.user_data['user_profile']['_id']
        mode, currencies = _get_user_settings_for_iou(context)
        primary_currency = currencies[0] if mode == 'single' else 'USD'

        amount_str = update.message.text
        # Use the mode-aware parser. It will auto-select currency in single-mode.
        amount, currency, is_ambiguous = parse_amount_and_currency_for_mode(
            amount_str, mode, primary_currency
        )

        if is_ambiguous:
            # Default ambiguous repayments to USD in dual mode
            currency = 'USD'

        person = context.user_data['lump_repay_person']
        debt_type = context.user_data['lump_repay_debt_type']

        response = api_client.record_lump_sum_repayment(
            person, currency, amount, debt_type, user_id, timestamp=None
        )

        base_text = (t("iou.repay_success", context, message=response['message'])
                     if 'message' in response
                     else t("iou.repay_fail", context, error=response.get('error', 'Unknown error')))

        summary_text = format_summary_message(
            api_client.get_detailed_summary(user_id), context
        )

        await update.message.reply_text(
            base_text + summary_text,
            parse_mode='HTML',
            reply_markup=keyboards.main_menu_keyboard(context)
        )
        return ConversationHandler.END
    except (ValueError, TypeError):
        await update.message.reply_text(t("iou.repay_invalid_amount", context))
        return REPAY_LUMP_AMOUNT

# --- NEW: Debt Edit/Cancel Handlers ---

@authenticate_user
async def iou_manage_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows the edit/cancel menu for a specific debt."""
    query = update.callback_query
    await query.answer()
    _, _, _, debt_id, person, is_settled_str = query.data.split(':')
    await query.edit_message_text(
        t("iou.manage_menu_header", context, person=person),
        reply_markup=keyboards.iou_manage_keyboard(debt_id, person, is_settled_str, context)
    )


@authenticate_user
async def iou_cancel_prompt(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for confirmation before canceling a debt."""
    query = update.callback_query
    await query.answer()
    _, _, _, debt_id, person, is_settled_str = query.data.split(':')
    await query.edit_message_text(
        t("iou.cancel_prompt", context),
        parse_mode='Markdown',
        reply_markup=keyboards.iou_cancel_confirm_keyboard(debt_id, person, is_settled_str, context)
    )


@authenticate_user
async def iou_cancel_confirm(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Confirms and cancels the debt."""
    query = update.callback_query
    await query.answer(t("iou.cancel_confirm", context))

    user_id = context.user_data['user_profile']['_id']
    debt_id = query.data.split(':')[-1]
    response = api_client.cancel_debt(debt_id, user_id)

    if 'message' in response:
        base_text = t("iou.cancel_success", context, message=response['message'])
    else:
        base_text = t("iou.cancel_fail", context, error=response.get('error', 'Unknown error'))

    summary_text = format_summary_message(
        api_client.get_detailed_summary(user_id), context
    )

    await query.edit_message_text(
        base_text + summary_text,
        parse_mode='HTML',
        reply_markup=keyboards.main_menu_keyboard(context)
    )
    return ConversationHandler.END


# --- NEW: Debt Edit Conversation ---

@authenticate_user
async def iou_edit_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Starts the conversation to edit a debt's field."""
    query = update.callback_query
    await query.answer()

    user_profile = context.user_data.get('user_profile')
    context.user_data.clear()
    context.user_data['user_profile'] = user_profile

    _, _, field, debt_id = query.data.split(':')

    context.user_data['iou_edit_debt_id'] = debt_id
    context.user_data['iou_edit_field'] = field

    if field == 'person':
        await query.message.reply_text(t("iou.edit_ask_person", context))
    elif field == 'purpose':
        await query.message.reply_text(t("iou.edit_ask_purpose", context))

    return IOU_EDIT_GET_VALUE


async def iou_edit_received_value(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Receives the new value and updates the debt."""
    user_id = context.user_data['user_profile']['_id']
    debt_id = context.user_data.get('iou_edit_debt_id')
    field = context.user_data.get('iou_edit_field')
    new_value = update.message.text

    if not debt_id or not field:
        await update.message.reply_text(
            t("iou.edit_error_context", context),
            reply_markup=keyboards.main_menu_keyboard(context)
        )
        return ConversationHandler.END

    response = api_client.update_debt(debt_id, {field: new_value}, user_id)

    if 'message' in response:
        base_text = t("iou.edit_success", context, message=response['message'])
    else:
        base_text = t("iou.edit_fail", context, error=response.get('error', 'Unknown error'))

    summary_text = format_summary_message(
        api_client.get_detailed_summary(user_id), context
    )

    await update.message.reply_text(
        base_text + summary_text,
        parse_mode='HTML',
        reply_markup=keyboards.main_menu_keyboard(context)
    )
    context.user_data.clear()
    return ConversationHandler.END
# --- End of modified file ---

============================================================

==================== FILE: telegram_bot/handlers/onboarding.py ====================
# --- telegram_bot/handlers/onboarding.py (FIXED) ---

from telegram import Update
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
    CommandHandler  # <-- IMPORT THIS
)
import logging
import api_client
import keyboards  # <-- IMPORT THIS
from .helpers import format_summary_message  # <-- IMPORT THIS
from utils.i18n import t  # <-- IMPORT THIS

log = logging.getLogger(__name__)

# Conversation states
(
    ASK_LANGUAGE,
    ASK_CURRENCY_MODE,
    ASK_NAME_EN,
    ASK_NAME_KM,
    ASK_SINGLE_CURRENCY,
    ASK_USD_BALANCE,
    ASK_KHR_BALANCE,
    ASK_SINGLE_BALANCE
) = range(100, 108)


async def onboarding_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Starts the mandatory onboarding flow OR shows the main menu.
    This is the main entry point for /start.
    """
    user_id = update.effective_user.id
    log.info(f"User {user_id}: Entering onboarding_start (from /start or callback).")

    if not update.effective_user:
        log.warning("onboarding_start received update with no effective_user.")
        return ConversationHandler.END

    cached = context.user_data.get("user_profile")
    if not cached:
        log.info(f"User {user_id}: No profile in cache. Fetching from API.")
        profile = api_client.find_or_create_user(user_id)
        if not profile or profile.get("error"):
            msg = profile.get("error", "Auth failed.")
            log.error(f"User {user_id}: Auth failed or API error: {msg}")
            if update.message:
                await update.message.reply_text(f"ðŸš« {msg}")
            elif update.callback_query:
                await context.bot.answer_callback_query(update.callback_query.id, f"ðŸš« {msg}", show_alert=True)
            return ConversationHandler.END
        context.user_data["user_profile"] = profile
        log.info(f"User {user_id}: Profile fetched and cached.")
    else:
        log.info(f"User {user_id}: Profile found in cache.")

    is_complete = context.user_data["user_profile"].get("onboarding_complete")

    if is_complete:
        # --- REPLICATE common.start LOGIC ---
        # User is onboarded, just call the normal start handler logic
        log.info(f"User {user_id}: Already onboarded. Showing main menu.")
        user_profile = context.user_data['user_profile']
        user_id_obj = user_profile['_id']  # Get the object ID

        lang = user_profile.get('settings', {}).get('language', 'en')
        user_name = user_profile.get('name_en', 'User')
        if lang == 'km' and user_profile.get('name_km'):
            user_name = user_profile.get('name_km')

        text = t("common.welcome", context, name=user_name)
        keyboard = keyboards.main_menu_keyboard(context)
        chat_id = update.effective_chat.id

        summary_data = api_client.get_detailed_summary(user_id_obj)
        summary_text = format_summary_message(summary_data, context)

        if update.callback_query:
            await update.callback_query.answer()
            try:
                await update.callback_query.edit_message_text(
                    text + summary_text, parse_mode='HTML', reply_markup=keyboard
                )
            except Exception:
                pass  # Message might be identical
        else:
            await context.bot.send_message(
                chat_id=chat_id, text=text + summary_text, parse_mode='HTML', reply_markup=keyboard
            )
        return ConversationHandler.END  # End the conversation
        # --- END REPLICATE ---

    # --- START ONBOARDING FLOW ---
    log.info(f"User {user_id}: Not onboarded.\n    Starting flow.") # <-- FIX: F-string on one line
    user_profile = context.user_data.get('user_profile')
    context.user_data.clear()
    context.user_data['user_profile'] = user_profile
    context.user_data['onboarding_data'] = {}

    message_interface = update.message
    if update.callback_query:
        # If started from a callback (like 'Back to Main Menu'), edit the message
        await update.callback_query.answer()
        message_interface = update.callback_query.message
    else: # <-- FIX: Un-indented else block
        # If started from /start, just use the message
        message_interface = update.message

    # --- THIS IS THE MODIFIED WELCOME MESSAGE ---
    await message_interface.reply_text(
        "Welcome to FinanceBot! Please select your language.\n"
        "âž¡ï¸ For English, reply: en\n\n"
        "ážŸáž¼áž˜ážŸáŸ’ážœáž¶áž‚áž˜áž“áŸáž˜áž€áž€áž¶áž“áŸ‹ FinanceBot! ážŸáž¼áž˜áž‡áŸ’ážšáž¾ážŸážšáž¾ážŸáž—áž¶ážŸáž¶áŸ”\n"
        "âž¡ï¸ ážŸáž˜áŸ’ážšáž¶áž”áŸ‹áž—áž¶ážŸáž¶ážáŸ’áž˜áŸ‚ážš ážŸáž¼áž˜áž†áŸ’áž›áž¾áž™ážáž”áŸ– km"
    )
    # --- END MODIFICATION ---

    log.info(f"User {user_id}: Sent language prompt. Awaiting state ASK_LANGUAGE.")
    return ASK_LANGUAGE


async def received_language(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles language selection and asks for currency mode."""
    user_id = update.effective_user.id
    choice = update.message.text.strip().lower()
    data = context.user_data['onboarding_data']
    log.info(f"User {user_id}: In state ASK_LANGUAGE.\n    Received: '{choice}'")

    if choice not in ['en', 'km']:
        log.warning(f"User {user_id}: Invalid language choice.")
        # <-- FIX: Indented the following lines to be *inside* the if-block
        await update.message.reply_text(
            "Invalid choice. Please reply with `en` or `km`.\n\n"
            "áž€áž¶ážšáž‡áŸ’ážšáž¾ážŸážšáž¾ážŸáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ” ážŸáž¼áž˜áž†áŸ’áž›áž¾áž™ážáž”áž‡áž¶áž˜áž½áž™ `en` áž¬ `km` áŸ”",
            parse_mode='Markdown'
        )
        return ASK_LANGUAGE

    data['language'] = choice
    context.user_data['user_profile']['settings']['language'] = choice
    log.info(f"User {user_id}: Set language to '{choice}'.")

    # Now that language is set, we can use the t() function
    await update.message.reply_text(t("onboarding.ask_mode", context))
    log.info(f"User {user_id}: Sent currency mode prompt. Awaiting state ASK_CURRENCY_MODE.")
    return ASK_CURRENCY_MODE


async def received_currency_mode(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the '1' or '2' currency mode choice."""
    user_id = update.effective_user.id
    choice = update.message.text.strip()
    data = context.user_data['onboarding_data']
    lang = data['language']
    # <-- FIX: F-string on one line
    log.info(f"User {user_id}: In state ASK_CURRENCY_MODE.\n    Received: '{choice}'")

    next_state = None
    prompt = ""

    if choice == '1':
        data['mode'] = 'single'
        log.info(f"User {user_id}: Set mode to 'single'.")
        # --- MODIFIED LOGIC ---
        if lang == 'km':
            prompt = t("onboarding.ask_name_km", context)
            next_state = ASK_NAME_KM
        else:  # Default to English <-- FIX: Un-indented else
            prompt = t("onboarding.ask_name_en", context)
            next_state = ASK_NAME_EN
        # --- END MODIFICATION ---

    elif choice == '2': # <-- FIX: Un-indented elif
        data['mode'] = 'dual'
        log.info(f"User {user_id}: Set mode to 'dual'.")
        # --- MODIFIED LOGIC ---
        if lang == 'km':
            prompt = t("onboarding.ask_name_km", context)
            next_state = ASK_NAME_KM
        else:  # Default to English <-- FIX: Un-indented else
            prompt = t("onboarding.ask_name_en", context)
            next_state = ASK_NAME_EN
        # --- END MODIFICATION ---

    else: # <-- FIX: Un-indented else
        log.warning(f"User {user_id}: Invalid currency mode choice.")
        await update.message.reply_text(t("onboarding.invalid_mode", context))
        return ASK_CURRENCY_MODE

    await update.message.reply_text(prompt)
    return next_state


async def received_name_en(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles receiving the user's English name."""
    user_id = update.effective_user.id
    data = context.user_data['onboarding_data']
    data['name_en'] = update.message.text.strip()
    # <-- FIX: F-string on one line
    log.info(f"User {user_id}: Received EN name '{data['name_en']}'.\n    Mode is '{data['mode']}'.")

    # --- MODIFIED LOGIC ---
    if data['mode'] == 'single':
        await update.message.reply_text(t("onboarding.ask_primary_currency", context))
        return ASK_SINGLE_CURRENCY

    elif data['mode'] == 'dual':
        # <-- FIX: Indented the following block
        # Check if we still need the Khmer name
        if 'name_km' not in data:
            await update.message.reply_text(t("onboarding.ask_name_km", context))
            return ASK_NAME_KM
        else:
            # Both names are present, save and proceed
            return await _save_mode_and_names(update, context)
# --- END MODIFICATION ---


async def received_name_km(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles receiving the user's Khmer name."""
    user_id = update.effective_user.id
    data = context.user_data['onboarding_data']
    data['name_km'] = update.message.text.strip()
    log.info(f"User {user_id}: Received KM name '{data['name_km']}'.")

    # --- MODIFIED LOGIC ---
    if data['mode'] == 'single':
        # This is a new path: user chose 'km' and 'single'
        await update.message.reply_text(t("onboarding.ask_primary_currency", context))
        return ASK_SINGLE_CURRENCY

    elif data['mode'] == 'dual':
        # <-- FIX: Indented the following block
        # Check if we still need the English name
        if 'name_en' not in data:
            await update.message.reply_text(t("onboarding.ask_name_en", context))
            return ASK_NAME_EN
        else:
            # Both names are present, save and proceed
            return await _save_mode_and_names(update, context)
    # --- END MODIFICATION ---


async def _save_mode_and_names(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Internal helper to save mode/names (for DUAL mode) and ask for USD balance.
    This is called once both names (EN and KM) are collected.
    """
    user_id = update.effective_user.id
    data = context.user_data['onboarding_data']
    log.info(f"User {user_id}: Saving dual-mode names.")

    # Save mode, language, and names to DB
    api_client.update_user_mode(
        user_id,
        mode=data['mode'],
        language=data['language'],
        name_en=data['name_en'],
        name_km=data['name_km']
    )
    log.info(f"User {user_id}: Saved mode/names to DB.")

    # Update local cache
    context.user_data['user_profile']['name_en'] = data['name_en']
    context.user_data['user_profile']['name_km'] = data['name_km']
    context.user_data['user_profile']['settings']['currency_mode'] = data['mode']

    # --- MODIFIED LOGIC: Use the correct name for the prompt ---
    lang = data['language']
    display_name = data.get('name_km') if lang == 'km' else data.get('name_en')

    await update.message.reply_text(
        t("onboarding.ask_usd_balance", context, name=display_name)
    )
    return ASK_USD_BALANCE


async def received_single_currency(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles receiving the primary currency (single mode)."""
    user_id = update.effective_user.id
    data = context.user_data['onboarding_data']
    data['primary_currency'] = update.message.text.strip().upper()
    log.info(f"User {user_id}: Received single currency '{data['primary_currency']}'.")

    # --- MODIFIED LOGIC: Save whichever name was provided (en or km) ---
    name_en = data.get('name_en')
    name_km = data.get('name_km')

    api_client.update_user_mode(
        user_id,
        mode=data['mode'],
        language=data['language'],
        name_en=name_en,
        name_km=name_km,
        primary_currency=data['primary_currency']
    )
    log.info(f"User {user_id}: Saved mode/names/currency to DB.")

    # Update local cache
    if name_en:
        context.user_data['user_profile']['name_en'] = name_en
    if name_km:
        context.user_data['user_profile']['name_km'] = name_km
    context.user_data['user_profile']['settings']['currency_mode'] = data['mode']
    context.user_data['user_profile']['settings']['primary_currency'] = data['primary_currency']

    # Use the name that was actually provided for the prompt
    display_name = name_en or name_km

    await update.message.reply_text(
        t("onboarding.ask_single_balance", context,
          name=display_name, currency=data['primary_currency'])
    )
    # --- END MODIFICATION ---
    return ASK_SINGLE_BALANCE


async def received_usd_balance(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles receiving the initial USD balance (dual mode)."""
    user_id = update.effective_user.id
    try:
        amount = float(update.message.text)
        log.info(f"User {user_id}: Received USD balance '{amount}'.")

        api_client.update_initial_balance(user_id, 'USD', amount)
        context.user_data['user_profile']['settings']['initial_balances']['USD'] = amount

        await update.message.reply_text(
            t("onboarding.ask_khr_balance", context)
        )
        return ASK_KHR_BALANCE

    except (ValueError, TypeError):
        log.warning(f"User {user_id}: Invalid USD balance input.")
        await update.message.reply_text(
            t("onboarding.invalid_amount", context)
        )
        return ASK_USD_BALANCE
    except Exception as e:
        log.error(f"Error in received_usd_balance: {e}", exc_info=True)
        await update.message.reply_text(t("common.error_generic", context, error=e))
        return ConversationHandler.END


async def received_khr_balance(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles receiving the initial KHR balance (dual mode) and ends onboarding."""
    user_id = update.effective_user.id
    try:
        amount = float(update.message.text)
        log.info(f"User {user_id}: Received KHR balance '{amount}'.")

        api_client.update_initial_balance(user_id, 'KHR', amount)
        context.user_data['user_profile']['settings']['initial_balances']['KHR'] = amount

        # Mark onboarding as complete in the DB and local cache
        log.info(f"User {user_id}: Completing onboarding.")
        api_client.complete_onboarding(user_id)
        context.user_data['user_profile']['onboarding_complete'] = True

        await update.message.reply_text(
            t("onboarding.setup_complete", context)
        )
        # Manually call the start logic again to show the main menu
        return await onboarding_start(update, context)

    except (ValueError, TypeError):
        log.warning(f"User {user_id}: Invalid KHR balance input.")
        await update.message.reply_text(
            t("onboarding.invalid_amount", context)
        )
        return ASK_KHR_BALANCE
    except Exception as e:
        log.error(f"Error in received_khr_balance: {e}", exc_info=True)
        await update.message.reply_text(t("common.error_generic", context, error=e))
        return ConversationHandler.END


async def received_single_balance(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles receiving the initial balance (single mode) and ends onboarding."""
    user_id = update.effective_user.id
    try:
        amount = float(update.message.text)
        currency = context.user_data['onboarding_data']['primary_currency']
        log.info(f"User {user_id}: Received single balance '{amount} {currency}'.")

        api_client.update_initial_balance(user_id, currency, amount)
        context.user_data['user_profile']['settings']['initial_balances'][currency] = amount

        # Mark onboarding as complete in the DB and local cache
        log.info(f"User {user_id}: Completing onboarding.")
        api_client.complete_onboarding(user_id)
        context.user_data['user_profile']['onboarding_complete'] = True

        await update.message.reply_text(
            t("onboarding.setup_complete", context)
        )
        # Manually call the start logic again to show the main menu
        # <-- FIX: Indented this line to be *inside* the try block
        return await onboarding_start(update, context)

    except (ValueError, TypeError):
        log.warning(f"User {user_id}: Invalid single balance input.")
        await update.message.reply_text(
            t("onboarding.invalid_amount", context)
        )
        return ASK_SINGLE_BALANCE
    except Exception as e:
        log.error(f"Error in received_single_balance: {e}", exc_info=True)
        await update.message.reply_text(t("common.error_generic", context, error=e))
        return ConversationHandler.END


async def cancel_onboarding(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Cancels the onboarding process."""
    user_id = update.effective_user.id
    log.info(f"User {user_id}: Canceled onboarding.")
    await (update.message or update.callback_query.message).reply_text(
        t("common.cancel_onboarding", context)
    )
    context.user_data.clear()
    return ConversationHandler.END


onboarding_conversation_handler = ConversationHandler(
    entry_points=[
        CommandHandler('start', onboarding_start),  # <-- MODIFIED: This is now the main entry
        CallbackQueryHandler(onboarding_start, pattern='^start$')  # <-- NEW: Catches 'back' buttons
    ],
    states={
        ASK_LANGUAGE: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, received_language
        )],
        ASK_CURRENCY_MODE: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, received_currency_mode
        )],
        ASK_NAME_EN: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, received_name_en
        )],
        ASK_NAME_KM: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, received_name_km
        )],
        ASK_SINGLE_CURRENCY: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, received_single_currency
        )],
        ASK_USD_BALANCE: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, received_usd_balance
        )],
        ASK_KHR_BALANCE: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, received_khr_balance
        )],
        ASK_SINGLE_BALANCE: [MessageHandler(
            filters.TEXT & ~filters.COMMAND, received_single_balance
        )],
    },
    fallbacks=[
        # Allow /cancel during onboarding
        CommandHandler('cancel', cancel_onboarding),
        # Also catch any other command
        MessageHandler(filters.COMMAND, cancel_onboarding)
    ],
    per_message=False
)
# --- End of fixed file ---

============================================================

==================== FILE: telegram_bot/handlers/search.py ====================
# --- Start of new file: telegram_bot/handlers/search.py ---

import api_client
import keyboards
from telegram import Update
from telegram.ext import ContextTypes, ConversationHandler
from .common import cancel
from .helpers import format_summation_results
from decorators import authenticate_user # <-- MODIFICATION: Fix import
from datetime import datetime
from zoneinfo import ZoneInfo
from utils.i18n import t

# Conversation states
(
    CHOOSE_PERIOD, GET_CUSTOM_START, GET_CUSTOM_END, CHOOSE_TYPE,
    GET_CATEGORIES, GET_KEYWORDS, GET_KEYWORD_LOGIC,
    CHOOSE_ACTION
) = range(8)

PHNOM_PENH_TZ = ZoneInfo("Asia/Phnom_Penh")


@authenticate_user # <-- MODIFICATION
async def search_menu_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Displays the search sub-menu and enters the conversation."""
    query = update.callback_query
    await query.answer()

    # --- THIS IS THE FIX ---
    # Preserve the user_profile, clear everything else, then restore it.
    user_profile = context.user_data.get('user_profile')
    context.user_data.clear()
    context.user_data['user_profile'] = user_profile
    # --- END FIX ---

    await query.edit_message_text(
        text=t("search.menu_header", context),
        reply_markup=keyboards.search_menu_keyboard(context)
    )
    return CHOOSE_ACTION


@authenticate_user # <-- MODIFICATION
async def search_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the search type choice ('manage' or 'sum') and moves to period selection."""
    query = update.callback_query
    await query.answer()

    search_type = query.data.replace('start_search_', '')
    context.user_data['search_type'] = search_type
    context.user_data['search_params'] = {}

    await query.edit_message_text(
        t("search.ask_period", context),
        reply_markup=keyboards.report_period_keyboard(context, is_search=True)
    )
    return CHOOSE_PERIOD


@authenticate_user # <-- MODIFICATION
async def received_period_choice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the period choice and asks for transaction type."""
    query = update.callback_query
    await query.answer()
    period = query.data.replace('report_period_', '')

    if period == "custom":
        await query.edit_message_text(t("search.ask_start", context))
        return GET_CUSTOM_START
    elif period != "all_time":
        context.user_data['search_params']['period'] = period

    await query.edit_message_text(
        t("search.ask_type", context),
        reply_markup=keyboards.search_type_keyboard(context)
    )
    return CHOOSE_TYPE


@authenticate_user # <-- MODIFICATION
async def received_custom_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Receives and validates the custom start date."""
    try:
        start_date = datetime.strptime(update.message.text, "%Y-%m-%d").date()
        context.user_data['search_params']['start_date'] = start_date.isoformat()
        await update.message.reply_text(
            t("search.ask_end", context, date=start_date)
        )
        return GET_CUSTOM_END
    except ValueError:
        await update.message.reply_text(t("search.invalid_date", context))
        return GET_CUSTOM_START


@authenticate_user # <-- MODIFICATION
async def received_custom_end(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Receives, validates end date, and asks for transaction type."""
    try:
        end_date = datetime.strptime(update.message.text, "%Y-%m-%d").date()
        start_date_str = context.user_data['search_params'].get('start_date')
        if not start_date_str or end_date < datetime.fromisoformat(start_date_str).date():
            await update.message.reply_text(t("search.invalid_range", context))
            return GET_CUSTOM_END

        context.user_data['search_params']['end_date'] = end_date.isoformat()
        await update.message.reply_text(
            t("search.ask_type", context),
            reply_markup=keyboards.search_type_keyboard(context)
        )
        return CHOOSE_TYPE
    except ValueError:
        await update.message.reply_text(t("search.invalid_date", context))
        return GET_CUSTOM_END


@authenticate_user # <-- MODIFICATION
async def received_type_choice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the transaction type choice and asks for categories."""
    query = update.callback_query
    await query.answer()
    tx_type = query.data.replace('search_type_', '')
    if tx_type != 'all':
        context.user_data['search_params']['transaction_type'] = tx_type

    await query.edit_message_text(
        t("search.ask_categories", context),
        reply_markup=keyboards.skip_keyboard(context, 'search_skip_categories')
    )
    return GET_CATEGORIES


@authenticate_user # <-- MODIFICATION
async def received_categories(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Receives categories and asks for keywords."""
    message_text = t("search.ask_keywords", context)
    if update.callback_query:
        await update.callback_query.answer()
        await update.callback_query.edit_message_text(
            message_text,
            reply_markup=keyboards.skip_keyboard(context, 'search_skip_keywords')
        )
    else:
        categories = [c.strip() for c in update.message.text.split(',')]
        context.user_data['search_params']['categories'] = categories
        await update.message.reply_text(
            message_text,
            reply_markup=keyboards.skip_keyboard(context, 'search_skip_keywords')
        )

    return GET_KEYWORDS


@authenticate_user # <-- MODIFICATION
async def received_keywords(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Receives keywords and either asks for logic or executes the search."""
    if update.callback_query:
        await update.callback_query.answer()
        return await execute_search(update, context)

    keywords = [k.strip() for k in update.message.text.split(',')]
    context.user_data['search_params']['keywords'] = keywords

    if len(keywords) > 1:
        await update.message.reply_text(
            t("search.ask_logic", context),
            reply_markup=keyboards.search_keyword_logic_keyboard(context)
        )
        return GET_KEYWORD_LOGIC

    context.user_data['search_params']['keyword_logic'] = 'OR'
    return await execute_search(update, context)


@authenticate_user # <-- MODIFICATION
async def received_keyword_logic(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Receives the keyword logic and executes the search."""
    query = update.callback_query
    await query.answer()
    logic = query.data.replace('search_logic_', '')
    context.user_data['search_params']['keyword_logic'] = logic.upper()
    return await execute_search(update, context)


async def execute_search(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Executes the correct search type and displays results by editing the message."""

    user_id = context.user_data['user_profile']['_id']
    params = context.user_data.get('search_params', {})
    search_type = context.user_data.get('search_type')

    message_to_edit = None
    if update.callback_query:
        await update.callback_query.edit_message_text(t("search.searching", context))
        message_to_edit = update.callback_query.message
    else:
        message_to_edit = await update.message.reply_text(t("search.searching", context))

    if search_type == 'manage':
        results = api_client.search_transactions_for_management(params, user_id)
        if not results:
            await message_to_edit.edit_text(
                t("search.no_results", context),
                reply_markup=keyboards.main_menu_keyboard(context)
            )
        elif len(results) == 1:
            tx = results[0]
            emoji = "â¬‡ï¸ Expense" if tx['type'] == 'expense' else "â¬†ï¸ Income"
            date_str = datetime.fromisoformat(
                tx['timestamp']
            ).astimezone(PHNOM_PENH_TZ).strftime('%d %b %Y, %I:%M %p')
            amount_format = ",.0f" if tx['currency'] == 'KHR' else ",.2f"
            amount = tx['amount']
            description = tx.get('description') or 'N/A'

            text = (
                f"{t('search.one_result', context)}\n\n"
                f"{t('history.tx_details_no_prompt', context, emoji=emoji, amount=f'{amount:{amount_format}}', currency=tx['currency'], category=tx['categoryId'], description=description, date=date_str)}"
            )
            await message_to_edit.edit_text(
                text=text,
                parse_mode='HTML',
                reply_markup=keyboards.manage_tx_keyboard(tx['_id'], context)
            )
        else:
            text = t("search.many_results", context, count=len(results))
            await message_to_edit.edit_text(
                text=text,
                reply_markup=keyboards.history_keyboard(
                    results, context, is_search_result=True
                )
            )

    elif search_type == 'sum':
        results = api_client.sum_transactions_for_analytics(params, user_id)
        response_text = format_summation_results(params, results, context)
        await message_to_edit.edit_text(
            response_text,
            parse_mode='HTML',
            reply_markup=keyboards.main_menu_keyboard(context)
        )

    context.user_data.clear()
    return ConversationHandler.END
# --- End of new file ---

============================================================

==================== FILE: telegram_bot/handlers/settings.py ====================
# --- Start of modified file: telegram_bot/handlers/settings.py ---

from telegram import Update
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
    CallbackQueryHandler,
    MessageHandler,
    filters,
    CommandHandler
)
import logging  # Import logging
import api_client
import keyboards
from .common import start, cancel  # <-- THIS IS THE FIX
from decorators import authenticate_user
from utils.i18n import t

log = logging.getLogger(__name__) # Add logger

# Conversation states
(
    SETTINGS_MENU,
    SETBALANCE_ACCOUNT,
    SETBALANCE_AMOUNT,
    NEW_RATE,
    CATEGORIES_MENU,
    CATEGORY_ADD_START,
    CATEGORY_ADD_GET_NAME,
    CATEGORY_REMOVE_START,
    CATEGORY_REMOVE_GET_NAME,
    SWITCH_TO_DUAL_CONFIRM,
    SWITCH_TO_DUAL_GET_KM_NAME,
    # --- NEW STATES ---
    ASK_NEW_LANGUAGE,
    GET_MISSING_NAME
    # --- END NEW STATES ---
) = range(13) # <-- MODIFIED COUNT


def _get_user_settings_for_settings(context: ContextTypes.DEFAULT_TYPE):
    """Helper to safely get user settings and currency mode."""
    profile = context.user_data.get('user_profile', {})
    settings = profile.get('settings', {})
    mode = settings.get('currency_mode', 'dual')

    if mode == 'single':
        primary_currency = settings.get('primary_currency', 'USD')
        return mode, (primary_currency,)

    return 'dual', ('USD', 'KHR')


@authenticate_user
async def settings_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Displays the main settings menu."""
    query = update.callback_query
    if query:
        await query.answer()

    # --- MODIFICATION: Use message if no query (e.g., returning from a sub-flow) ---
    message_interface = update.message
    if query:
        message_interface = query.message
    # ---

    user_id = context.user_data['user_profile']['_id']
    log.info(f"User {user_id} entering settings menu.")

    # Use the /settings/ endpoint which returns settings + names
    user_data = api_client.get_user_settings(user_id)
    rate_data = api_client.get_exchange_rate(user_id)

    if not user_data or not rate_data:
        err_msg = t("common.error_generic", context)
        if query:
            await query.edit_message_text(
                err_msg,
                reply_markup=keyboards.main_menu_keyboard(context)
            )
        else:
            await update.message.reply_text(
                err_msg,
                reply_markup=keyboards.main_menu_keyboard(context)
            )
        return ConversationHandler.END

    # Update local cache with fresh data
    context.user_data['user_profile']['settings'] = user_data.get('settings', {})
    context.user_data['user_profile']['name_en'] = user_data.get('name_en')
    context.user_data['user_profile']['name_km'] = user_data.get('name_km')

    settings = user_data.get('settings', {})
    balances = settings.get('initial_balances', {})
    rate_pref = settings.get('rate_preference', 'live')
    fixed_rate = settings.get('fixed_rate', 4100)
    current_rate = rate_data.get('rate', 4100)

    mode, currencies = _get_user_settings_for_settings(context)

    balance_lines = []
    if mode == 'dual':
        usd_bal = balances.get('USD', 0)
        khr_bal = balances.get('KHR', 0)
        balance_lines.append(f"  ðŸ’µ ${usd_bal:,.2f} USD")
        balance_lines.append(f"  áŸ› {khr_bal:,.0f} KHR")
    else:
        curr = currencies[0]
        bal = balances.get(curr, 0)
        fmt = ",.0f" if curr == 'KHR' else ",.2f"
        balance_lines.append(f"  <b>{bal:{fmt}} {curr}</b>")

    balance_text = "\n".join(balance_lines)

    rate_text = (
        f"Fixed ({fixed_rate:,.0f})"
        if rate_pref == 'fixed'
        else f"Live ({current_rate:,.0f})"
    )

    text = t("settings.menu_header", context,
             balance_text=balance_text,
             rate_text=rate_text,
             mode=mode.title()
             )

    keyboard = keyboards.settings_menu_keyboard(context)

    # --- MODIFICATION: Use message_interface ---
    if query:
        await message_interface.edit_text(
            text=text,
            parse_mode='HTML',
            reply_markup=keyboard
        )
    else:
        await message_interface.reply_text(
            text=text,
            parse_mode='HTML',
            reply_markup=keyboard
        )
    # ---

    return SETTINGS_MENU


# --- Set Balance Flow ---

async def set_balance_start(update: Update,
                            context: ContextTypes.DEFAULT_TYPE):
    """Asks which account balance to set."""
    query = update.callback_query
    await query.answer()
    log.info(f"User {context.user_data['user_profile']['_id']} starting set_balance flow.")

    mode, currencies = _get_user_settings_for_settings(context)

    await query.edit_message_text(
        t("settings.ask_balance_account", context),
        reply_markup=keyboards.set_balance_account_keyboard(context, mode, currencies)
    )
    return SETBALANCE_ACCOUNT


async def received_balance_account(update: Update,
                                   context: ContextTypes.DEFAULT_TYPE):
    """Asks for the new amount for the selected account."""
    query = update.callback_query
    await query.answer()
    currency = query.data.split('_')[-1]
    context.user_data['settings_currency'] = currency
    await query.edit_message_text(
        t("settings.ask_balance_amount", context, currency=currency),
        parse_mode='HTML'
    )
    return SETBALANCE_AMOUNT


async def received_balance_amount(update: Update,
                                  context: ContextTypes.DEFAULT_TYPE):
    """Saves the new initial balance to the API."""
    try:
        user_id = context.user_data['user_profile']['_id']
        amount = float(update.message.text)
        currency = context.user_data.get('settings_currency')
        log.info(f"User {user_id} setting balance for {currency} to {amount}.")

        if not currency:
            log.warning(f"User {user_id} lost context in received_balance_amount.")
            raise ValueError("Context lost")

        api_client.update_initial_balance(user_id, currency, amount)

        await update.message.reply_text(
            t("settings.balance_set_success", context,
              currency=currency, amount=amount)
        )

        # Go back to settings menu
        return await settings_menu(update, context)

    except (ValueError, TypeError):
        await update.message.reply_text(
            t("tx.invalid_amount", context)
        )
        return SETBALANCE_AMOUNT
    except Exception as e:
        log.error(f"Error in received_balance_amount: {e}", exc_info=True)
        await update.message.reply_text(t("common.error_generic", context))
        return await start(update, context)


# --- Set Rate Flow ---

async def update_rate_start(update: Update,
                            context: ContextTypes.DEFAULT_TYPE):
    """Asks for a new fixed exchange rate."""
    query = update.callback_query
    await query.answer()
    log.info(f"User {context.user_data['user_profile']['_id']} starting update_rate flow.")
    await query.edit_message_text(t("settings.ask_rate", context))
    return NEW_RATE


async def received_new_rate(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Saves the new fixed rate via the API."""
    try:
        user_id = context.user_data['user_profile']['_id']
        new_rate = float(update.message.text)
        log.info(f"User {user_id} setting new fixed rate to {new_rate}.")

        api_client.update_exchange_rate(new_rate, user_id)

        await update.message.reply_text(
            t("settings.rate_set_success", context, rate=new_rate)
        )
        return await settings_menu(update, context)

    except (ValueError, TypeError):
        await update.message.reply_text(t("settings.invalid_rate", context))
        return NEW_RATE
    except Exception as e:
        log.error(f"Error in received_new_rate: {e}", exc_info=True)
        await update.message.reply_text(t("common.error_generic", context))
        return await start(update, context)


# --- Manage Categories Flow ---

async def categories_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Displays the category management menu."""
    query = update.callback_query
    await query.answer()
    user_id = context.user_data['user_profile']['_id']
    log.info(f"User {user_id} entering categories menu.")

    user_data = api_client.get_user_settings(user_id)
    if not user_data:
        await query.edit_message_text(
            t("common.error_generic", context),
            reply_markup=keyboards.settings_menu_keyboard(context)
        )
        return SETTINGS_MENU

    categories = user_data.get('settings', {}).get('categories', {})
    expense_cats = categories.get('expense', [])
    income_cats = categories.get('income', [])

    text = t("settings.categories_header", context,
             expense_cats=', '.join(expense_cats) or 'None',
             income_cats=', '.join(income_cats) or 'None')

    await query.edit_message_text(
        text=text,
        parse_mode='HTML',
        reply_markup=keyboards.manage_categories_keyboard(context)
    )
    return CATEGORIES_MENU


async def category_add_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for the type of category to add."""
    query = update.callback_query
    await query.answer()
    context.user_data['category_action'] = 'add'
    await query.edit_message_text(
        t("settings.category_ask_add", context),
        reply_markup=keyboards.category_type_keyboard(context, 'add')
    )
    return CATEGORY_ADD_START


async def category_remove_start(update: Update,
                                context: ContextTypes.DEFAULT_TYPE):
    """Asks for the type of category to remove."""
    query = update.callback_query
    await query.answer()
    context.user_data['category_action'] = 'remove'
    await query.edit_message_text(
        t("settings.category_ask_remove", context),
        reply_markup=keyboards.category_type_keyboard(context, 'remove')
    )
    return CATEGORY_REMOVE_START


async def received_category_type(update: Update,
                                 context: ContextTypes.DEFAULT_TYPE):
    """Receives category type and asks for the name."""
    query = update.callback_query
    await query.answer()

    action = context.user_data['category_action']
    cat_type = query.data.split(':')[-1]
    context.user_data['category_type'] = cat_type

    await query.edit_message_text(
        t("settings.category_ask_name", context,
          cat_type=cat_type, action=action)
    )
    if action == 'add':
        return CATEGORY_ADD_GET_NAME
    if action == 'remove':
        return CATEGORY_REMOVE_GET_NAME
    return SETTINGS_MENU


async def received_category_add_name(update: Update,
                                     context: ContextTypes.DEFAULT_TYPE):
    """Receives and saves the new category name."""
    try:
        user_id = context.user_data['user_profile']['_id']
        cat_type = context.user_data['category_type']
        cat_name = update.message.text.strip().title()
        log.info(f"User {user_id} adding category '{cat_name}' to {cat_type}.")

        api_client.add_category(user_id, cat_type, cat_name)
        await update.message.reply_text(
            t("settings.category_add_success", context,
              name=cat_name, type=cat_type)
        )
        return await settings_menu(update, context)

    except Exception as e:
        log.error(f"Error in received_category_add_name: {e}", exc_info=True)
        await update.message.reply_text(t("common.error_generic", context))
        return await start(update, context)


async def received_category_remove_name(update: Update,
                                        context: ContextTypes.DEFAULT_TYPE):
    """Receives and removes the category name."""
    try:
        user_id = context.user_data['user_profile']['_id']
        cat_type = context.user_data['category_type']
        cat_name = update.message.text.strip().title()
        log.info(f"User {user_id} removing category '{cat_name}' from {cat_type}.")

        api_client.remove_category(user_id, cat_type, cat_name)
        await update.message.reply_text(
            t("settings.category_remove_success", context,
              name=cat_name, type=cat_type)
        )
        return await settings_menu(update, context)

    except Exception as e:
        log.error(f"Error in received_category_remove_name: {e}", exc_info=True)
        await update.message.reply_text(t("common.error_generic", context))
        return await start(update, context)


# --- Switch Mode Flow ---

async def switch_to_dual_confirm(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks the user to confirm switching to dual-currency mode."""
    query = update.callback_query
    await query.answer()
    log.info(f"User {context.user_data['user_profile']['_id']} starting switch_to_dual flow.")

    await query.edit_message_text(
        t("settings.switch_to_dual_confirm", context),
        reply_markup=keyboards.switch_to_dual_confirm_keyboard(context)
    )
    return SWITCH_TO_DUAL_CONFIRM


async def switch_to_dual_get_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for the user's Khmer name."""
    query = update.callback_query
    await query.answer()

    # Set language to Khmer by default for this prompt
    context.user_data['user_profile']['settings']['language'] = 'km'

    await query.edit_message_text(
        t("settings.ask_name_km_switch", context)
    )
    return SWITCH_TO_DUAL_GET_KM_NAME


async def received_km_name_for_switch(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Receives the Khmer name and finalizes the mode switch."""
    try:
        km_name = update.message.text.strip()
        user_id = context.user_data['user_profile']['_id']
        log.info(f"User {user_id} completing switch_to_dual with KM name.")

        # Get existing English name
        name_en = context.user_data['user_profile'].get('name_en', 'User')

        # Use the /settings/mode endpoint to update
        api_client.update_user_mode(
            user_id,
            mode='dual',
            language='km', # Default to Khmer upon switch
            name_en=name_en,
            name_km=km_name
        )

        # Update local cache
        context.user_data['user_profile']['settings']['currency_mode'] = 'dual'
        context.user_data['user_profile']['settings']['language'] = 'km'
        context.user_data['user_profile']['name_km'] = km_name

        await update.message.reply_text(
            t("settings.switch_to_dual_success", context)
        )
        return await settings_menu(update, context)

    except Exception as e:
        log.error(f"Error in received_km_name_for_switch: {e}", exc_info=True)
        await update.message.reply_text(t("common.error_generic", context))
        return await start(update, context)


# --- NEW: Change Language Flow ---

async def change_language_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks the user which language they want to switch to."""
    query = update.callback_query
    await query.answer()
    log.info(f"User {context.user_data['user_profile']['_id']} starting change_language flow.")

    await query.edit_message_text(
        t("settings.ask_new_language", context),
        reply_markup=keyboards.change_language_keyboard(context)
    )
    return ASK_NEW_LANGUAGE


async def received_new_language(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Receives the new language choice.
    If in dual-mode and the corresponding name is missing, asks for it.
    Otherwise, just updates the language setting.
    """
    query = update.callback_query
    await query.answer()

    new_lang = query.data.split(':')[-1]
    user_id = context.user_data['user_profile']['_id']
    profile = context.user_data['user_profile']
    mode = profile.get('settings', {}).get('currency_mode', 'dual')

    context.user_data['new_lang'] = new_lang # Store for next step if needed

    # Check if we need to ask for a missing name
    if mode == 'dual':
        if new_lang == 'km' and not profile.get('name_km'):
            log.info(f"User {user_id} switching to KM, but name_km is missing. Asking.")
            # Set lang in context so the prompt is in Khmer
            context.user_data['user_profile']['settings']['language'] = 'km'
            await query.edit_message_text(t("settings.ask_missing_name_km", context))
            return GET_MISSING_NAME

        if new_lang == 'en' and not profile.get('name_en'):
            log.info(f"User {user_id} switching to EN, but name_en is missing. Asking.")
            # Set lang in context so the prompt is in English
            context.user_data['user_profile']['settings']['language'] = 'en'
            await query.edit_message_text(t("settings.ask_missing_name_en", context))
            return GET_MISSING_NAME

    # If in single-mode OR in dual-mode with both names present, just switch
    log.info(f"User {user_id} switching language to {new_lang}. No name needed.")
    api_client.update_user_mode(
        user_id,
        mode=mode, # Keep existing mode
        language=new_lang,
        name_en=profile.get('name_en'), # Pass existing names
        name_km=profile.get('name_km'),
        primary_currency=profile.get('settings', {}).get('primary_currency') # Pass existing currency
    )

    # Update local cache
    context.user_data['user_profile']['settings']['language'] = new_lang

    await query.edit_message_text(
        t("settings.language_switch_success", context),
        reply_markup=keyboards.main_menu_keyboard(context) # Go to main menu
    )
    return ConversationHandler.END


async def received_missing_name_for_switch(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Receives the missing name (EN or KM) and finalizes the language switch.
    """
    try:
        new_name = update.message.text.strip()
        user_id = context.user_data['user_profile']['_id']
        new_lang = context.user_data['new_lang']
        profile = context.user_data['user_profile']
        mode = profile.get('settings', {}).get('currency_mode', 'dual')

        name_en = profile.get('name_en')
        name_km = profile.get('name_km')

        if new_lang == 'km':
            name_km = new_name
            log.info(f"User {user_id} provided missing KM name. Saving.")
        else:
            name_en = new_name
            log.info(f"User {user_id} provided missing EN name. Saving.")

        # Save the full profile update
        api_client.update_user_mode(
            user_id,
            mode=mode,
            language=new_lang,
            name_en=name_en,
            name_km=name_km,
            primary_currency=profile.get('settings', {}).get('primary_currency')
        )

        # Update local cache
        context.user_data['user_profile']['settings']['language'] = new_lang
        context.user_data['user_profile']['name_en'] = name_en
        context.user_data['user_profile']['name_km'] = name_km

        await update.message.reply_text(
            t("settings.language_switch_success", context),
            reply_markup=keyboards.main_menu_keyboard(context) # Go to main menu
        )
        return ConversationHandler.END

    except Exception as e:
        log.error(f"Error in received_missing_name_for_switch: {e}", exc_info=True)
        await update.message.reply_text(t("common.error_generic", context))
        return await start(update, context)

# --- END NEW FLOW ---


settings_conversation_handler = ConversationHandler(
    entry_points=[
        CallbackQueryHandler(settings_menu, pattern='^settings_menu$')
    ],
    states={
        SETTINGS_MENU: [
            CallbackQueryHandler(
                set_balance_start, pattern='^settings_set_balance$'
            ),
            CallbackQueryHandler(
                update_rate_start, pattern='^settings_set_rate$'
            ),
            CallbackQueryHandler(
                categories_menu, pattern='^settings_manage_categories$'
            ),
            CallbackQueryHandler(
                switch_to_dual_confirm, pattern='^settings_switch_to_dual$'
            ),
            # --- NEW HANDLER ---
            CallbackQueryHandler(
                change_language_start, pattern='^settings_change_language$'
            ),
            # ---
            CallbackQueryHandler(start, pattern='^start$'),
        ],
        SETBALANCE_ACCOUNT: [
            CallbackQueryHandler(
                received_balance_account, pattern='^set_balance_'
            )
        ],
        SETBALANCE_AMOUNT: [
            MessageHandler(filters.TEXT & ~filters.COMMAND,
                           received_balance_amount)
        ],
        NEW_RATE: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, received_new_rate)
        ],
        CATEGORIES_MENU: [
            CallbackQueryHandler(
                category_add_start, pattern='^category_add$'
            ),
            CallbackQueryHandler(
                category_remove_start, pattern='^category_remove$'
            ),
            CallbackQueryHandler(settings_menu, pattern='^settings_menu$'),
        ],
        CATEGORY_ADD_START: [
            CallbackQueryHandler(
                received_category_type, pattern='^cat_type:add:'
            )
        ],
        CATEGORY_REMOVE_START: [
            CallbackQueryHandler(
                received_category_type, pattern='^cat_type:remove:'
            )
        ],
        CATEGORY_ADD_GET_NAME: [
            MessageHandler(filters.TEXT & ~filters.COMMAND,
                           received_category_add_name)
        ],
        CATEGORY_REMOVE_GET_NAME: [
            MessageHandler(filters.TEXT & ~filters.COMMAND,
                           received_category_remove_name)
        ],
        SWITCH_TO_DUAL_CONFIRM: [
            CallbackQueryHandler(
                switch_to_dual_get_name, pattern='^confirm_switch_dual$'
            ),
            CallbackQueryHandler(settings_menu, pattern='^settings_menu$'),
        ],
        SWITCH_TO_DUAL_GET_KM_NAME: [
            MessageHandler(filters.TEXT & ~filters.COMMAND,
                           received_km_name_for_switch)
        ],
        # --- NEW STATES ---
        ASK_NEW_LANGUAGE: [
            CallbackQueryHandler(
                received_new_language, pattern='^change_lang:'
            )
        ],
        GET_MISSING_NAME: [
            MessageHandler(filters.TEXT & ~filters.COMMAND,
                           received_missing_name_for_switch)
        ],
        # --- END NEW STATES ---
    },
    fallbacks=[
        CommandHandler('start', start),
        CommandHandler('cancel', cancel),
        CallbackQueryHandler(start, pattern='^start$'),
        CallbackQueryHandler(cancel, pattern='^cancel_conversation$')
    ],
    per_message=False
)

# --- End of modified file ---

============================================================

==================== FILE: telegram_bot/handlers/transaction.py ====================
# --- Start of file: telegram_bot/handlers/transaction.py ---

from telegram import Update
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
    CallbackQueryHandler,
    MessageHandler,
    filters
)
from datetime import datetime, timedelta, time
from zoneinfo import ZoneInfo
import re
import api_client
import keyboards
from .common import start, cancel
from decorators import authenticate_user
from utils.i18n import t

# Conversation states
(
    AMOUNT, CURRENCY, CATEGORY, CUSTOM_CATEGORY, ASK_REMARK, REMARK,
    FORGOT_DATE, FORGOT_CUSTOM_DATE, FORGOT_TYPE,
    EDIT_CHOOSE_FIELD, EDIT_GET_NEW_VALUE, EDIT_GET_NEW_CATEGORY,
    EDIT_GET_CUSTOM_CATEGORY, EDIT_GET_NEW_DATE, EDIT_GET_NEW_CURRENCY
) = range(15)

PHNOM_PENH_TZ = ZoneInfo("Asia/Phnom_Penh")


def _get_user_settings_for_tx(context: ContextTypes.DEFAULT_TYPE):
    """Helper to get currency mode and primary currency."""
    profile = context.user_data.get('user_profile', {})
    settings = profile.get('settings', {})
    mode = settings.get('currency_mode', 'dual')

    if mode == 'single':
        primary_currency = settings.get('primary_currency', 'USD')
        return mode, (primary_currency,)

    return 'dual', ('USD', 'KHR')


def parse_amount_and_currency_for_mode(amount_str: str, mode: str, primary_currency: str):
    """
    Parses an amount string based on the user's currency mode.
    Returns (amount, currency, is_ambiguous)
    """
    amount_str = amount_str.lower().strip()

    if mode == 'single':
        try:
            # In single mode, just strip all non-numeric characters
            amount_val = float(re.sub(r"[^0-9.]", "", amount_str))
            return amount_val, primary_currency, False
        except ValueError:
            raise ValueError("Invalid amount for single currency mode")

    # Dual-currency mode logic
    try:
        if 'khr' in amount_str:
            amount_val = float(amount_str.replace('khr', '').strip())
            return amount_val, 'KHR', False

        # Check if it's just a number (ambiguous)
        amount_val = float(amount_str)
        return amount_val, None, True # Ambiguous, default to USD but ask

    except ValueError:
        # Check if it has 'usd' or '$'
        amount_val_str = re.sub(r"[^0-9.]", "", amount_str)
        if amount_val_str:
            amount_val = float(amount_val_str)
            return amount_val, 'USD', False

        raise ValueError("Invalid amount for dual currency mode")


# --- Add Transaction Flow ---

@authenticate_user
async def add_transaction_start(update: Update,
                                context: ContextTypes.DEFAULT_TYPE):
    """Starts the add transaction flow by asking for the amount."""
    query = update.callback_query
    await query.answer()

    user_profile = context.user_data.get('user_profile')
    context.user_data.clear()
    context.user_data['user_profile'] = user_profile

    tx_type = 'expense' if query.data == 'add_expense' else 'income'
    context.user_data['tx_type'] = tx_type
    emoji = "ðŸ’¸" if tx_type == 'expense' else "ðŸ’°"

    await query.message.reply_text(t("tx.ask_amount", context, emoji=emoji))
    return AMOUNT


@authenticate_user
async def received_amount(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Receives amount, parses it, and asks for category or currency."""
    try:
        mode, currencies = _get_user_settings_for_tx(context)
        primary_currency = currencies[0] if mode == 'single' else 'USD'

        amount_str = update.message.text
        amount, currency, is_ambiguous = parse_amount_and_currency_for_mode(
            amount_str, mode, primary_currency
        )

        context.user_data['tx_amount'] = amount

        # --- MODE-BASED LOGIC ---
        if mode == 'single' or not is_ambiguous:
            # Single mode OR Dual mode with explicit currency (e.g., "10khr")
            context.user_data['tx_currency'] = currency

            if currency == 'KHR':
                amount_display = f"{amount:,.0f} {currency}"
            else:
                amount_display = f"{amount:,.2f} {currency}"

            # Get user's dynamic categories
            profile = context.user_data['user_profile']
            tx_type = context.user_data['tx_type']
            all_categories = profile.get('settings', {}).get('categories', {})
            user_categories = all_categories.get(tx_type, [])

            if tx_type == 'expense':
                keyboard = keyboards.expense_categories_keyboard(user_categories,
                                                                 context)
            else:
                keyboard = keyboards.income_categories_keyboard(user_categories,
                                                                context)

            await update.message.reply_text(
                t("tx.ask_category", context, amount_display=amount_display),
                parse_mode='HTML',
                reply_markup=keyboard
            )
            return CATEGORY

        else:
            # Dual mode and ambiguous (e.g., "10")
            # Ask for currency
            await update.message.reply_text(
                t("tx.ask_currency", context),
                reply_markup=keyboards.currency_keyboard(context)
            )
            return CURRENCY

    except ValueError:
        await update.message.reply_text(t("tx.invalid_amount", context))
        return AMOUNT


@authenticate_user
async def received_currency(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Receives currency (if amount was ambiguous) and asks for category."""
    query = update.callback_query
    await query.answer()
    currency = query.data.split('_')[1]
    context.user_data['tx_currency'] = currency

    # Get user's dynamic categories
    profile = context.user_data['user_profile']
    tx_type = context.user_data['tx_type']
    all_categories = profile.get('settings', {}).get('categories', {})
    user_categories = all_categories.get(tx_type, [])

    if tx_type == 'expense':
        keyboard = keyboards.expense_categories_keyboard(user_categories,
                                                         context)
    else:
        keyboard = keyboards.income_categories_keyboard(user_categories,
                                                        context)

    await query.edit_message_text(
        t("tx.ask_category_curr", context, currency=currency),
        parse_mode='HTML',
        reply_markup=keyboard
    )
    return CATEGORY


@authenticate_user
async def received_category(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Receives category and asks for a remark."""
    query = update.callback_query
    await query.answer()
    category = query.data.split('_')[1]

    if category == 'other':
        await query.edit_message_text(
            t("tx.ask_custom_category", context)
        )
        return CUSTOM_CATEGORY

    context.user_data['tx_category'] = category
    await query.edit_message_text(
        t("tx.ask_remark", context, category=category),
        parse_mode='HTML',
        reply_markup=keyboards.ask_remark_keyboard(context)
    )
    return ASK_REMARK


@authenticate_user
async def received_custom_category(update: Update,
                                   context: ContextTypes.DEFAULT_TYPE):
    """Receives custom category name and asks for a remark."""
    category = update.message.text.strip().title()
    context.user_data['tx_category'] = category
    await update.message.reply_text(
        t("tx.ask_remark", context, category=category),
        parse_mode='HTML',
        reply_markup=keyboards.ask_remark_keyboard(context)
    )
    return ASK_REMARK


@authenticate_user
async def ask_remark(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles 'Add Remark' or 'Skip' button press."""
    query = update.callback_query
    await query.answer()
    choice = query.data.split('_')[1]

    if choice == 'yes':
        await query.edit_message_text(t("tx.ask_remark_prompt", context))
        return REMARK
    if choice == 'no':
        context.user_data['tx_remark'] = ""
        return await save_transaction_and_end(update, context)
    return ConversationHandler.END


@authenticate_user
async def received_remark(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Receives the remark text and saves the transaction."""
    context.user_data['tx_remark'] = update.message.text
    return await save_transaction_and_end(update, context)


async def save_transaction_and_end(update: Update,
                                   context: ContextTypes.DEFAULT_TYPE):
    """Final step: construct and save the transaction to the API."""
    try:
        user_id = context.user_data['user_profile']['_id']
        data = context.user_data
        tx_data = {
            "type": data['tx_type'],
            "amount": data['tx_amount'],
            "currency": data['tx_currency'],
            "categoryId": data['tx_category'],
            "accountName": f"{data['tx_currency']} Account",
            "description": data.get('tx_remark', ''),
            "timestamp": data.get('timestamp')  # None if not set
        }

        response = api_client.add_transaction(tx_data, user_id)
        message = t("tx.success", context) if response else t("tx.fail", context)

        if update.callback_query:
            await update.callback_query.message.reply_text(
                message, reply_markup=keyboards.main_menu_keyboard(context)
            )
        else:
            await update.message.reply_text(
                message, reply_markup=keyboards.main_menu_keyboard(context)
            )

        context.user_data.clear()
        return ConversationHandler.END
    except Exception as e:
        await (update.message or update.callback_query.message).reply_text(
            t("common.error_generic", context, error=e)
        )
        return await start(update, context)


# --- Forgot to Log Flow ---

@authenticate_user
async def forgot_log_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Starts the 'forgot to log' flow by asking for the day."""
    query = update.callback_query
    await query.answer()

    user_profile = context.user_data.get('user_profile')
    context.user_data.clear()
    context.user_data['user_profile'] = user_profile

    await query.message.reply_text(
        t("forgot.ask_day", context),
        reply_markup=keyboards.forgot_day_keyboard(context)
    )
    return FORGOT_DATE


@authenticate_user
async def received_forgot_day(update: Update,
                              context: ContextTypes.DEFAULT_TYPE):
    """Handles the day choice (Yesterday, Custom) for the forgot flow."""
    query = update.callback_query
    await query.answer()
    choice = query.data.split('_')[-1]

    if choice == 'custom':
        await query.message.reply_text(t("forgot.ask_date", context))
        return FORGOT_CUSTOM_DATE

    days_ago = int(choice)
    tx_date = datetime.now(PHNOM_PENH_TZ).date() - timedelta(days=days_ago)
    tx_datetime = datetime.combine(tx_date, time(12, 0), tzinfo=PHNOM_PENH_TZ)
    context.user_data['timestamp'] = tx_datetime.isoformat()

    await query.message.reply_text(
        t("forgot.ask_type", context),
        reply_markup=keyboards.forgot_type_keyboard(context)
    )
    return FORGOT_TYPE


@authenticate_user
async def received_forgot_custom_date(update: Update,
                                      context: ContextTypes.DEFAULT_TYPE):
    """Receives and validates the custom date for the forgot flow."""
    try:
        custom_date = datetime.strptime(update.message.text, "%Y-%m-%d").date()
        tx_datetime = datetime.combine(
            custom_date, time(12, 0), tzinfo=PHNOM_PENH_TZ
        )
        context.user_data['timestamp'] = tx_datetime.isoformat()
        await update.message.reply_text(
            t("forgot.ask_type", context),
            reply_markup=keyboards.forgot_type_keyboard(context)
        )
        return FORGOT_TYPE
    except ValueError:
        await update.message.reply_text(t("forgot.invalid_date", context))
        return FORGOT_CUSTOM_DATE


@authenticate_user
async def received_forgot_type(update: Update,
                               context: ContextTypes.DEFAULT_TYPE):
    """Receives the transaction type and asks for the amount."""
    query = update.callback_query
    await query.answer()
    tx_type = query.data.split('_')[-1]
    context.user_data['tx_type'] = tx_type
    await query.message.reply_text(
        t("forgot.ask_amount", context, type=tx_type.title()),
        parse_mode='HTML'
    )
    return AMOUNT  # Re-use the existing AMOUNT state


# --- History, Manage, Edit, Delete Flow ---

@authenticate_user
async def history_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Displays the last 20 transactions for the user."""
    query = update.callback_query
    await query.answer()

    user_id = context.user_data['user_profile']['_id']
    transactions = api_client.get_recent_transactions(user_id)

    if not transactions:
        await query.edit_message_text(
            t("history.no_tx", context),
            reply_markup=keyboards.main_menu_keyboard(context)
        )
        return ConversationHandler.END

    await query.edit_message_text(
        t("history.menu_header", context),
        reply_markup=keyboards.history_keyboard(transactions, context)
    )
    return ConversationHandler.END


@authenticate_user
async def manage_transaction(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Displays details and edit/delete options for a single transaction."""
    query = update.callback_query
    await query.answer()

    user_id = context.user_data['user_profile']['_id']
    tx_id = query.data.replace('manage_tx_', '')
    tx = api_client.get_transaction_details(tx_id, user_id)

    if not tx:
        await query.edit_message_text(
            t("history.fetch_fail", context),
            reply_markup=keyboards.history_keyboard([], context)
        )
        return

    emoji = "â¬‡ï¸ Expense" if tx['type'] == 'expense' else "â¬†ï¸ Income"
    date_str = datetime.fromisoformat(
        tx['timestamp']
    ).astimezone(PHNOM_PENH_TZ).strftime('%d %b %Y, %I:%M %p')

    currency = tx.get('currency', 'USD') # Default for safety
    amount_format = ",.0f" if currency == 'KHR' else ",.2f"
    amount = tx['amount']
    description = tx.get('description') or 'N/A'

    text = t("history.tx_details", context,
             emoji=emoji,
             amount=f"{amount:{amount_format}}",
             currency=currency,
             category=tx['categoryId'],
             description=description,
             date=date_str)

    await query.edit_message_text(
        text=text,
        parse_mode='HTML',
        reply_markup=keyboards.manage_tx_keyboard(tx_id, context)
    )


@authenticate_user
async def delete_transaction_prompt(update: Update,
                                    context: ContextTypes.DEFAULT_TYPE):
    """Asks the user to confirm deletion."""
    query = update.callback_query
    await query.answer()
    tx_id = query.data.replace('delete_tx_', '')
    await query.edit_message_text(
        t("history.delete_prompt", context),
        parse_mode='HTML',
        reply_markup=keyboards.confirm_delete_keyboard(tx_id, context)
    )


@authenticate_user
async def delete_transaction_confirm(update: Update,
                                     context: ContextTypes.DEFAULT_TYPE):
    """Executes the deletion and shows the main menu."""
    query = update.callback_query
    await query.answer("Deleting...")

    user_id = context.user_data['user_profile']['_id']
    tx_id = query.data.replace('confirm_delete_', '')

    success = api_client.delete_transaction(tx_id, user_id)
    message = (t("history.delete_success", context) if success
               else t("history.delete_fail", context))

    await query.edit_message_text(
        message,
        reply_markup=keyboards.main_menu_keyboard(context)
    )
    return ConversationHandler.END


# --- Edit Transaction Conversation ---

@authenticate_user
async def edit_transaction_start(update: Update,
                                 context: ContextTypes.DEFAULT_TYPE):
    """Asks which field to edit."""
    query = update.callback_query
    await query.answer()
    tx_id = query.data.replace('edit_tx_', '')

    user_profile = context.user_data.get('user_profile')
    context.user_data.clear()
    context.user_data['user_profile'] = user_profile

    context.user_data['edit_tx_id'] = tx_id

    tx = api_client.get_transaction_details(
        tx_id, context.user_data['user_profile']['_id']
    )
    if not tx:
        await query.edit_message_text(t("history.edit_fail", context))
        return ConversationHandler.END

    context.user_data['edit_tx_type'] = tx['type']
    await query.edit_message_text(
        t("history.edit_ask_field", context),
        reply_markup=keyboards.edit_tx_options_keyboard(tx_id, context)
    )
    return EDIT_CHOOSE_FIELD


@authenticate_user
async def edit_choose_field(update: Update,
                            context: ContextTypes.DEFAULT_TYPE):
    """Handles field choice and asks for the new value."""
    query = update.callback_query
    await query.answer()
    parts = query.data.split('_')
    field = parts[2]
    context.user_data['edit_field'] = field

    if field == 'categoryId':
        tx_type = context.user_data['edit_tx_type']
        profile = context.user_data['user_profile']
        all_categories = profile.get('settings', {}).get('categories', {})
        user_categories = all_categories.get(tx_type, [])

        if tx_type == 'expense':
            keyboard = keyboards.expense_categories_keyboard(user_categories,
                                                             context)
        else:
            keyboard = keyboards.income_categories_keyboard(user_categories,
                                                            context)
        await query.edit_message_text(
            t("history.edit_ask_new_category", context),
            reply_markup=keyboard
        )
        return EDIT_GET_NEW_CATEGORY

    if field == 'timestamp':
        await query.edit_message_text(
            t("history.edit_ask_new_date", context)
        )
        return EDIT_GET_NEW_DATE

    if field == 'currency':
        # Only show currency keyboard for dual-mode users
        mode, _ = _get_user_settings_for_tx(context)
        if mode == 'dual':
            await query.edit_message_text(
                t("history.edit_ask_new_currency", context),
                reply_markup=keyboards.currency_keyboard(context)
            )
            return EDIT_GET_NEW_CURRENCY
        else:
            await context.bot.answer_callback_query(
                query.id,
                t("history.edit_no_currency_single", context),
                show_alert=True
            )
            return EDIT_CHOOSE_FIELD # Stay on the same menu

    if field == 'amount':
        await query.edit_message_text(
            t("history.edit_ask_new_amount", context)
        )
    if field == 'description':
        await query.edit_message_text(
            t("history.edit_ask_new_desc", context)
        )

    return EDIT_GET_NEW_VALUE


@authenticate_user
async def edit_received_new_value(update: Update,
                                  context: ContextTypes.DEFAULT_TYPE):
    """Receives new text value (amount/desc) and saves."""
    field = context.user_data['edit_field']
    value = update.message.text

    if field == 'amount':
        try:
            # We don't use the currency parser here, just update the number
            float(value)
        except ValueError:
            await update.message.reply_text(
                t("history.edit_invalid_amount", context)
            )
            return EDIT_GET_NEW_VALUE

    context.user_data['edit_new_value'] = value
    return await save_updated_transaction(update, context)


@authenticate_user
async def edit_received_new_date(update: Update,
                                 context: ContextTypes.DEFAULT_TYPE):
    """Receives new date value and saves."""
    try:
        new_date = datetime.strptime(update.message.text, "%Y-%m-%d").date()
        tx_datetime = datetime.combine(
            new_date, time(12, 0), tzinfo=PHNOM_PENH_TZ
        )
        context.user_data['edit_new_value'] = tx_datetime.isoformat()
        return await save_updated_transaction(update, context)
    except ValueError:
        await update.message.reply_text(
            t("history.edit_invalid_date", context)
        )
        return EDIT_GET_NEW_DATE


@authenticate_user
async def edit_received_new_currency(update: Update,
                                     context: ContextTypes.DEFAULT_TYPE):
    """Receives new currency from button and saves."""
    query = update.callback_query
    await query.answer()
    currency = query.data.split('_')[1]

    context.user_data['edit_new_value'] = currency
    # Also update the accountName to match
    context.user_data['edit_extra_field'] = {
        "field": "accountName",
        "value": f"{currency} Account"
    }
    return await save_updated_transaction(update, context)


@authenticate_user
async def edit_received_new_category(update: Update,
                                     context: ContextTypes.DEFAULT_TYPE):
    """Receives new category from button and saves."""
    query = update.callback_query
    await query.answer()
    category = query.data.split('_')[1]

    if category == 'other':
        await query.edit_message_text(
            t("tx.ask_custom_category", context)
        )
        return EDIT_GET_CUSTOM_CATEGORY

    context.user_data['edit_new_value'] = category
    return await save_updated_transaction(update, context)


@authenticate_user
async def edit_received_custom_category(update: Update,
                                        context: ContextTypes.DEFAULT_TYPE):
    """Receives new custom category text and saves."""
    category = update.message.text.strip().title()
    context.user_data['edit_new_value'] = category
    return await save_updated_transaction(update, context)


async def save_updated_transaction(update: Update,
                                   context: ContextTypes.DEFAULT_TYPE):
    """Final step: save the updated transaction field to the API."""
    user_id = context.user_data['user_profile']['_id']
    tx_id = context.user_data['edit_tx_id']
    field = context.user_data['edit_field']
    value = context.user_data['edit_new_value']

    payload = {field: value}

    # Check if we also need to update accountName (from currency edit)
    if 'edit_extra_field' in context.user_data:
        extra = context.user_data['edit_extra_field']
        payload[extra['field']] = extra['value']

    response = api_client.update_transaction(tx_id, payload, user_id)

    message_interface = (update.callback_query.message if update.callback_query
                         else update.message)

    if response and response.get('message'):
        await message_interface.reply_text(
            t("history.edit_success", context),
            reply_markup=keyboards.main_menu_keyboard(context)
        )
    else:
        error = response.get('error', 'Unknown error')
        await message_interface.reply_text(
            t("history.edit_update_fail", context, error=error),
            reply_markup=keyboards.main_menu_keyboard(context)
        )

    context.user_data.clear()
    return ConversationHandler.END

# --- End of file ---

============================================================

==================== FILE: telegram_bot/handlers/utility.py ====================
# --- Start of file: telegram_bot/handlers/utility.py ---

from telegram import Update
from telegram.ext import ContextTypes, ConversationHandler
import keyboards
import api_client
from decorators import authenticate_user # <-- MODIFICATION: Fix import
from datetime import datetime, timedelta, time
from zoneinfo import ZoneInfo
from .helpers import format_summary_message
import os
from utils.i18n import t

# Conversation states
(
    NEW_RATE,
    SETBALANCE_ACCOUNT, SETBALANCE_AMOUNT,
    REMINDER_PURPOSE, REMINDER_ASK_DATE, REMINDER_CUSTOM_DATE, REMINDER_ASK_TIME
) = range(7)

PHNOM_PENH_TZ = ZoneInfo("Asia/Phnom_Penh")


@authenticate_user # <-- MODIFICATION
async def get_current_rate(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Fetches and displays the current LIVE exchange rate."""
    query = update.callback_query
    await query.answer("Fetching rate...")

    # --- MODIFICATION: Get user_id ---
    user_id = context.user_data['user_profile']['_id']
    data = api_client.get_exchange_rate(user_id) # <-- MODIFICATION
    # ---

    if data and 'rate' in data:
        rate = data['rate']
        source = data.get('source', 'live')
        text = t("utility.rate_header", context, source=source, rate=rate)
    else:
        text = t("utility.rate_fail", context)

    await query.edit_message_text(
        text=text,
        parse_mode='HTML',
        reply_markup=keyboards.main_menu_keyboard(context)
    )


# --- Set Reminder Conversation ---
@authenticate_user # <-- MODIFICATION
async def set_reminder_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    # --- THIS IS THE FIX ---
    user_profile = context.user_data.get('user_profile')
    context.user_data.clear()
    context.user_data['user_profile'] = user_profile
    # --- END FIX ---

    await query.message.reply_text(t("utility.remind_what", context))
    return REMINDER_PURPOSE


@authenticate_user # <-- MODIFICATION
async def received_reminder_purpose(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['reminder_purpose'] = update.message.text
    await update.message.reply_text(
        t("utility.remind_when", context),
        reply_markup=keyboards.reminder_date_keyboard(context)
    )
    return REMINDER_ASK_DATE


@authenticate_user # <-- MODIFICATION
async def received_reminder_date_choice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    choice = query.data.split('_')[-1]
    if choice == 'custom':
        await query.message.reply_text(t("utility.remind_ask_date", context))
        return REMINDER_CUSTOM_DATE

    reminder_date = datetime.now(PHNOM_PENH_TZ).date() + timedelta(days=int(choice))
    context.user_data['reminder_date_part'] = reminder_date
    await query.message.reply_text(t("utility.remind_ask_time", context))
    return REMINDER_ASK_TIME


@authenticate_user # <-- MODIFICATION
async def received_reminder_custom_date(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        custom_date = datetime.strptime(update.message.text, "%Y-%m-%d").date()
        context.user_data['reminder_date_part'] = custom_date
        await update.message.reply_text(t("utility.remind_ask_time", context))
        return REMINDER_ASK_TIME
    except ValueError:
        await update.message.reply_text(t("utility.remind_invalid_date", context))
        return REMINDER_CUSTOM_DATE


@authenticate_user # <-- MODIFICATION
async def received_reminder_time(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        # --- MODIFICATION: Get user_id and chat_id from profile ---
        user_profile = context.user_data['user_profile']
        user_id = user_profile['_id']

        # Use the user's specific reminder chat ID, or fall back to the current chat
        target_chat_id = user_profile.get('settings', {}).get('notification_chat_ids', {}).get('reminder') or update.effective_chat.id
        # ---

        reminder_time = datetime.strptime(update.message.text, "%H:%M").time()
        reminder_date = context.user_data['reminder_date_part']
        aware_dt = datetime.combine(reminder_date, reminder_time, tzinfo=PHNOM_PENH_TZ)
        context.user_data['reminder_datetime'] = aware_dt.isoformat()

        reminder_data = {
            "purpose": context.user_data['reminder_purpose'],
            "reminder_datetime": context.user_data['reminder_datetime'],
            "chat_id": target_chat_id
        }

        api_client.add_reminder(reminder_data, user_id) # <-- MODIFICATION

        await update.message.reply_text(
            t("utility.remind_success", context, date_time=aware_dt.strftime('%d %b %Y at %H:%M')),
            reply_markup=keyboards.main_menu_keyboard(context)
        )
        return ConversationHandler.END
    except ValueError:
        await update.message.reply_text(t("utility.remind_invalid_time", context))
        return REMINDER_ASK_TIME
# --- End of file ---

============================================================

==================== FILE: telegram_bot/keyboards.py ====================
# --- Start of modified file: telegram_bot/keyboards.py ---
from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from datetime import datetime
from telegram.ext import ContextTypes
from utils.i18n import t


def _get_user_settings_for_keyboards(context: ContextTypes.DEFAULT_TYPE):
    """Helper to safely get user settings and currency mode."""
    profile = context.user_data.get('user_profile', {})
    settings = profile.get('settings', {})
    mode = settings.get('currency_mode', 'dual')

    if mode == 'single':
        primary_currency = settings.get('primary_currency', 'USD')
        return mode, (primary_currency,)

    return 'dual', ('USD', 'KHR')


def main_menu_keyboard(context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [
            InlineKeyboardButton(
                t("keyboards.add_expense", context),
                callback_data='add_expense'
            ),
            InlineKeyboardButton(
                t("keyboards.add_income", context),
                callback_data='add_income'
            )
        ],
        [
            InlineKeyboardButton(
                t("keyboards.forgot_log", context),
                callback_data='forgot_log_start'
            ),
            InlineKeyboardButton(
                t("keyboards.quick_check", context),
                callback_data='quick_check'
            ),
        ],
        [
            InlineKeyboardButton(
                t("keyboards.set_reminder", context),
                callback_data='set_reminder_start'
            ),
            InlineKeyboardButton(
                t("keyboards.iou_menu", context),
                callback_data='iou_menu'
            )
        ],
        [
            InlineKeyboardButton(
                t("keyboards.history", context),
                callback_data='history'
            ),
            InlineKeyboardButton(
                t("keyboards.search", context),
                callback_data='search_menu'
            )
        ],
        [
            InlineKeyboardButton(
                t("keyboards.report", context),
                callback_data='report_menu'
            ),
            InlineKeyboardButton(
                t("keyboards.habits", context),
                callback_data='habits_menu'
            )
        ],
        [
            InlineKeyboardButton(
                t("keyboards.get_live_rate", context),
                callback_data='get_live_rate'
            ),
            InlineKeyboardButton(
                t("keyboards.settings", context),
                callback_data='settings_menu'
            )
        ],
    ]
    return InlineKeyboardMarkup(keyboard)


def report_actions_keyboard(start_date, end_date,
                            context: ContextTypes.DEFAULT_TYPE):
    """Keyboard shown after a report is generated."""
    callback_data = f"report_csv:{start_date.isoformat()}:{end_date.isoformat()}"
    keyboard = [
        [
            InlineKeyboardButton(
                t("keyboards.download_report_csv", context), # <-- MODIFIED
                callback_data=callback_data
            )
        ],
        [InlineKeyboardButton(t("keyboards.back_to_main", context), callback_data='start')], # <-- MODIFIED
    ]
    return InlineKeyboardMarkup(keyboard)


def debt_analysis_actions_keyboard(context: ContextTypes.DEFAULT_TYPE):
    """Keyboard shown after debt analysis is generated."""
    keyboard = [
        [
            InlineKeyboardButton(
                t("keyboards.download_open_debts_csv", context), # <-- MODIFIED
                callback_data="debt_analysis_csv"
            )
        ],
        [InlineKeyboardButton(t("keyboards.back_to_iou", context), callback_data='iou_menu')], # <-- MODIFIED
    ]
    return InlineKeyboardMarkup(keyboard)


def search_menu_keyboard(context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [InlineKeyboardButton(
            t("keyboards.search_manage", context), # <-- MODIFIED
            callback_data='start_search_manage'
        )],
        [InlineKeyboardButton(
            t("keyboards.search_sum", context), # <-- MODIFIED
            callback_data='start_search_sum'
        )],
        [InlineKeyboardButton(t("keyboards.back_to_main", context), callback_data='start')], # <-- MODIFIED
    ]
    return InlineKeyboardMarkup(keyboard)


def reminder_date_keyboard(context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [
            InlineKeyboardButton(t("keyboards.tomorrow", context), callback_data='remind_date_1'), # <-- MODIFIED
            InlineKeyboardButton(t("keyboards.in_3_days", context), callback_data='remind_date_3'), # <-- MODIFIED
            InlineKeyboardButton(t("keyboards.in_1_week", context), callback_data='remind_date_7') # <-- MODIFIED
        ],
        [InlineKeyboardButton(t("keyboards.custom_date", context), # <-- MODIFIED
                              callback_data='remind_date_custom')],
        [InlineKeyboardButton(t("keyboards.cancel", context), # <-- MODIFIED
                              callback_data='cancel_conversation')]
    ]
    return InlineKeyboardMarkup(keyboard)


def forgot_day_keyboard(context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [
            InlineKeyboardButton(t("keyboards.yesterday", context), callback_data='forgot_day_1'), # <-- MODIFIED
            InlineKeyboardButton(t("keyboards.days_ago", context, days=2), callback_data='forgot_day_2') # <-- MODIFIED
        ],
        [InlineKeyboardButton(t("keyboards.custom_date", context), # <-- MODIFIED
                              callback_data='forgot_day_custom')],
        [InlineKeyboardButton(t("keyboards.cancel", context), # <-- MODIFIED
                              callback_data='cancel_conversation')]
    ]
    return InlineKeyboardMarkup(keyboard)


def iou_date_keyboard(context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [
            InlineKeyboardButton(t("keyboards.today", context), callback_data='iou_date_today'), # <-- MODIFIED
            InlineKeyboardButton(t("keyboards.yesterday", context), # <-- MODIFIED
                                 callback_data='iou_date_yesterday'),
        ],
        [InlineKeyboardButton(t("keyboards.custom_date", context), # <-- MODIFIED
                              callback_data='iou_date_custom')],
        [InlineKeyboardButton(t("keyboards.cancel", context), # <-- MODIFIED
                              callback_data='cancel_conversation')]
    ]
    return InlineKeyboardMarkup(keyboard)


def forgot_type_keyboard(context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [
            InlineKeyboardButton(t("keyboards.expense", context), # <-- MODIFIED
                                 callback_data='forgot_type_expense'),
            InlineKeyboardButton(t("keyboards.income", context), # <-- MODIFIED
                                 callback_data='forgot_type_income')
        ],
    ]
    return InlineKeyboardMarkup(keyboard)


def report_period_keyboard(context: ContextTypes.DEFAULT_TYPE, is_search=False):
    keyboard = [
        [
            InlineKeyboardButton(t("keyboards.period_today", context), # <-- MODIFIED
                                 callback_data='report_period_today'),
            InlineKeyboardButton(t("keyboards.period_this_week", context), # <-- MODIFIED
                                 callback_data='report_period_this_week'),
        ],
        [
            InlineKeyboardButton(t("keyboards.period_last_week", context), # <-- MODIFIED
                                 callback_data='report_period_last_week'),
            InlineKeyboardButton(t("keyboards.period_this_month", context), # <-- MODIFIED
                                 callback_data='report_period_this_month'),
        ],
        [
            InlineKeyboardButton(t("keyboards.period_last_month", context), # <-- MODIFIED
                                 callback_data='report_period_last_month'),
            InlineKeyboardButton(t("keyboards.period_custom", context), # <-- MODIFIED
                                 callback_data='report_period_custom'),
        ],
    ]
    if is_search:
        keyboard.append([InlineKeyboardButton(
            t("keyboards.period_all_time", context), # <-- MODIFIED
            callback_data='report_period_all_time'
        )])

    keyboard.append([InlineKeyboardButton(t("keyboards.back", context), callback_data='start')]) # <-- MODIFIED
    return InlineKeyboardMarkup(keyboard)


def search_type_keyboard(context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [
            InlineKeyboardButton(t("keyboards.expense", context), # <-- MODIFIED
                                 callback_data='search_type_expense'),
            InlineKeyboardButton(t("keyboards.income", context), # <-- MODIFIED
                                 callback_data='search_type_income')
        ],
        [InlineKeyboardButton(t("keyboards.all_types", context), callback_data='search_type_all')], # <-- MODIFIED
    ]
    return InlineKeyboardMarkup(keyboard)


def skip_keyboard(context: ContextTypes.DEFAULT_TYPE, callback_data):
    keyboard = [
        [InlineKeyboardButton(t("keyboards.skip", context), callback_data=callback_data)], # <-- MODIFIED
    ]
    return InlineKeyboardMarkup(keyboard)


def search_keyword_logic_keyboard(context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [
            InlineKeyboardButton(t("keyboards.search_logic_and", context), # <-- MODIFIED
                                 callback_data='search_logic_and'),
            InlineKeyboardButton(t("keyboards.search_logic_or", context), # <-- MODIFIED
                                 callback_data='search_logic_or')
        ]
    ]
    return InlineKeyboardMarkup(keyboard)


def settings_menu_keyboard(context: ContextTypes.DEFAULT_TYPE):
    mode, currencies = _get_user_settings_for_keyboards(context)

    keyboard = [
        [
            InlineKeyboardButton(
                t("keyboards.settings_update_balances", context), # <-- MODIFIED
                callback_data='settings_set_balance'
            )
        ],
        [
            InlineKeyboardButton(
                t("keyboards.settings_manage_categories", context), # <-- MODIFIED
                callback_data='settings_manage_categories'
            )
        ],
        # --- NEW BUTTON ---
        [
            InlineKeyboardButton(
                t("keyboards.settings_change_language", context),
                callback_data='settings_change_language'
            )
        ],
        # --- END NEW BUTTON ---
    ]

    # Only show rate and mode-switch options to dual-currency users
    # or single-currency users (to let them switch *to* dual)
    if mode == 'dual':
        keyboard.append([
            InlineKeyboardButton(
                t("keyboards.settings_update_rate", context), callback_data='settings_set_rate' # <-- MODIFIED
            )
        ])
    elif mode == 'single':
        keyboard.append([
            InlineKeyboardButton(
                t("keyboards.settings_switch_to_dual", context), # <-- MODIFIED
                callback_data='settings_switch_to_dual'
            )
        ])

    keyboard.append([InlineKeyboardButton(t("keyboards.back_to_main", context), callback_data='start')]) # <-- MODIFIED
    return InlineKeyboardMarkup(keyboard)


def set_balance_account_keyboard(context: ContextTypes.DEFAULT_TYPE, mode: str, currencies: tuple):
    keyboard = []

    if mode == 'dual':
        keyboard.append([
            InlineKeyboardButton(t("keyboards.usd_account", context), # <-- MODIFIED
                                 callback_data='set_balance_USD'),
            InlineKeyboardButton(t("keyboards.khr_account", context), # <-- MODIFIED
                                 callback_data='set_balance_KHR')
        ])
    else:
        # Single currency mode
        curr = currencies[0]
        keyboard.append([
            InlineKeyboardButton(t("keyboards.update_balance", context, currency=curr), # <-- MODIFIED
                                 callback_data=f'set_balance_{curr}'),
        ])

    keyboard.append([InlineKeyboardButton(t("keyboards.back_to_settings", context), # <-- MODIFIED
                                          callback_data='settings_menu')])
    return InlineKeyboardMarkup(keyboard)


def switch_to_dual_confirm_keyboard(context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [
            InlineKeyboardButton(
                t("keyboards.switch_dual_confirm", context), # <-- MODIFIED
                callback_data='confirm_switch_dual'
            )
        ],
        [
            InlineKeyboardButton(
                t("keyboards.switch_dual_cancel", context), # <-- MODIFIED
                callback_data="settings_menu"
            )
        ]
    ]
    return InlineKeyboardMarkup(keyboard)


# --- NEW KEYBOARD ---
def change_language_keyboard(context: ContextTypes.DEFAULT_TYPE):
    """Shows language options for switching."""
    keyboard = [
        [
            InlineKeyboardButton("English", callback_data='change_lang:en'),
            InlineKeyboardButton("áž—áž¶ážŸáž¶ážáŸ’áž˜áŸ‚ážš", callback_data='change_lang:km')
        ],
        [
            InlineKeyboardButton(
                t("keyboards.back_to_settings", context),
                callback_data="settings_menu"
            )
        ]
    ]
    return InlineKeyboardMarkup(keyboard)
# --- END NEW KEYBOARD ---


def manage_categories_keyboard(context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [
            InlineKeyboardButton(t("keyboards.category_add", context), # <-- MODIFIED
                                 callback_data='category_add'),
            InlineKeyboardButton(t("keyboards.category_remove", context), # <-- MODIFIED
                                 callback_data='category_remove')
        ],
        [InlineKeyboardButton(t("keyboards.back_to_settings", context), # <-- MODIFIED
                              callback_data='settings_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)


def category_type_keyboard(context: ContextTypes.DEFAULT_TYPE, action: str):
    """Generates a keyboard to select category type (expense/income)."""
    keyboard = [
        [
            InlineKeyboardButton(
                t("keyboards.expense", context), callback_data=f'cat_type:{action}:expense' # <-- MODIFIED
            ),
            InlineKeyboardButton(
                t("keyboards.income", context), callback_data=f'cat_type:{action}:income' # <-- MODIFIED
            )
        ],
        [
            InlineKeyboardButton(
                t("keyboards.back", context), callback_data='settings_manage_categories' # <-- MODIFIED
            )
        ]
    ]
    return InlineKeyboardMarkup(keyboard)


def iou_menu_keyboard(context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [InlineKeyboardButton(t("keyboards.iou_lent", context), callback_data='iou_lent')], # <-- MODIFIED
        [InlineKeyboardButton(t("keyboards.iou_borrowed", context), # <-- MODIFIED
                              callback_data='iou_borrowed')],
        [InlineKeyboardButton(t("keyboards.iou_view_open", context), callback_data='iou_view')], # <-- MODIFIED
        [InlineKeyboardButton(t("keyboards.iou_view_settled", context), # <-- MODIFIED
                              callback_data='iou_view_settled')],
        [InlineKeyboardButton(t("keyboards.iou_analysis", context), # <-- MODIFIED
                              callback_data='debt_analysis')],
        [InlineKeyboardButton(t("keyboards.back_to_main", context), callback_data='start')], # <-- MODIFIED
    ]
    return InlineKeyboardMarkup(keyboard)


def iou_list_keyboard(grouped_debts, context: ContextTypes.DEFAULT_TYPE,
                      is_settled=False):
    """Shows a consolidated list of debts grouped by person."""
    keyboard = []
    status_str = "settled" if is_settled else "open"

    mode, currencies = _get_user_settings_for_keyboards(context)

    lent = [d for d in grouped_debts if d['type'] == 'lent']
    borrowed = [d for d in grouped_debts if d['type'] == 'borrowed']

    def format_totals(totals):
        parts = []
        for t in totals:
            # Only show totals for currencies the user cares about
            if t['currency'] in currencies:
                amount_format = ",.0f" if t['currency'] == 'KHR' else ",.2f"
                parts.append(
                    f"{t['total']:{amount_format}} {t['currency']} ({t['count']})"
                )
        return ", ".join(parts) if parts else None

    if lent:
        for debt in lent:
            formatted_total = format_totals(debt['totals'])
            if formatted_total: # Only show if there's a relevant total
                label = t("keyboards.iou_person_lent", context, person=debt['person'], totals=formatted_total) # <-- MODIFIED
                keyboard.append(
                    [InlineKeyboardButton(
                        label,
                        callback_data=f"iou:person:{status_str}:{debt['person']}"
                    )]
                )
    if borrowed:
        for debt in borrowed:
            formatted_total = format_totals(debt['totals'])
            if formatted_total: # Only show if there's a relevant total
                label = t("keyboards.iou_person_borrowed", context, person=debt['person'], totals=formatted_total) # <-- MODIFIED
                keyboard.append(
                    [InlineKeyboardButton(
                        label,
                        callback_data=f"iou:person:{status_str}:{debt['person']}"
                    )]
                )

    keyboard.append([InlineKeyboardButton(t("keyboards.back", context), callback_data='iou_menu')]) # <-- MODIFIED
    return InlineKeyboardMarkup(keyboard)


def iou_person_actions_keyboard(person_name, debt_type,
                                context: ContextTypes.DEFAULT_TYPE,
                                is_settled=False):
    """Shows action buttons for the unified person ledger screen."""
    keyboard = []

    if not is_settled:
        keyboard.append([
            InlineKeyboardButton(
                t("keyboards.iou_record_repayment", context), # <-- MODIFIED
                callback_data=f"iou:repay:{person_name}:{debt_type}"
            ),
            InlineKeyboardButton(
                t("keyboards.iou_manage_individual", context), # <-- MODIFIED
                callback_data=f"iou:manage:list:{person_name}:{debt_type}:False"
            )
        ])

    back_callback = 'iou_view_settled' if is_settled else 'iou_view'
    keyboard.append([InlineKeyboardButton(
        t("keyboards.back_to_summary", context), callback_data=back_callback # <-- MODIFIED
    )])
    return InlineKeyboardMarkup(keyboard)


def iou_manage_list_keyboard(person_debts, person_name,
                             debt_type, is_settled,
                             context: ContextTypes.DEFAULT_TYPE):
    """Displays a list of individual debts for management (Edit/Cancel)."""
    keyboard = []

    mode, currencies = _get_user_settings_for_keyboards(context)

    for debt in person_debts:
        # Filter list by user's currency mode
        if debt.get('currency') not in currencies:
            continue

        created_date = datetime.fromisoformat(
            debt['created_at']
        ).strftime('%d %b')
        purpose = debt.get('purpose') or 'No purpose'
        amount_key = 'remainingAmount' if not is_settled else 'originalAmount'
        amount = debt.get(amount_key, 0)
        currency = debt.get('currency')

        amount_format = ",.0f" if currency == 'KHR' else ",.2f"
        label = f"{amount:{amount_format}} {currency} " \
                f"({created_date}) - {purpose}"

        callback = f"iou:detail:{debt['_id']}:{person_name}:{is_settled}"
        keyboard.append([InlineKeyboardButton(label, callback_data=callback)])

    back_callback = (
        f"iou:person:settled:{person_name}"
        if is_settled
        else f"iou:person:open:{person_name}"
    )
    keyboard.append([InlineKeyboardButton(
        t("keyboards.back_to_ledger", context), callback_data=back_callback # <-- MODIFIED
    )])
    return InlineKeyboardMarkup(keyboard)


def iou_detail_actions_keyboard(debt_id, person_name, debt_type,
                                is_settled, status,
                                context: ContextTypes.DEFAULT_TYPE):
    """Shows actions for a single, specific debt."""
    keyboard = []

    if status == 'open':
        keyboard.append([
            InlineKeyboardButton(
                t("keyboards.iou_edit_cancel", context), # <-- MODIFIED
                callback_data=f"iou:manage:detail:{debt_id}:{person_name}:"
                              f"{is_settled}"
            )
        ])

    back_callback = f"iou:manage:list:{person_name}:{debt_type}:{is_settled}"
    keyboard.append([InlineKeyboardButton(
        t("keyboards.back_to_list", context), callback_data=back_callback # <-- MODIFIED
    )])
    return InlineKeyboardMarkup(keyboard)


def iou_manage_keyboard(debt_id, person, is_settled_str,
                        context: ContextTypes.DEFAULT_TYPE):
    """Keyboard for editing or canceling a debt."""
    keyboard = [
        [
            InlineKeyboardButton(
                t("keyboards.iou_edit_person", context), callback_data=f"iou:edit:person:{debt_id}" # <-- MODIFIED
            ),
            InlineKeyboardButton(
                t("keyboards.iou_edit_purpose", context), callback_data=f"iou:edit:purpose:{debt_id}" # <-- MODIFIED
            )
        ],
        [
            InlineKeyboardButton(
                t("keyboards.iou_cancel_debt", context), # <-- MODIFIED
                callback_data=f"iou:cancel:prompt:{debt_id}:{person}:"
                              f"{is_settled_str}"
            )
        ],
        [
            InlineKeyboardButton(
                t("keyboards.back", context), # <-- MODIFIED
                callback_data=f"iou:detail:{debt_id}:{person}:{is_settled_str}"
            )
        ]
    ]
    return InlineKeyboardMarkup(keyboard)


def iou_cancel_confirm_keyboard(debt_id, person, is_settled_str,
                                context: ContextTypes.DEFAULT_TYPE):
    """Confirmation keyboard for canceling a debt."""
    keyboard = [
        [
            InlineKeyboardButton(
                t("keyboards.iou_cancel_confirm", context), # <-- MODIFIED
                callback_data=f"iou:cancel:confirm:{debt_id}"
            )
        ],
        [
            InlineKeyboardButton(
                t("keyboards.iou_cancel_go_back", context), # <-- MODIFIED
                callback_data=f"iou:manage:detail:{debt_id}:{person}:"
                              f"{is_settled_str}"
            )
        ]
    ]
    return InlineKeyboardMarkup(keyboard)


def currency_keyboard(context: ContextTypes.DEFAULT_TYPE):
    """
    Returns a currency keyboard, always showing USD and KHR.
    This is only used in dual-currency mode.
    """
    keyboard = [
        [
            InlineKeyboardButton("ðŸ’µ USD", callback_data='curr_USD'),
            InlineKeyboardButton("áŸ› KHR", callback_data='curr_KHR')
        ]
    ]
    return InlineKeyboardMarkup(keyboard)


def expense_categories_keyboard(categories: list,
                                context: ContextTypes.DEFAULT_TYPE):
    """Builds a dynamic keyboard from the user's category list."""
    keyboard = []
    row = []
    for category in categories:
        # Use the category as a KEY to get the translated emoji + text
        translated_text = t(f"categories.{category}", context)
        row.append(
            InlineKeyboardButton(translated_text, callback_data=f'cat_{category}')
        )
        if len(row) == 2:
            keyboard.append(row)
            row = []

    if row:  # Add any remaining buttons
        keyboard.append(row)

    # Add the static "Other" button
    keyboard.append([
        InlineKeyboardButton(
            t("keyboards.other", context), callback_data='cat_other'
        )
    ])
    return InlineKeyboardMarkup(keyboard)


def income_categories_keyboard(categories: list,
                               context: ContextTypes.DEFAULT_TYPE):
    """Builds a dynamic keyboard from the user's category list."""
    keyboard = []
    row = []
    for category in categories:
        # Use the category as a KEY to get the translated emoji + text
        translated_text = t(f"categories.{category}", context)
        row.append(
            InlineKeyboardButton(translated_text, callback_data=f'cat_{category}')
        )
        if len(row) == 2:
            keyboard.append(row)
            row = []

    if row:  # Add any remaining buttons
        keyboard.append(row)

    # Add the static "Other" button
    keyboard.append([
        InlineKeyboardButton(
            t("keyboards.other", context), callback_data='cat_other'
        )
    ])
    return InlineKeyboardMarkup(keyboard)


def ask_remark_keyboard(context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [
            InlineKeyboardButton(t("keyboards.add_remark", context), callback_data='remark_yes'), # <-- MODIFIED
            InlineKeyboardButton(t("keyboards.skip", context), callback_data='remark_no') # <-- MODIFIED
        ]
    ]
    return InlineKeyboardMarkup(keyboard)


def history_keyboard(transactions, context: ContextTypes.DEFAULT_TYPE,
                     is_search_result=False):
    keyboard = []
    if not is_search_result:
        keyboard.append([InlineKeyboardButton(
            t("keyboards.search", context), callback_data='search_menu'
        )])

    mode, currencies = _get_user_settings_for_keyboards(context)

    for tx in transactions:
        # Filter list by user's currency mode
        if tx.get('currency') not in currencies:
            continue

        amount = tx.get('amount', 0)
        currency = tx.get('currency', 'N/A')
        category = tx.get('categoryId', 'Unknown')
        tx_type_emoji = "â¬‡ï¸" if tx.get('type') == 'expense' else "â¬†ï¸"

        amount_format = ",.0f" if currency == 'KHR' else ",.2f"
        label = f"{tx_type_emoji} {amount:{amount_format}} " \
                f"{currency} - {category}"
        callback = f"manage_tx_{tx['_id']}"
        keyboard.append([InlineKeyboardButton(label, callback_data=callback)])

    keyboard.append([InlineKeyboardButton(
        t("keyboards.back_to_main", context), callback_data='start' # <-- MODIFIED
    )])
    return InlineKeyboardMarkup(keyboard)


def manage_tx_keyboard(tx_id, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [
            InlineKeyboardButton(t("keyboards.edit", context), callback_data=f'edit_tx_{tx_id}'), # <-- MODIFIED
            InlineKeyboardButton(t("keyboards.delete", context), # <-- MODIFIED
                                 callback_data=f'delete_tx_{tx_id}')
        ],
        [InlineKeyboardButton(t("keyboards.back_to_history", context), callback_data='history')], # <-- MODIFIED
    ]
    return InlineKeyboardMarkup(keyboard)


def edit_tx_options_keyboard(tx_id, context: ContextTypes.DEFAULT_TYPE):

    mode, currencies = _get_user_settings_for_keyboards(context)

    keyboard = [
        [
            InlineKeyboardButton(
                t("keyboards.edit_amount", context), callback_data=f'edit_field_amount_{tx_id}' # <-- MODIFIED
            ),
            InlineKeyboardButton(
                t("keyboards.edit_category", context), callback_data=f'edit_field_categoryId_{tx_id}' # <-- MODIFIED
            ),
        ],
        [
            InlineKeyboardButton(
                t("keyboards.edit_description", context), # <-- MODIFIED
                callback_data=f'edit_field_description_{tx_id}'
            ),
            InlineKeyboardButton(
                t("keyboards.edit_date", context), callback_data=f'edit_field_timestamp_{tx_id}' # <-- MODIFIED
            ),
        ],
    ]

    # Only show the "Edit Currency" button to dual-mode users
    if mode == 'dual':
        keyboard.append([
            InlineKeyboardButton(
                t("keyboards.edit_currency", context), callback_data=f'edit_field_currency_{tx_id}' # <-- MODIFIED
            )
        ])

    keyboard.append([InlineKeyboardButton(
        t("keyboards.edit_cancel", context), callback_data=f'manage_tx_{tx_id}' # <-- MODIFIED
    )])

    return InlineKeyboardMarkup(keyboard)


def confirm_delete_keyboard(tx_id, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [
            InlineKeyboardButton(t("keyboards.delete_confirm", context), # <-- MODIFIED
                                 callback_data=f'confirm_delete_{tx_id}'),
            InlineKeyboardButton(t("keyboards.delete_cancel", context), # <-- MODIFIED
                                 callback_data=f'manage_tx_{tx_id}')
        ]
    ]
    return InlineKeyboardMarkup(keyboard)

# --- End of modified file ---

============================================================

==================== FILE: telegram_bot/locales/en.json ====================
{
  "common": {
    "welcome": "Welcome, {name}!",
    "quick_check_header": "ðŸ” Here is your quick summary:",
    "cancel": "Operation cancelled.",
    "cancel_onboarding": "Onboarding cancelled. Type /start to try again when you're ready.",
    "error_generic": "An error occurred.\n    Please try again later.",
    "expense_word": "Expense",
    "income_word": "Income"
  },
  "summary": {
    "status_header": "\n\n--- Your Current Status ---",
    "balances": "<b>Balances:</b>",
    "debts": "<b>Debts:</b>",
    "you_are_owed": "âž¡ï¸ <b>You are owed:</b>",
    "you_owe": "â¬…ï¸ <b>You owe:</b>",
    "activity_header": "<b>Operational Activity (Excl. Loans):</b>",
    "today": "<b>Today:</b>",
    "this_week": "<b>This Week:</b>",
    "last_week": "<b>Last Week:</b>",
    "this_month": "<b>This Month:</b>",
    "in": "    â¬†ï¸ In: {value}",
    "out": "    â¬‡ï¸ Out: {value}",
    "net": "    <b>Net: ${value:,.2f}</b> {emoji}"
  },
  "keyboards": {
    "add_expense": "ðŸ’¸ Add Expense",
    "add_income": "ðŸ’° Add Income",
    "forgot_log": "ðŸ¤” Forgot to Log?",
    "quick_check": "ðŸ” Quick Check",
    "set_reminder": "ðŸ”” Set Reminder",
    "iou_menu": "ðŸ¤ IOU / Debts",
    "history": "ðŸ“– History",
    "search": "ðŸ”Ž Search & Analyze",
    "report": "ðŸ“ˆ Report",
    "habits": "ðŸ§  Habits",
    "get_live_rate": "ðŸ“Š Get Live Rate",
    "settings": "âš™ï¸ Settings",
    "other": "ðŸ“ Other",
    "back_to_main": "â€¹ Back to Main Menu",
    "download_report_csv": "ðŸ“„ Download Report CSV",
    "download_open_debts_csv": "ðŸ“„ Download Open Debts CSV",
    "back_to_iou": "â€¹ Back to IOU Menu",
    "search_manage": "âœï¸ Find & Manage Transactions",
    "search_sum": "ðŸ“ˆ Calculate Totals",
    "tomorrow": "Tomorrow",
    "in_3_days": "In 3 Days",
    "in_1_week": "In 1 Week",
    "custom_date": "ðŸ—“ï¸ Custom Date",
    "cancel": "âŒ Cancel",
    "yesterday": "Yesterday",
    "days_ago": "{days} Days Ago",
    "today": "Today",
    "expense": "ðŸ’¸ Expense",
    "income": "ðŸ’° Income",
    "period_today": "ðŸ—“ï¸ Today",
    "period_this_week": "ðŸ—“ï¸ This Week",
    "period_last_week": "ðŸ—“ï¸ Last Week",
    "period_this_month": "ðŸ—“ï¸ This Month",
    "period_last_month": "ðŸ—“ï¸ Last Month",
    "period_custom": "ðŸ—“ï¸ Custom Range",
    "period_all_time": "â™¾ï¸ All Time",
    "back": "â€¹ Back",
    "all_types": "ðŸŒ All Types",
    "skip": "â© Skip",
    "search_logic_and": "Must contain ALL (AND)",
    "search_logic_or": "Contains ANY (OR)",
    "settings_update_balances": "ðŸ’¸ Update Initial Balances",
    "settings_manage_categories": "ðŸ·ï¸ Manage Categories",
    "settings_update_rate": "ðŸ“ˆ Update Fixed Rate",
    "settings_switch_to_dual": "ðŸ”„ Switch to Dual-Currency Mode",
    "settings_change_language": "ðŸŒ Change Language",
    "usd_account": "ðŸ’µ USD Account",
    "khr_account": "áŸ› KHR Account",
    "update_balance": "Update {currency} Balance",
    "back_to_settings": "â€¹ Back to Settings",
    "switch_dual_confirm": "âœ… Yes, Switch Me",
    "switch_dual_cancel": "â€¹ No, Go Back",
    "category_add": "âž• Add Category",
    "category_remove": "âž– Remove Category",
    "iou_lent": "âž¡ï¸ I Lent Money",
    "iou_borrowed": "â¬…ï¸ I Borrowed Money",
    "iou_view_open": "ðŸ“– View Open Debts",
    "iou_view_settled": "âœ… View Settled Debts",
    "iou_analysis": "ðŸ”¬ Debt Analysis",
    "iou_person_lent": "Owed by {person}: {totals}",
    "iou_person_borrowed": "You owe {person}: {totals}",
    "iou_record_repayment": "ðŸ’° Record Repayment",
    "iou_manage_individual": "âœï¸ Manage Individual Debts",
    "back_to_summary": "â€¹ Back to Summary",
    "back_to_ledger": "â€¹ Back to Ledger",
    "back_to_list": "â€¹ Back to List",
    "iou_edit_cancel": "âœï¸ Edit/Cancel",
    "iou_edit_person": "âœï¸ Edit Person",
    "iou_edit_purpose": "âœï¸ Edit Purpose",
    "iou_cancel_debt": "âŒ Cancel Debt",
    "iou_cancel_confirm": "âœ… Yes, Cancel Debt",
    "iou_cancel_go_back": "â€¹ No, Go Back",
    "add_remark": "âœ… Add Remark",
    "edit": "âœï¸ Edit",
    "delete": "ðŸ—‘ï¸ Delete",
    "back_to_history": "â€¹ Back to History",
    "edit_amount": "ðŸ’° Amount",
    "edit_category": "ðŸ·ï¸ Category",
    "edit_description": "ðŸ“ Description",
    "edit_date": "ðŸ—“ï¸ Date",
    "edit_currency": "ðŸª™ Currency",
    "edit_cancel": "â€¹ Cancel Edit",
    "delete_confirm": "âœ… Yes, Delete",
    "delete_cancel": "âŒ No, Cancel"
  },
  "onboarding": {
    "welcome": "Welcome to FinanceBot!\n    Letâ€™s set up your account.",
    "ask_mode": "Would you like to track ONE currency or TWO currencies (USD & KHR)?\n\n(Reply with: `1` or `2`)",
    "invalid_mode": "Invalid choice.\n    Please reply with `1` or `2`.",
    "ask_language": "You've chosen 2 currencies.\n    What is your preferred language?\n\n(Reply with: `en` or `km`)",
    "invalid_language": "Invalid choice.\n    Please reply with `en` or `km`.",
    "ask_name_en": "What is your name (in English)?\n\n(e.g., John Doe)",
    "ask_name_km": "What is your name (in Khmer)?\n\n(e.g., áž…áž“ ážŠáž¼)",
    "ask_primary_currency": "You've chosen 1 currency.\n    Which currency will be your primary one?\n\n(Reply with a currency code, e.g.: `USD`, `KHR`, `CNY`)",
    "ask_usd_balance": "Great, {name}.\n    Let's set your starting balances.\n\nWhat is your current **USD** balance?\n\n(Reply with a number, e.g.: `100.50`)",
    "ask_khr_balance": "Got it.\n    Now, what is your current **KHR** balance?\n\n(Reply with a number, e.g.: `50000`)",
    "ask_single_balance": "Great, {name}.\n    Let's set your starting balance.\n\nWhat is your current **{currency}** balance?\n\n(Reply with a number, e.g.: `150.50`)",
    "invalid_amount": "That doesn't look like a valid number.\n    Please try again (e.g., `100.50`).",
    "setup_complete": "ðŸŽ‰ Setup Complete!\n\nYou're all set.\n    Here is the main menu."
  },
  "settings": {
    "menu_header": "<b>âš™ï¸ Bot Settings</b>\n\nHere you can manage your preferences and initial data.\n\n<b>Currency Mode:</b> {mode}\n\n<b>Initial Balances:</b>\n{balance_text}\n\n<b>Exchange Rate:</b> {rate_text}\n",
    "ask_balance_account": "Which initial balance do you want to set/update?",
    "ask_balance_amount": "Account: <b>{currency}</b>\n\nWhat is the new initial balance?\n    (This will NOT create a transaction).",
    "balance_set_success": "âœ… Initial balance for {currency} updated to {amount:,.2f}.",
    "ask_rate": "Please enter your new **fixed** exchange rate for 1 USD to KHR (e.g., `4100`).\n\nThis will also set your preference to 'fixed'.",
    "rate_set_success": "âœ… Your fixed exchange rate is now set to {rate}.",
    "invalid_rate": "Invalid number.\n    Please enter a valid rate.",
    "categories_header": "<b>ðŸ·ï¸ Manage Categories</b>\n\n<b>Expense:</b>\n  {expense_cats}\n\n<b>Income:</b>\n  {income_cats}\n",
    "category_ask_add": "What type of category do you want to add?",
    "category_ask_remove": "What type of category do you want to remove?",
    "category_ask_name": "Please type the name of the new **{cat_type}** category to {action}:",
    "category_add_success": "âœ… Category '{name}' added to {type}.",
    "category_remove_success": "âœ… Category '{name}' removed from {type}.",
    "switch_to_dual_confirm": "This will switch your account to dual-currency (USD & KHR) mode.\n    This allows you to log transactions in both currencies and cannot be undone.\n\nAre you sure?",
    "ask_name_km_switch": "Great.\n    Please reply with your name in Khmer (e.g., áž…áž“ ážŠáž¼).",
    "switch_to_dual_success": "âœ… Success!\n    Your account is now in dual-currency mode and your language is set to Khmer.\n    You can change the language back in settings.",
    "ask_new_language": "Please select your new preferred language:",
    "ask_missing_name_km": "You are switching to Khmer, but your Khmer name is not set.\n\nPlease reply with your name in Khmer (e.g., áž…áž“ ážŠáž¼):",
    "ask_missing_name_en": "You are switching to English, but your English name is not set.\n\nPlease reply with your name in English (e.g., John Doe):",
    "language_switch_success": "âœ… Language successfully updated!"
  },
  "tx": {
    "ask_amount": "{emoji} Enter the amount:",
    "ask_currency": "Which currency?",
    "ask_category": "Amount: <b>{amount_display}</b> (auto-selected)\n\nWhich category?",
    "ask_category_curr": "Currency: <b>{currency}</b>\n\nWhich category?",
    "ask_custom_category": "Please type your custom category name:",
    "ask_remark": "Category: <b>{category}</b>\n\nAdd a remark/description?",
    "ask_remark_prompt": "Please type your remark.",
    "success": "âœ… Transaction recorded successfully!",
    "fail": "âŒ Failed to record transaction.",
    "invalid_amount": "Please enter a valid number."
  },
  "forgot": {
    "ask_day": "Which day did you forget to log?",
    "ask_date": "Please enter the date in `YYYY-MM-DD` format.",
    "ask_type": "Got it.\n    Was it an expense or an income?",
    "ask_amount": "Type: <b>{type}</b>\n\nEnter the amount:",
    "invalid_date": "Invalid format.\n    Please use `YYYY-MM-DD`."
  },
  "utility": {
    "rate_header": "ðŸ“ˆ Using **{source}** rate:\n<b>1 USD = {rate:,.0f} KHR</b>",
    "rate_fail": "âŒ Could not fetch the exchange rate.",
    "remind_what": "What would you like to be reminded of?",
    "remind_when": "When should I remind you?",
    "remind_ask_date": "Please enter the date in `YYYY-MM-DD` format.",
    "remind_ask_time": "Got it.\n    And at what time? (e.g., `09:00`, `17:30`)",
    "remind_success": "âœ… Got it!\n    I will remind you on {date_time}.",
    "remind_invalid_date": "Invalid format.\nPlease use `YYYY-MM-DD`.",
    "remind_invalid_time": "Invalid time format.\nPlease use `HH:MM` (24-hour)."
  },
  "history": {
    "menu_header": "Recent transactions:",
    "no_tx": "No recent transactions found.",
    "tx_details": "<b>Transaction Details:</b>\n\n<b>Type:</b> {emoji}\n<b>Amount:</b> {amount} {currency}\n<b>Category:</b> {category}\n<b>Description:</b> {description}\n<b>Date:</b> {date}\n\nWhat would you like to do?",
    "tx_details_no_prompt": "<b>Type:</b> {emoji}\n<b>Amount:</b> {amount} {currency}\n<b>Category:</b> {category}\n<b>Description:</b> {description}\n<b>Date:</b> {date}",
    "fetch_fail": "Error: Could not fetch transaction details.",
    "delete_prompt": "âš ï¸ Are you sure you want to delete this transaction?",
    "delete_success": "ðŸ—‘ï¸ Transaction successfully deleted.",
    "delete_fail": "âŒ Error: Could not delete transaction.",
    "edit_ask_field": "Which field would you like to edit?",
    "edit_fail": "âŒ Error: Transaction not found.",
    "edit_ask_new_date": "Please enter the new date (`YYYY-MM-DD`):",
    "edit_ask_new_amount": "Please enter the new amount:",
    "edit_ask_new_desc": "Please enter the new description:",
    "edit_ask_new_category": "Please select the new category:",
    "edit_no_currency_single": "You are in single-currency mode and cannot edit the currency.",
    "edit_invalid_amount": "Invalid amount.\nPlease enter a valid number.",
    "edit_invalid_date": "Invalid date format.\nPlease use `YYYY-MM-DD`.",
    "edit_success": "âœ… Transaction successfully updated!",
    "edit_update_fail": "âŒ Error: {error}"
  },
  "command": {
    "calculating": "ðŸ§® Result: `{result}`",
    "calculator_fail": "Couldn't calculate that.\nPlease check the expression.",
    "invalid_format_generic": "âš ï¸ Invalid format.\n`!{command} <Category> [\"Description\"] <Amount>[khr] [MM-DD]`\n\n(Tip: Use quotes for multi-word descriptions)",
    "invalid_format_debt": "âš ï¸ Invalid format.\n`!{command} <Person> <Amount>[khr] [\"Purpose\"] [MM-DD]`\n\n(Tip: Use quotes for multi-word names or purposes)",
    "invalid_format_missing_amount": "âš ï¸ Invalid format.\nAmount is missing.",
    "invalid_format_repayment": "âš ï¸ Format: {example}",
    "repayment_error": "âŒ Error: {error}",
    "repayment_fail": "âš ï¸ Invalid format for repayment command.",
    "error_generic": "An error occurred during quick command processing.",
    "error_parsing": "An error occurred.\nPlease check the format.",
    "tx_fail": "âŒ Failed to record transaction.",
    "debt_fail": "âŒ Failed to save record.",
    "unknown_prompt": "New expense '{description}' for {amount_display}.\nWhich category?",
    "unknown_ask_custom": "Please type your new custom category name:",
    "unknown_fail": "I'm not sure what you mean.\nPlease provide an amount (e.g., '!coffee 2.50').",
    "parse_error": "âš ï¸ Parsing error.\nCheck your quotes: {error}",
    "success_header": "<b>âœ… Recorded:</b>",
    "success_type": "  - <b>Type:</b> {type}",
    "success_amount": "  - <b>Amount:</b> {amount_display}",
    "success_category": "  - <b>Category:</b> {category}",
    "success_description": "  - <b>Description:</b> {description}",
    "success_person": "  - <b>Person:</b> {person}",
    "success_purpose": "  - <b>Purpose:</b> {purpose}",
    "success_date": "  - <b>Date:</b> {date}"
  },
  "iou": {
    "menu_header": "ðŸ¤ Let's manage your IOUs.",
    "view_header_open": "Here is a summary of your **open** debts.\nSelect one to see details:",
    "view_header_settled": "Here is a summary of your **settled/canceled** debts.\nSelect one to see details:",
    "view_no_open": "You have no open debts!\nðŸ‘",
    "view_no_settled": "You have no settled debts.",
    "person_header_open": "<b>Open Debts for {person}</b> ({direction})\n\n",
    "person_header_settled": "<b>Settled Debts for {person}</b> ({direction})\n\n",
    "person_direction_lent": "owes you",
    "person_direction_borrowed": "you owe",
    "person_direction_lent_past": "owed you",
    "person_direction_borrowed_past": "you owed",
    "person_fail": "âŒ Could not find any open debts for {person}.",
    "person_fail_settled": "âŒ Could not find any settled debts for {person}.",
    "ledger_total_remaining": "<b>Total Remaining:</b>",
    "ledger_none": "  None",
    "ledger_header": "<b>Full Ledger (Oldest First):</b>",
    "manage_header": "Select a specific debt to manage:",
    "manage_fail": "âŒ No debts found to manage.",
    "detail_fail": "âŒ Error: Could not find this debt.",
    "debt_details_header": "<b>Debt Details (Status: {status})</b>",
    "debt_person": "<b>Person:</b> {person} ({direction})",
    "debt_direction_lent": "Owes you",
    "debt_direction_borrowed": "You owe",
    "debt_created": "<b>Date Created:</b> {date}",
    "debt_purpose": "<b>Purpose:</b> {purpose}\n",
    "debt_original": "<b>Original Amount:</b> {amount} {currency}",
    "debt_remaining": "<b>Remaining Balance:</b> {amount} {currency}\n",
    "debt_repayments": "<b>Repayment History:</b>",
    "debt_repayment_item": "  - {amount} {currency} on {date}",
    "analysis_header": "ðŸ”¬ <b>Debt Analysis</b>",
    "analysis_loading": "Analyzing debts...",
    "analysis_fail": "Could not perform debt analysis.",
    "analysis_lent_header": "\n<b>Top People You've Lent To:</b>",
    "analysis_lent_none": "    - No one owes you money.\n",
    "analysis_borrow_header": "\n<b>Top People You've Borrowed From:</b>",
    "analysis_borrow_none": "    - You don't owe anyone money.\n",
    "analysis_aging_header": "\n<b>Oldest Outstanding Debts (Avg.\nAge):</b>",
    "analysis_aging_none": "    - No open debts to analyze.\n",
    "analysis_item": "    - {person}: ${total:,.2f}",
    "analysis_aging_item": "    - {person}: {days:.0f} days ({count} loans)",
    "ask_date": "When did this happen?",
    "ask_person_lent": "Who did you lend money to?",
    "ask_person_borrowed": "Who did you borrow from?",
    "ask_date_custom": "Please enter the date in `YYYY-MM-DD` format.",
    "ask_amount": "How much?",
    "ask_purpose": "Amount: <b>{amount_display}</b>\n\nWhat was this for?\n(e.g., Lunch, Deposit)",
    "ask_currency": "Which currency?",
    "ask_purpose_curr": "Currency: <b>{currency}</b>\n\nWhat was this for?\n(e.g., Lunch, Deposit)",
    "invalid_amount": "Please enter a valid number for the amount (e.g. 20.50 or 10000khr).",
    "success": "âœ… Debt successfully recorded!",
    "fail": "âŒ Failed to record debt.",
    "repay_ask_amount_lent": "How much did {person} repay you (in USD or KHR)?",
    "repay_ask_amount_borrowed": "How much did you repay {person} (in USD or KHR)?",
    "repay_invalid_amount": "Please enter a valid amount and currency (e.g., '50.50' or '20000khr').",
    "repay_success": "âœ… {message}",
    "repay_fail": "âŒ Error: {error}",
    "manage_menu_header": "What would you like to do for this debt with {person}?",
    "cancel_prompt": "âš ï¸ **Are you sure you want to cancel this debt?**\n\nThis will create a reversing transaction to balance your accounts and mark the debt as 'Canceled'.\nThis action cannot be undone.",
    "cancel_confirm": "Canceling...",
    "cancel_success": "âœ… {message}",
    "cancel_fail": "âŒ Error: {error}",
    "edit_ask_person": "Please enter the new person's name:",
    "edit_ask_purpose": "Please enter the new purpose:",
    "edit_error_context": "Error: Conversation context lost.\nPlease try again.",
    "edit_success": "âœ… {message}",
    "edit_fail": "âŒ Error: {error}"
  },
  "analytics": {
    "report_ask_period": "What period would you like a report for?",
    "report_ask_start": "Please enter the start date (`YYYY-MM-DD`):",
    "report_ask_end": "Start date set to {date}.\nNow, please enter the end date (`YYYY-MM-DD`):",
    "report_invalid_date": "Invalid date format.\nPlease use `YYYY-MM-DD`.",
    "report_invalid_range": "Invalid date range.\nEnd date cannot be before start date.",
    "report_generating": "ðŸ“ˆ Generating your report for {start_date:%b %d, %Y} to {end_date:%b %d, %Y}...",
    "report_success": "Report complete!\nWhat's next?",
    "report_fail": "Could not generate report.\nNo data found for this period.",
    "habits_ask_period": "ðŸ§  For which period would you like to analyze your spending habits?",
    "habits_no_custom": "Custom date range is not available for habits analysis.\nPlease select a standard period.",
    "habits_generating": "ðŸ§  Analyzing your habits...",
    "habits_fail": "Could not find enough data to analyze your habits for this period.",
    "habits_invalid_period": "Invalid period selected."
  },
  "search": {
    "menu_header": "What type of search do you want to perform?",
    "ask_period": "ðŸ”Ž Advanced Search\n\nFirst, select a time period for the search.",
    "ask_start": "Please enter the start date (`YYYY-MM-DD`):",
    "ask_end": "Start date set to {date:%Y-%m-%d}.\nNow, please enter the end date (`YYYY-MM-DD`):",
    "invalid_date": "Invalid date format.\nPlease use `YYYY-MM-DD`.",
    "invalid_range": "Invalid date range.\nEnd date cannot be before start date.",
    "ask_type": "Which transaction type do you want to search?",
    "ask_categories": "Enter the categories you want to include, separated by a comma (e.g., Food, Drink).\n\nOr press Skip to include all categories.",
    "ask_keywords": "Enter keywords to search for in the description, separated by a comma (e.g., coffee, lunch).\n\nOr press Skip to not filter by keywords.",
    "ask_logic": "Should the description contain ALL of these keywords (AND) or ANY of them (OR)?",
    "searching": "ðŸ”Ž searching...",
    "no_results": "No transactions found matching your criteria.",
    "one_result": "Found 1 matching transaction:",
    "many_results": "Found {count} matching transactions.\nSelect one to manage:"
  },
  "categories": {
    "Food": "ðŸ’¸ Food",
    "Drink": "â˜•ï¸ Drink",
    "Transport": "ðŸš— Transport",
    "Shopping": "ðŸ›ï¸ Shopping",
    "Bills": "ðŸ§¾ Bills",
    "Utilities": "ðŸ’¡ Utilities",
    "Entertainment": "ðŸŽ¬ Entertainment",
    "Personal Care": "ðŸ§´ Personal Care",
    "Work": "ðŸ’¼ Work",
    "Alcohol": "ðŸº Alcohol",
    "For Others": "ðŸ‘¥ For Others",
    "Health": "ðŸ©º Health",
    "Investment": "ðŸ“ˆ Investment",
    "Forgot": "ðŸ¤” Forgot",
    "Rent": "ðŸ  Rent",
    "Subscriptions": "ðŸ”„ Subscriptions",
    "Insurance": "ðŸ›¡ï¸ Insurance",
    "Education": "ðŸŽ“ Education",
    "Gifts": "ðŸŽ Gifts",
    "Donations": "â¤ï¸ Donations",
    "Family": "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦ Family",
    "Travel": "âœˆï¸ Travel",
    "Pets": "ðŸ¾ Pets",
    "Electronics": "ðŸ“± Electronics",
    "Car Maintenance": "ðŸ› ï¸ Car Maintenance",
    "Salary": "ðŸ’° Salary",
    "Bonus": "ðŸŽ‰ Bonus",
    "Freelance": "ðŸ’» Freelance",
    "Commission": "ðŸ¤ Commission",
    "Allowance": "ðŸ§‘â€ðŸŽ“ Allowance",
    "Gift": "ðŸŽ Gift",
    "Investment Income": "ðŸ“ˆ Investment Income",
    "Other Income": " miscellaneous Income"
  }
}

============================================================

==================== FILE: telegram_bot/locales/km.json ====================
{
  "common": {
    "welcome": "ážŸáž¼áž˜ážŸáŸ’ážœáž¶áž‚áž˜áž“áŸ, {name}!",
    "quick_check_header": "ðŸ” áž“áŸáŸ‡áž‡áž¶ážŸáŸáž…áž€áŸ’ážáž¸ážŸáž„áŸ’ážáŸáž”ážšáž”ážŸáŸ‹áž¢áŸ’áž“áž€áŸ–",
    "cancel": "áž”áŸ’ážšážáž·áž”ážáŸ’ážáž·áž€áž¶ážšážáŸ’ážšáž¼ážœáž”áž¶áž“áž”áŸ„áŸ‡áž”áž„áŸ‹áŸ”",
    "cancel_onboarding": "áž€áž¶ážšážŠáŸ†áž¡áž¾áž„áž‚ážŽáž“áž¸ážáŸ’ážšáž¼ážœáž”áž¶áž“áž”áŸ„áŸ‡áž”áž„áŸ‹áŸ”\n    ážœáž¶áž™ /start ážŠáž¾áž˜áŸ’áž”áž¸áž–áŸ’áž™áž¶áž™áž¶áž˜áž˜áŸ’ážáž„áž‘áŸ€ážáž“áŸ…áž–áŸáž›áž¢áŸ’áž“áž€ážšáž½áž…ážšáž¶áž›áŸ‹áŸ”",
    "error_generic": "áž˜áž¶áž“áž”áž‰áŸ’áž áž¶áž€áž¾ážáž¡áž¾áž„áŸ”\n    ážŸáž¼áž˜â€‹áž–áŸ’áž™áž¶áž™áž¶áž˜â€‹áž˜áŸ’ážáž„â€‹áž‘áŸ€ážâ€‹áž“áŸ…â€‹áž–áŸáž›â€‹áž€áŸ’ážšáŸ„áž™áŸ”",
    "expense_word": "áž…áŸ†ážŽáž¶áž™",
    "income_word": "áž…áŸ†ážŽáž¼áž›"
  },
  "summary": {
    "status_header": "\n\n--- ážŸáŸ’ážáž¶áž“áž—áž¶áž–áž”áž…áŸ’áž…áž»áž”áŸ’áž”áž“áŸ’áž“ážšáž”ážŸáŸ‹áž¢áŸ’áž“áž€ ---",
    "balances": "<b>ážŸáž˜ážáž»áž›áŸ’áž™áŸ–</b>",
    "debts": "<b>áž”áŸ†ážŽáž»áž›áŸ–</b>",
    "you_are_owed": "âž¡ï¸ <b>áž‚áŸáž‡áŸ†áž–áž¶áž€áŸ‹áž¢áŸ’áž“áž€áŸ–</b>",
    "you_owe": "â¬…ï¸ <b>áž¢áŸ’áž“áž€áž‡áŸ†áž–áž¶áž€áŸ‹áž‚áŸáŸ–</b>",
    "activity_header": "<b>ážŸáž€áž˜áŸ’áž˜áž—áž¶áž–áž”áŸ’ážšážáž·áž”ážáŸ’ážáž·áž€áž¶ážš (áž˜áž·áž“ážšáž½áž˜áž”áž‰áŸ’áž…áž¼áž›áž”áŸ’ážšáž¶áž€áŸ‹áž€áž˜áŸ’áž…áž¸)áŸ–</b>",
    "today": "<b>ážáŸ’áž„áŸƒáž“áŸáŸ‡áŸ–</b>",
    "this_week": "<b>ážŸáž”áŸ’ážáž¶áž áŸáž“áŸáŸ‡áŸ–</b>",
    "last_week": "<b>ážŸáž”áŸ’ážáž¶áž áŸáž˜áž»áž“áŸ–</b>",
    "this_month": "<b>ážáŸ‚áž“áŸáŸ‡áŸ–</b>",
    "in": "    â¬†ï¸ áž”áŸ’ážšáž¶áž€áŸ‹áž…áž¼áž›áŸ– {value}",
    "out": "    â¬‡ï¸ áž”áŸ’ážšáž¶áž€áŸ‹áž…áŸáž‰áŸ– {value}",
    "net": "    <b>áž”áŸ’ážšáž¶áž€áŸ‹áž…áŸ†ážŽáŸáž‰/ážáž¶ážáŸ– ${value:,.2f}</b> {emoji}"
  },
  "keyboards": {
    "add_expense": "ðŸ’¸ áž”áž“áŸ’ážáŸ‚áž˜áž…áŸ†ážŽáž¶áž™",
    "add_income": "ðŸ’° áž”áž“áŸ’ážáŸ‚áž˜áž…áŸ†ážŽáž¼áž›",
    "forgot_log": "ðŸ¤” áž—áŸ’áž›áŸáž…áž€ážáŸ‹ážáŸ’ážšáž¶?",
    "quick_check": "ðŸ” áž–áž·áž“áž·ážáŸ’áž™ážšáž áŸážŸ",
    "set_reminder": "ðŸ”” áž€áŸ†ážŽážáŸ‹áž€áž¶ážšážšáŸ†áž›áž¹áž€",
    "iou_menu": "ðŸ¤ áž”áŸ†ážŽáž»áž›",
    "history": "ðŸ“– áž”áŸ’ážšážœážáŸ’ážáž·",
    "search": "ðŸ”Ž ážŸáŸ’ážœáŸ‚áž„ážšáž€ & ážœáž·áž—áž¶áž‚",
    "report": "ðŸ“ˆ ážšáž”áž¶áž™áž€áž¶ážšážŽáŸ",
    "habits": "ðŸ§  áž‘áž˜áŸ’áž›áž¶áž”áŸ‹",
    "get_live_rate": "ðŸ“Š áž¢ážáŸ’ážšáž¶áž”áŸ’ážáž¼ážšáž”áŸ’ážšáž¶áž€áŸ‹",
    "settings": "âš™ï¸ áž€áž¶ážšáž€áŸ†ážŽážáŸ‹",
    "other": "ðŸ“ áž•áŸ’ážŸáŸáž„áŸ—",
    "back_to_main": "â€¹ ážáŸ’ážšáž¡áž”áŸ‹áž‘áŸ…áž˜áŸ",
    "download_report_csv": "ðŸ“„ áž‘áž¶áž‰áž™áž€ CSV ážšáž”áž¶áž™áž€áž¶ážšážŽáŸ",
    "download_open_debts_csv": "ðŸ“„ áž‘áž¶áž‰áž™áž€ CSV áž”áŸ†ážŽáž»áž›áž˜áž·áž“áž‘áž¶áž“áŸ‹áž‘áž¼áž‘áž¶ážáŸ‹",
    "back_to_iou": "â€¹ ážáŸ’ážšáž¡áž”áŸ‹áž‘áŸ…áž”áŸ†ážŽáž»áž›",
    "search_manage": "âœï¸ ážŸáŸ’ážœáŸ‚áž„ážšáž€ & áž‚áŸ’ážšáž”áŸ‹áž‚áŸ’ážšáž„",
    "search_sum": "ðŸ“ˆ áž‚ážŽáž“áž¶áž•áž›ážŸážšáž»áž”",
    "tomorrow": "ážáŸ’áž„áŸƒážŸáŸ’áž¢áŸ‚áž€",
    "in_3_days": "3 ážáŸ’áž„áŸƒáž‘áŸ€áž",
    "in_1_week": "1 ážŸáž”áŸ’ážáž¶áž áŸáž‘áŸ€áž",
    "custom_date": "ðŸ—“ï¸ áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘áž•áŸ’áž‘áž¶áž›áŸ‹ážáŸ’áž›áž½áž“",
    "cancel": "âŒ áž”áŸ„áŸ‡áž”áž„áŸ‹",
    "yesterday": "áž˜áŸ’ážŸáž·áž›áž˜áž·áž‰",
    "days_ago": "{days} ážáŸ’áž„áŸƒáž˜áž»áž“",
    "today": "ážáŸ’áž„áŸƒáž“áŸáŸ‡",
    "expense": "ðŸ’¸ áž…áŸ†ážŽáž¶áž™",
    "income": "ðŸ’° áž…áŸ†ážŽáž¼áž›",
    "period_today": "ðŸ—“ï¸ ážáŸ’áž„áŸƒáž“áŸáŸ‡",
    "period_this_week": "ðŸ—“ï¸ ážŸáž”áŸ’ážáž¶áž áŸáž“áŸáŸ‡",
    "period_last_week": "ðŸ—“ï¸ ážŸáž”áŸ’ážáž¶áž áŸáž˜áž»áž“",
    "period_this_month": "ðŸ—“ï¸ ážáŸ‚áž“áŸáŸ‡",
    "period_last_month": "ðŸ—“ï¸ ážáŸ‚áž˜áž»áž“",
    "period_custom": "ðŸ—“ï¸ áž€áŸ†ážŽážáŸ‹áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘",
    "period_all_time": "â™¾ï¸ áž‚áŸ’ážšáž”áŸ‹áž–áŸáž›",
    "back": "â€¹ ážáŸ’ážšáž¡áž”áŸ‹",
    "all_types": "ðŸŒ áž‚áŸ’ážšáž”áŸ‹áž”áŸ’ážšáž—áŸáž‘",
    "skip": "â© áž†áŸ’áž›áž„áž€áž¶ážáŸ‹",
    "search_logic_and": "ážáŸ’ážšáž¼ážœáž˜áž¶áž“áž‘áž¶áŸ†áž„áž¢ážŸáŸ‹ (AND)",
    "search_logic_or": "áž˜áž¶áž“ážŽáž¶áž˜áž½áž™ (OR)",
    "settings_update_balances": "ðŸ’¸ áž’áŸ’ážœáž¾áž”áž…áŸ’áž…áž»áž”áŸ’áž”áž“áŸ’áž“áž—áž¶áž–ážŸáž˜ážáž»áž›áŸ’áž™ážŠáŸ†áž”áž¼áž„",
    "settings_manage_categories": "ðŸ·ï¸ áž‚áŸ’ážšáž”áŸ‹áž‚áŸ’ážšáž„áž”áŸ’ážšáž—áŸáž‘",
    "settings_update_rate": "ðŸ“ˆ áž’áŸ’ážœáž¾áž”áž…áŸ’áž…áž»áž”áŸ’áž”áž“áŸ’áž“áž—áž¶áž–áž¢ážáŸ’ážšáž¶ážáŸážš",
    "settings_switch_to_dual": "ðŸ”„ áž”áŸ’ážáž¼ážšáž‘áŸ… ážšáž”áŸ€áž”ážšáž¼áž”áž·áž™áž”áŸážŽáŸ’ážŽáž–áž¸ážš",
    "settings_change_language": "ðŸŒ áž”áŸ’ážáž¼ážšáž—áž¶ážŸáž¶",
    "usd_account": "ðŸ’µ áž‚ážŽáž“áž¸ USD",
    "khr_account": "áŸ› áž‚ážŽáž“áž¸ KHR",
    "update_balance": "áž’áŸ’ážœáž¾áž”áž…áŸ’áž…áž»áž”áŸ’áž”áž“áŸ’áž“áž—áž¶áž–ážŸáž˜ážáž»áž›áŸ’áž™ {currency}",
    "back_to_settings": "â€¹ ážáŸ’ážšáž¡áž”áŸ‹áž‘áŸ…áž€áž¶ážšáž€áŸ†ážŽážáŸ‹",
    "switch_dual_confirm": "âœ… áž”áž¶áž‘/áž…áž¶ážŸ, áž”áŸ’ážáž¼ážš",
    "switch_dual_cancel": "â€¹ áž‘áŸ, ážáŸ’ážšáž¡áž”áŸ‹",
    "category_add": "âž• áž”áž“áŸ’ážáŸ‚áž˜áž”áŸ’ážšáž—áŸáž‘",
    "category_remove": "âž– ážŠáž€áž”áŸ’ážšáž—áŸáž‘",
    "iou_lent": "âž¡ï¸ ážáŸ’áž‰áž»áŸ†áž¢áŸ„áž™áž‚áŸážáŸ’áž…áž¸",
    "iou_borrowed": "â¬…ï¸ ážáŸ’áž‰áž»áŸ†ážáŸ’áž…áž¸áž‚áŸ",
    "iou_view_open": "ðŸ“– áž˜áž¾áž›áž”áŸ†ážŽáž»áž›áž˜áž·áž“áž‘áž¶áž“áŸ‹áž‘áž¼áž‘áž¶ážáŸ‹",
    "iou_view_settled": "âœ… áž˜áž¾áž›áž”áŸ†ážŽáž»áž›áž”áž¶áž“áž‘áž¼áž‘áž¶ážáŸ‹",
    "iou_analysis": "ðŸ”¬ ážœáž·áž—áž¶áž‚áž”áŸ†ážŽáž»áž›",
    "iou_person_lent": "áž‚áŸáž‡áŸ†áž–áž¶áž€áŸ‹ {person}: {totals}",
    "iou_person_borrowed": "áž¢áŸ’áž“áž€áž‡áŸ†áž–áž¶áž€áŸ‹ {person}: {totals}",
    "iou_record_repayment": "ðŸ’° áž€ážáŸ‹ážáŸ’ážšáž¶áž€áž¶ážšážŸáž„áž”áŸ’ážšáž¶áž€áŸ‹",
    "iou_manage_individual": "âœï¸ áž‚áŸ’ážšáž”áŸ‹áž‚áŸ’ážšáž„áž”áŸ†ážŽáž»áž›áž“áž¸áž˜áž½áž™áŸ—",
    "back_to_summary": "â€¹ ážáŸ’ážšáž¡áž”áŸ‹áž‘áŸ…ážŸáŸáž…áž€áŸ’ážáž¸ážŸáž„áŸ’ážáŸáž”",
    "back_to_ledger": "â€¹ ážáŸ’ážšáž¡áž”áŸ‹áž‘áŸ…áž”áž‰áŸ’áž‡áž¸",
    "back_to_list": "â€¹ ážáŸ’ážšáž¡áž”áŸ‹áž‘áŸ…áž”áž‰áŸ’áž‡áž¸",
    "iou_edit_cancel": "âœï¸ áž€áŸ‚ážŸáž˜áŸ’ážšáž½áž›/áž”áŸ„áŸ‡áž”áž„áŸ‹",
    "iou_edit_person": "âœï¸ áž€áŸ‚ážŸáž˜áŸ’ážšáž½áž›áž”áž»áž‚áŸ’áž‚áž›",
    "iou_edit_purpose": "âœï¸ áž€áŸ‚ážŸáž˜áŸ’ážšáž½áž›áž‚áŸ„áž›áž”áŸ†ážŽáž„",
    "iou_cancel_debt": "âŒ áž”áŸ„áŸ‡áž”áž„áŸ‹áž”áŸ†ážŽáž»áž›",
    "iou_cancel_confirm": "âœ… áž”áž¶áž‘/áž…áž¶ážŸ, áž”áŸ„áŸ‡áž”áž„áŸ‹",
    "iou_cancel_go_back": "â€¹ áž‘áŸ, ážáŸ’ážšáž¡áž”áŸ‹",
    "add_remark": "âœ… áž”áž“áŸ’ážáŸ‚áž˜áž…áŸ†ážŽáž¶áŸ†",
    "edit": "âœï¸ áž€áŸ‚ážŸáž˜áŸ’ážšáž½áž›",
    "delete": "ðŸ—‘ï¸ áž›áž»áž”",
    "back_to_history": "â€¹ ážáŸ’ážšáž¡áž”áŸ‹áž‘áŸ…áž”áŸ’ážšážœážáŸ’ážáž·",
    "edit_amount": "ðŸ’° áž…áŸ†áž“áž½áž“áž‘áž¹áž€áž”áŸ’ážšáž¶áž€áŸ‹",
    "edit_category": "ðŸ·ï¸ áž”áŸ’ážšáž—áŸáž‘",
    "edit_description": "ðŸ“ áž€áž¶ážšáž–áž·áž–ážŽáŸŒáž“áž¶",
    "edit_date": "ðŸ—“ï¸ áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘",
    "edit_currency": "ðŸª™ ážšáž¼áž”áž·áž™áž”áŸážŽáŸ’ážŽ",
    "edit_cancel": "â€¹ áž”áŸ„áŸ‡áž”áž„áŸ‹áž€áž¶ážšáž€áŸ‚ážŸáž˜áŸ’ážšáž½áž›",
    "delete_confirm": "âœ… áž”áž¶áž‘/áž…áž¶ážŸ, áž›áž»áž”",
    "delete_cancel": "âŒ áž‘áŸ, áž”áŸ„áŸ‡áž”áž„áŸ‹"
  },
  "onboarding": {
    "welcome": "ážŸáž¼áž˜ážŸáŸ’ážœáž¶áž‚áž˜áž“áŸáž˜áž€áž€áž¶áž“áŸ‹ FinanceBot!\n    ážáŸ„áŸ‡áž˜áž€ážŠáŸ†áž¡áž¾áž„áž‚ážŽáž“áž¸ážšáž”ážŸáŸ‹áž¢áŸ’áž“áž€áŸ”",
    "ask_mode": "ážáž¾áž¢áŸ’áž“áž€áž…áž„áŸ‹ážáž¶áž˜ážŠáž¶áž“ážšáž¼áž”áž·áž™áž”áŸážŽáŸ’ážŽáž˜áž½áž™ áž¬ ážšáž¼áž”áž·áž™áž”áŸážŽáŸ’ážŽáž–áž¸ážš (USD & KHR)?\n\n(ážŸáž¼áž˜áž†áŸ’áž›áž¾áž™ážáž”áž‡áž¶áž˜áž½áž™: `1` áž¬ `2`)",
    "invalid_mode": "áž€áž¶ážšáž‡áŸ’ážšáž¾ážŸážšáž¾ážŸáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ”\n    ážŸáž¼áž˜áž†áŸ’áž›áž¾áž™ážáž”áž‡áž¶áž˜áž½áž™ `1` áž¬ `2` áŸ”",
    "ask_language": "áž¢áŸ’áž“áž€áž”áž¶áž“áž‡áŸ’ážšáž¾ážŸážšáž¾ážŸ 2 ážšáž¼áž”áž·áž™áž”áŸážŽáŸ’ážŽáŸ”\n    ážáž¾áž¢áŸ’áž“áž€áž…áž„áŸ‹áž”áŸ’ážšáž¾áž—áž¶ážŸáž¶áž¢áŸ’ážœáž¸?\n\n(ážŸáž¼áž˜áž†áŸ’áž›áž¾áž™ážáž”áž‡áž¶áž˜áž½áž™: `en` áž¬ `km`)",
    "invalid_language": "áž€áž¶ážšáž‡áŸ’ážšáž¾ážŸážšáž¾ážŸáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ”\n    ážŸáž¼áž˜áž†áŸ’áž›áž¾áž™ážáž”áž‡áž¶áž˜áž½áž™ `en` áž¬ `km` áŸ”",
    "ask_name_en": "ážáž¾áž¢áŸ’áž“áž€ážˆáŸ’áž˜áŸ„áŸ‡áž¢áŸ’ážœáž¸ (áž‡áž¶áž—áž¶ážŸáž¶áž¢áž„áŸ‹áž‚áŸ’áž›áŸážŸ)?\n\n(áž§áž‘áž¶áž ážšážŽáŸ: John Doe)",
    "ask_name_km": "ážáž¾áž¢áŸ’áž“áž€ážˆáŸ’áž˜áŸ„áŸ‡áž¢áŸ’ážœáž¸ (áž‡áž¶áž—áž¶ážŸáž¶ážáŸ’áž˜áŸ‚ážš)?\n\n(áž§áž‘áž¶áž ážšážŽáŸ: áž…áž“ ážŠáž¼)",
    "ask_primary_currency": "áž¢áŸ’áž“áž€áž”áž¶áž“áž‡áŸ’ážšáž¾ážŸážšáž¾ážŸ 1 ážšáž¼áž”áž·áž™áž”áŸážŽáŸ’ážŽáŸ”\n    ážáž¾áž¢áŸ’áž“áž€áž“áž¹áž„áž”áŸ’ážšáž¾ážšáž¼áž”áž·áž™áž”áŸážŽáŸ’ážŽáž˜áž½áž™ážŽáž¶?\n\n(ážŸáž¼áž˜áž†áŸ’áž›áž¾áž™ážáž”áž‡áž¶áž˜áž½áž™áž¢áž€áŸ’ážŸážšáž€áž¶ážáŸ‹, áž§.: `USD`, `KHR`, `CNY`)",
    "ask_usd_balance": "áž›áŸ’áž¢ážŽáž¶ážŸáŸ‹, {name}áŸ”\n    ážáŸ„áŸ‡áž€áŸ†ážŽážáŸ‹ážŸáž˜ážáž»áž›áŸ’áž™áž…áž¶áž”áŸ‹áž•áŸ’ážáž¾áž˜ážšáž”ážŸáŸ‹áž¢áŸ’áž“áž€áŸ”\n\nážáž¾áž¢áŸ’áž“áž€áž˜áž¶áž“ážŸáž˜ážáž»áž›áŸ’áž™ **USD** áž”áž…áŸ’áž…áž»áž”áŸ’áž”áž“áŸ’áž“áž”áŸ‰áž»áž“áŸ’áž˜áž¶áž“?\n\n(ážŸáž¼áž˜áž†áŸ’áž›áž¾áž™ážáž”áž‡áž¶áž›áŸáž, áž§.: `100.50`)",
    "ask_khr_balance": "áž™áž›áŸ‹áž áž¾áž™áŸ”\n    áž¥áž¡áž¼ážœáž“áŸáŸ‡ ážáž¾áž¢áŸ’áž“áž€áž˜áž¶áž“ážŸáž˜ážáž»áž›áŸ’áž™ **KHR** áž”áž…áŸ’áž…áž»áž”áŸ’áž”áž“áŸ’áž“áž”áŸ‰áž»áž“áŸ’áž˜áž¶áž“?\n\n(ážŸáž¼áž˜áž†áŸ’áž›áž¾áž™ážáž”áž‡áž¶áž›áŸáž, áž§.: `50000`)",
    "ask_single_balance": "áž›áŸ’áž¢ážŽáž¶ážŸáŸ‹, {name}áŸ”\n    ážáŸ„áŸ‡áž€áŸ†ážŽážáŸ‹ážŸáž˜ážáž»áž›áŸ’áž™áž…áž¶áž”áŸ‹áž•áŸ’ážáž¾áž˜ážšáž”ážŸáŸ‹áž¢áŸ’áž“áž€áŸ”\n\nážáž¾áž¢áŸ’áž“áž€áž˜áž¶áž“ážŸáž˜ážáž»áž›áŸ’áž™ **{currency}** áž”áž…áŸ’áž…áž»áž”áŸ’áž”áž“áŸ’áž“áž”áŸ‰áž»áž“áŸ’áž˜áž¶áž“?\n\n(ážŸáž¼áž˜áž†áŸ’áž›áž¾áž™ážáž”áž‡áž¶áž›áŸáž, áž§.: `150.50`)",
    "invalid_amount": "áž“áŸ„áŸ‡áž˜áž·áž“áž˜áŸ‚áž“áž‡áž¶áž›áŸážážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáž‘áŸáŸ”\n    ážŸáž¼áž˜â€‹áž–áŸ’áž™áž¶áž™áž¶áž˜â€‹áž˜áŸ’ážáž„â€‹áž‘áŸ€áž (áž§.: `100.50`)áŸ”",
    "setup_complete": "ðŸŽ‰ áž€áž¶ážšážŠáŸ†áž¡áž¾áž„áž”áž¶áž“áž”áž‰áŸ’áž…áž”áŸ‹!\n\náž¢áŸ’áž“áž€áž”áž¶áž“ážáŸ’ážšáŸ€áž˜ážšáž½áž…ážšáž¶áž›áŸ‹áž áž¾áž™ã€‚\náž“áŸáŸ‡áž‚ážºáž‡áž¶áž˜áŸ‰ážºáž“áž»áž™áž˜áŸã€‚"
  },
  "settings": {
    "menu_header": "<b>âš™ï¸ áž€áž¶ážšáž€áŸ†ážŽážáŸ‹</b>\n\náž“áŸ…áž‘áž¸áž“áŸáŸ‡ áž¢áŸ’áž“áž€áž¢áž¶áž…áž‚áŸ’ážšáž”áŸ‹áž‚áŸ’ážšáž„áž…áŸ†ážŽáž¼áž›áž…áž·ážáŸ’áž áž“áž·áž„áž‘áž·áž“áŸ’áž“áŸáž™ážŠáŸ†áž”áž¼áž„ážšáž”ážŸáŸ‹áž¢áŸ’áž“áž€áŸ”\n\n<b>ážšáž”áŸ€áž”ážšáž¼áž”áž·áž™áž”áŸážŽáŸ’ážŽáŸ–</b> {mode}\n\n<b>ážŸáž˜ážáž»áž›áŸ’áž™ážŠáŸ†áž”áž¼áž„áŸ–</b>\n{balance_text}\n\n<b>áž¢ážáŸ’ážšáž¶áž”áŸ’ážáž¼ážšáž”áŸ’ážšáž¶áž€áŸ‹áŸ–</b> {rate_text}\n",
    "ask_balance_account": "ážáž¾ážŸáž˜ážáž»áž›áŸ’áž™ážŠáŸ†áž”áž¼áž„áž˜áž½áž™ážŽáž¶ážŠáŸ‚áž›áž¢áŸ’áž“áž€áž…áž„áŸ‹áž€áŸ†ážŽážáŸ‹/áž’áŸ’ážœáž¾áž”áž…áŸ’áž…áž»áž”áŸ’áž”áž“áŸ’áž“áž—áž¶áž–?",
    "ask_balance_amount": "áž‚ážŽáž“áž¸áŸ– <b>{currency}</b>\n\nážáž¾ážŸáž˜ážáž»áž›áŸ’áž™ážŠáŸ†áž”áž¼áž„ážáŸ’áž˜áž¸áž‚ážºáž‡áž¶áž¢áŸ’ážœáž¸?\n(ážœáž¶áž“áž¹áž„áž˜áž·áž“áž”áž„áŸ’áž€áž¾ážáž”áŸ’ážšážáž·áž”ážáŸ’ážáž·áž€áž¶ážšáž‘áŸ)áŸ”",
    "balance_set_success": "âœ… ážŸáž˜ážáž»áž›áŸ’áž™ážŠáŸ†áž”áž¼áž„ážŸáž˜áŸ’ážšáž¶áž”áŸ‹ {currency} áž”áž¶áž“áž’áŸ’ážœáž¾áž”áž…áŸ’áž…áž»áž”áŸ’áž”áž“áŸ’áž“áž—áž¶áž–áž‘áŸ… {amount:,.2f}áŸ”",
    "ask_rate": "ážŸáž¼áž˜áž”áž‰áŸ’áž…áž¼áž›áž¢ážáŸ’ážšáž¶áž”áŸ’ážáž¼ážšáž”áŸ’ážšáž¶áž€áŸ‹ **ážáŸážš** ážáŸ’áž˜áž¸ážšáž”ážŸáŸ‹áž¢áŸ’áž“áž€ážŸáž˜áŸ’ážšáž¶áž”áŸ‹ 1 USD áž‘áŸ… KHR (áž§. `4100`)áŸ”\n\nážœáž¶áž€áŸáž“áž¹áž„áž€áŸ†ážŽážáŸ‹áž…áŸ†ážŽáž¼áž›áž…áž·ážáŸ’ážážšáž”ážŸáŸ‹áž¢áŸ’áž“áž€áž‘áŸ…áž‡áž¶ 'ážáŸážš' áž•áž„ážŠáŸ‚ážšáŸ”",
    "rate_set_success": "âœ… áž¢ážáŸ’ážšáž¶áž”áŸ’ážáž¼ážšáž”áŸ’ážšáž¶áž€áŸ‹ážáŸážšážšáž”ážŸáŸ‹áž¢áŸ’áž“áž€áž¥áž¡áž¼ážœáž“áŸáŸ‡ážáŸ’ážšáž¼ážœáž”áž¶áž“áž€áŸ†ážŽážáŸ‹áž‘áŸ… {rate}áŸ”",
    "invalid_rate": "áž›áŸážáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ”\nážŸáž¼áž˜áž”áž‰áŸ’áž…áž¼áž›áž¢ážáŸ’ážšáž¶ážŠáŸ‚áž›ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ”",
    "categories_header": "<b>ðŸ·ï¸ áž‚áŸ’ážšáž”áŸ‹áž‚áŸ’ážšáž„áž”áŸ’ážšáž—áŸáž‘</b>\n\n<b>áž…áŸ†ážŽáž¶áž™áŸ–</b>\n  {expense_cats}\n\n<b>áž…áŸ†ážŽáž¼áž›áŸ–</b>\n  {income_cats}\n",
    "category_ask_add": "ážáž¾áž¢áŸ’áž“áž€áž…áž„áŸ‹áž”áž“áŸ’ážáŸ‚áž˜áž”áŸ’ážšáž—áŸáž‘áž¢áŸ’ážœáž¸?",
    "category_ask_remove": "ážáž¾áž¢áŸ’áž“áž€áž…áž„áŸ‹ážŠáž€áž”áŸ’ážšáž—áŸáž‘áž¢áŸ’ážœáž¸?",
    "category_ask_name": "ážŸáž¼áž˜ážœáž¶áž™ážˆáŸ’áž˜áŸ„áŸ‡áž”áŸ’ážšáž—áŸáž‘ **{cat_type}** ážáŸ’áž˜áž¸ážŠáž¾áž˜áŸ’áž”áž¸ {action}áŸ–",
    "category_add_success": "âœ… áž”áŸ’ážšáž—áŸáž‘ '{name}' áž”áž¶áž“áž”áž“áŸ’ážáŸ‚áž˜áž‘áŸ… {type}áŸ”",
    "category_remove_success": "âœ… áž”áŸ’ážšáž—áŸáž‘ '{name}' áž”áž¶áž“ážŠáž€áž…áŸáž‰áž–áž¸ {type}áŸ”",
    "switch_to_dual_confirm": "ážœáž¶áž“áž¹áž„áž”áŸ’ážáž¼ážšáž‚ážŽáž“áž¸ážšáž”ážŸáŸ‹áž¢áŸ’áž“áž€áž‘áŸ…áž‡áž¶ážšáž”áŸ€áž”ážšáž¼áž”áž·áž™áž”áŸážŽáŸ’ážŽáž–áž¸ážš (USD & KHR)áŸ”\n\n**áž…áŸ†ážŽáž¶áŸ†áŸ– áž¢áŸ’áž“áž€áž˜áž·áž“áž¢áž¶áž…áž”áŸ’ážáž¼ážšážœáž¶áž˜áž€ážœáž·áž‰áž”áž¶áž“áž‘áŸ**\n\nážáž¾áž¢áŸ’áž“áž€áž–áž·ážáž‡áž¶áž…áž„áŸ‹áž”áŸ’ážáž¼ážšáž˜áŸ‚áž“áž‘áŸ?",
    "ask_name_km_switch": "áž›áŸ’áž¢ážŽáž¶ážŸáŸ‹áŸ”\n    ážŸáž¼áž˜áž†áŸ’áž›áž¾áž™ážáž”áž‡áž¶áž˜áž½áž™ážˆáŸ’áž˜áŸ„áŸ‡ážšáž”ážŸáŸ‹áž¢áŸ’áž“áž€áž‡áž¶áž—áž¶ážŸáž¶ážáŸ’áž˜áŸ‚ážš (áž§. áž…áž“ ážŠáž¼)áŸ”",
    "switch_to_dual_success": "âœ… áž‡áŸ„áž‚áž‡áŸáž™!\n    áž‚ážŽáž“áž¸ážšáž”ážŸáŸ‹áž¢áŸ’áž“áž€áž¥áž¡áž¼ážœážŸáŸ’ážáž·ážáž€áŸ’áž“áž»áž„ážšáž”áŸ€áž”ážšáž¼áž”áž·áž™áž”áŸážŽáŸ’ážŽáž–áž¸ážš áž áž¾áž™áž—áž¶ážŸáž¶ážáŸ’ážšáž¼ážœáž”áž¶áž“áž€áŸ†ážŽážáŸ‹áž‘áŸ…áž‡áž¶ážáŸ’áž˜áŸ‚ážšáŸ”\n\náž¢áŸ’áž“áž€áž¢áž¶áž…áž”áŸ’ážáž¼ážšáž—áž¶ážŸáž¶áž“áŸ…áž€áŸ’áž“áž»áž„ âš™ï¸ áž€áž¶ážšáž€áŸ†ážŽážáŸ‹ áž–áŸáž›áž€áŸ’ážšáŸ„áž™áŸ”",
    "ask_new_language": "ážŸáž¼áž˜áž‡áŸ’ážšáž¾ážŸážšáž¾ážŸáž—áž¶ážŸáž¶ážŠáŸ‚áž›áž¢áŸ’áž“áž€áž–áŸáž‰áž…áž·ážáŸ’ážážáŸ’áž˜áž¸áŸ–",
    "ask_missing_name_km": "áž¢áŸ’áž“áž€áž€áŸ†áž–áž»áž„áž”áŸ’ážáž¼ážšáž‘áŸ…áž—áž¶ážŸáž¶ážáŸ’áž˜áŸ‚ážš áž”áŸ‰áž»áž“áŸ’ážáŸ‚ážˆáŸ’áž˜áŸ„áŸ‡ážáŸ’áž˜áŸ‚ážšážšáž”ážŸáŸ‹áž¢áŸ’áž“áž€áž˜áž·áž“ážáŸ’ážšáž¼ážœáž”áž¶áž“áž€áŸ†ážŽážáŸ‹áž‘áŸáŸ”\n\nážŸáž¼áž˜áž†áŸ’áž›áž¾áž™ážáž”áž‡áž¶áž˜áž½áž™ážˆáŸ’áž˜áŸ„áŸ‡ážšáž”ážŸáŸ‹áž¢áŸ’áž“áž€áž‡áž¶áž—áž¶ážŸáž¶ážáŸ’áž˜áŸ‚ážš (áž§. áž…áž“ ážŠáž¼)áŸ–",
    "ask_missing_name_en": "You are switching to English, but your English name is not set.\n\nPlease reply with your name in English (e.g., John Doe):",
    "language_switch_success": "âœ… áž—áž¶ážŸáž¶áž”áž¶áž“áž’áŸ’ážœáž¾áž”áž…áŸ’áž…áž»áž”áŸ’áž”áž“áŸ’áž“áž—áž¶áž–ážŠáŸ„áž™áž‡áŸ„áž‚áž‡áŸáž™!"
  },
  "tx": {
    "ask_amount": "{emoji} áž”áž‰áŸ’áž…áž¼áž›áž…áŸ†áž“áž½áž“áž‘áž¹áž€áž”áŸ’ážšáž¶áž€áŸ‹áŸ–",
    "ask_currency": "ážáž¾áž‡áž¶ážšáž¼áž”áž·áž™áž”áŸážŽáŸ’ážŽáž¢áŸ’ážœáž¸?",
    "ask_category": "áž…áŸ†áž“áž½áž“áŸ– <b>{amount_display}</b>\n\nážáž¾áž‡áž¶áž”áŸ’ážšáž—áŸáž‘áž¢áŸ’ážœáž¸?",
    "ask_category_curr": "ážšáž¼áž”áž·áž™áž”áŸážŽáŸ’ážŽáŸ– <b>{currency}</b>\n\nážáž¾áž‡áž¶áž”áŸ’ážšáž—áŸáž‘áž¢áŸ’ážœáž¸?",
    "ask_custom_category": "ážŸáž¼áž˜ážœáž¶áž™ážˆáŸ’áž˜áŸ„áŸ‡áž”áŸ’ážšáž—áŸáž‘áž•áŸ’áž‘áž¶áž›áŸ‹ážáŸ’áž›áž½áž“ážšáž”ážŸáŸ‹áž¢áŸ’áž“áž€áŸ–",
    "ask_remark": "áž”áŸ’ážšáž—áŸáž‘áŸ– <b>{category}</b>\n\nážáž¾áž¢áŸ’áž“áž€áž…áž„áŸ‹áž”áž“áŸ’ážáŸ‚áž˜áž…áŸ†ážŽáž¶áŸ†/áž–áž·áž–ážŽáŸŒáž“áž¶áž‘áŸ?",
    "ask_remark_prompt": "ážŸáž¼áž˜ážœáž¶áž™áž…áŸ†ážŽáž¶áŸ†ážšáž”ážŸáŸ‹áž¢áŸ’áž“áž€áŸ”",
    "success": "âœ… áž”áŸ’ážšážáž·áž”ážáŸ’ážáž·áž€áž¶ážšáž”áž¶áž“áž€ážáŸ‹ážáŸ’ážšáž¶ážŠáŸ„áž™áž‡áŸ„áž‚áž‡áŸáž™!",
    "fail": "âŒ áž˜áž·áž“áž¢áž¶áž…áž€ážáŸ‹ážáŸ’ážšáž¶áž”áŸ’ážšážáž·áž”ážáŸ’ážáž·áž€áž¶ážšáž”áž¶áž“áž‘áŸáŸ”",
    "invalid_amount": "ážŸáž¼áž˜áž”áž‰áŸ’áž…áž¼áž›áž›áŸážážŠáŸ‚áž›ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ”"
  },
  "forgot": {
    "ask_day": "ážáž¾áž¢áŸ’áž“áž€áž—áŸ’áž›áŸáž…áž€ážáŸ‹ážáŸ’ážšáž¶áž“áŸ…ážáŸ’áž„áŸƒážŽáž¶?",
    "ask_date": "ážŸáž¼áž˜áž”áž‰áŸ’áž…áž¼áž›áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘áž€áŸ’áž“áž»áž„áž‘áž˜áŸ’ážšáž„áŸ‹ `YYYY-MM-DD` áŸ”",
    "ask_type": "áž™áž›áŸ‹áž áž¾áž™áŸ”\nážáž¾ážœáž¶áž‡áž¶áž…áŸ†ážŽáž¶áž™ áž¬áž…áŸ†ážŽáž¼áž›?",
    "ask_amount": "áž”áŸ’ážšáž—áŸáž‘áŸ– <b>{type}</b>\n\náž”áž‰áŸ’áž…áž¼áž›áž…áŸ†áž“áž½áž“áž‘áž¹áž€áž”áŸ’ážšáž¶áž€áŸ‹áŸ–",
    "invalid_date": "áž‘áž˜áŸ’ážšáž„áŸ‹áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ”\nážŸáž¼áž˜áž”áŸ’ážšáž¾ `YYYY-MM-DD` áŸ”"
  },
  "utility": {
    "rate_header": "ðŸ“ˆ áž€áŸ†áž–áž»áž„áž”áŸ’ážšáž¾áž¢ážáŸ’ážšáž¶ **{source}** áŸ–\n<b>1 USD = {rate:,.0f} KHR</b>",
    "rate_fail": "âŒ áž˜áž·áž“áž¢áž¶áž…áž‘áž¶áž‰áž™áž€áž¢ážáŸ’ážšáž¶áž”áŸ’ážáž¼ážšáž”áŸ’ážšáž¶áž€áŸ‹áž”áž¶áž“áž‘áŸáŸ”",
    "remind_what": "ážáž¾áž¢áŸ’áž“áž€áž…áž„áŸ‹áž¢áŸ„áž™ážáŸ’áž‰áž»áŸ†ážšáŸ†áž›áž¹áž€áž¢áŸ†áž–áž¸áž¢áŸ’ážœáž¸?",
    "remind_when": "ážáž¾áž¢áŸ’áž“áž€áž…áž„áŸ‹áž¢áŸ„áž™ážáŸ’áž‰áž»áŸ†ážšáŸ†áž›áž¹áž€áž“áŸ…áž–áŸáž›ážŽáž¶?",
    "remind_ask_date": "ážŸáž¼áž˜áž”áž‰áŸ’áž…áž¼áž›áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘áž€áŸ’áž“áž»áž„áž‘áž˜áŸ’ážšáž„áŸ‹ `YYYY-MM-DD` áŸ”",
    "remind_ask_time": "áž™áž›áŸ‹áž áž¾áž™áŸ”\náž áž¾áž™áž“áŸ…áž˜áŸ‰áŸ„áž„áž”áŸ‰áž»áž“áŸ’áž˜áž¶áž“? (áž§. `09:00`, `17:30`)",
    "remind_success": "âœ… áž™áž›áŸ‹áž áž¾áž™! ážáŸ’áž‰áž»áŸ†áž“áž¹áž„ážšáŸ†áž›áž¹áž€áž¢áŸ’áž“áž€áž“áŸ… {date_time}áŸ”",
    "remind_invalid_date": "áž‘áž˜áŸ’ážšáž„áŸ‹áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ”\nážŸáž¼áž˜áž”áŸ’ážšáž¾ `YYYY-MM-DD` áŸ”",
    "remind_invalid_time": "áž‘áž˜áŸ’ážšáž„áŸ‹áž–áŸáž›ážœáŸáž›áž¶áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ”\nážŸáž¼áž˜áž”áŸ’ážšáž¾ `HH:MM` (24-áž˜áŸ‰áŸ„áž„)áŸ”"
  },
  "history": {
    "menu_header": "áž”áŸ’ážšážáž·áž”ážáŸ’ážáž·áž€áž¶ážšážáŸ’áž˜áž¸áŸ—áŸ–",
    "no_tx": "ážšáž€áž˜áž·áž“ážƒáž¾áž‰áž”áŸ’ážšážáž·áž”ážáŸ’ážáž·áž€áž¶ážšážáŸ’áž˜áž¸áŸ—áž‘áŸáŸ”",
    "tx_details": "<b>áž–áŸážáŸŒáž˜áž¶áž“áž›áž˜áŸ’áž¢áž·ážáž”áŸ’ážšážáž·áž”ážáŸ’ážáž·áž€áž¶ážšáŸ–</b>\n\n<b>áž”áŸ’ážšáž—áŸáž‘ (Type)áŸ–</b> {emoji}\n<b>áž…áŸ†áž“áž½áž“áž‘áž¹áž€áž”áŸ’ážšáž¶áž€áŸ‹áŸ–</b> {amount} {currency}\n<b>áž”áŸ’ážšáž—áŸáž‘ (Category)áŸ–</b> {category}\n<b>áž€áž¶ážšáž–áž·áž–ážŽáŸŒáž“áž¶áŸ–</b> {description}\n<b>áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘áŸ–</b> {date}\n\nážáž¾áž¢áŸ’áž“áž€áž…áž„áŸ‹áž’áŸ’ážœáž¾áž¢áŸ’ážœáž¸?",
    "tx_details_no_prompt": "<b>áž”áŸ’ážšáž—áŸáž‘ (Type)áŸ–</b> {emoji}\n<b>áž…áŸ†áž“áž½áž“áž‘áž¹áž€áž”áŸ’ážšáž¶áž€áŸ‹áŸ–</b> {amount} {currency}\n<b>áž”áŸ’ážšáž—áŸáž‘ (Category)áŸ–</b> {category}\n<b>áž€áž¶ážšáž–áž·áž–ážŽáŸŒáž“áž¶áŸ–</b> {description}\n<b>áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘áŸ–</b> {date}",
    "fetch_fail": "áž˜áž¶áž“áž”áž‰áŸ’áž áž¶áŸ– áž˜áž·áž“áž¢áž¶áž…áž‘áž¶áž‰áž™áž€áž–áŸážáŸŒáž˜áž¶áž“áž›áž˜áŸ’áž¢áž·ážáž¢áŸ†áž–áž¸áž”áŸ’ážšážáž·áž”ážáŸ’ážáž·áž€áž¶ážšáž”áž¶áž“áž‘áŸáŸ”",
    "delete_prompt": "âš ï¸ ážáž¾áž¢áŸ’áž“áž€áž”áŸ’ážšáž¶áž€ážŠáž¬áž‘áŸážáž¶áž…áž„áŸ‹áž›áž»áž”áž”áŸ’ážšážáž·áž”ážáŸ’ážáž·áž€áž¶ážšáž“áŸáŸ‡?",
    "delete_success": "ðŸ—‘ï¸ áž”áŸ’ážšážáž·áž”ážáŸ’ážáž·áž€áž¶ážšáž”áž¶áž“áž›áž»áž”ážŠáŸ„áž™áž‡áŸ„áž‚áž‡áŸáž™áŸ”",
    "delete_fail": "âŒ áž˜áž¶áž“áž”áž‰áŸ’áž áž¶áŸ– áž˜áž·áž“áž¢áž¶áž…áž›áž»áž”áž”áŸ’ážšážáž·áž”ážáŸ’ážáž·áž€áž¶ážšáž”áž¶áž“áž‘áŸáŸ”",
    "edit_ask_field": "ážáž¾áž¢áŸ’áž“áž€áž…áž„áŸ‹áž€áŸ‚ážŸáž˜áŸ’ážšáž½áž›áž•áŸ’áž“áŸ‚áž€áž˜áž½áž™ážŽáž¶?",
    "edit_fail": "âŒ áž˜áž¶áž“áž”áž‰áŸ’áž áž¶áŸ– ážšáž€áž˜áž·áž“ážƒáž¾áž‰áž”áŸ’ážšážáž·áž”ážáŸ’ážáž·áž€áž¶ážšáž‘áŸáŸ”",
    "edit_ask_new_date": "ážŸáž¼áž˜áž”áž‰áŸ’áž…áž¼áž›áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘ážáŸ’áž˜áž¸ (`YYYY-MM-DD`)áŸ–",
    "edit_ask_new_amount": "ážŸáž¼áž˜áž”áž‰áŸ’áž…áž¼áž›áž…áŸ†áž“áž½áž“áž‘áž¹áž€áž”áŸ’ážšáž¶áž€áŸ‹ážáŸ’áž˜áž¸áŸ–",
    "edit_ask_new_desc": "ážŸáž¼áž˜áž”áž‰áŸ’áž…áž¼áž›áž€áž¶ážšáž–áž·áž–ážŽáŸŒáž“áž¶ážáŸ’áž˜áž¸áŸ–",
    "edit_ask_new_category": "ážŸáž¼áž˜áž‡áŸ’ážšáž¾ážŸážšáž¾ážŸáž”áŸ’ážšáž—áŸáž‘ážáŸ’áž˜áž¸áŸ–",
    "edit_no_currency_single": "áž¢áŸ’áž“áž€ážŸáŸ’ážáž·ážáž“áŸ…áž€áŸ’áž“áž»áž„ážšáž”áŸ€áž”ážšáž¼áž”áž·áž™áž”áŸážŽáŸ’ážŽážáŸ‚áž˜áž½áž™ áž áž¾áž™áž˜áž·áž“áž¢áž¶áž…áž€áŸ‚ážŸáž˜áŸ’ážšáž½áž›ážšáž¼áž”áž·áž™áž”áŸážŽáŸ’ážŽáž”áž¶áž“áž‘áŸáŸ”",
    "edit_invalid_amount": "áž…áŸ†áž“áž½áž“áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ”\nážŸáž¼áž˜áž”áž‰áŸ’áž…áž¼áž›áž›áŸážážŠáŸ‚áž›ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ”",
    "edit_invalid_date": "áž‘áž˜áŸ’ážšáž„áŸ‹áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ”\nážŸáž¼áž˜áž”áŸ’ážšáž¾ `YYYY-MM-DD` áŸ”",
    "edit_success": "âœ… áž”áŸ’ážšážáž·áž”ážáŸ’ážáž·áž€áž¶ážšáž”áž¶áž“áž’áŸ’ážœáž¾áž”áž…áŸ’áž…áž»áž™áž”áŸ’áž”áž“áŸ’áž“áž—áž¶áž–ážŠáŸ„áž™áž‡áŸ„áž‚áž‡áŸáž™!",
    "edit_update_fail": "âŒ áž˜áž¶áž“áž”áž‰áŸ’áž áž¶áŸ– {error}"
  },
  "command": {
    "calculating": "ðŸ§® áž›áž‘áŸ’áž’áž•áž›áŸ– `{result}`",
    "calculator_fail": "áž˜áž·áž“áž¢áž¶áž…áž‚ážŽáž“áž¶áž”áž¶áž“áž‘áŸáŸ”\nážŸáž¼áž˜áž–áž·áž“áž·ážáŸ’áž™áž˜áž¾áž›áž€áž“áŸ’ážŸáŸ„áž˜áŸ”",
    "invalid_format_generic": "âš ï¸ áž‘áž˜áŸ’ážšáž„áŸ‹áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ”\n`!{command} <Category> [\"Description\"] <Amount>[khr] [MM-DD]`\n\n(áž‚áž“áŸ’áž›áž¹áŸ‡áŸ– áž”áŸ’ážšáž¾ážŸáž‰áŸ’áž‰áž¶ \"\" ážŸáž˜áŸ’ážšáž¶áž”áŸ‹áž€áž¶ážšáž–áž·áž–ážŽáŸŒáž“áž¶ážŠáŸ‚áž›áž˜áž¶áž“áž–áž¶áž€áŸ’áž™áž…áŸ’ážšáž¾áž“)",
    "invalid_format_debt": "âš ï¸ áž‘áž˜áŸ’ážšáž„áŸ‹áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ”\n`!{command} <Person> <Amount>[khr] [\"Purpose\"] [MM-DD]`\n\n(áž‚áž“áŸ’áž›áž¹áŸ‡áŸ– áž”áŸ’ážšáž¾ážŸáž‰áŸ’áž‰áž¶ \"\" ážŸáž˜áŸ’ážšáž¶áž”áŸ‹ážˆáŸ’áž˜áŸ„áŸ‡ áž¬áž‚áŸ„áž›áž”áŸ†ážŽáž„ážŠáŸ‚áž›áž˜áž¶áž“áž–áž¶áž€áŸ’áž™áž…áŸ’ážšáž¾áž“)",
    "invalid_format_missing_amount": "âš ï¸ áž‘áž˜áŸ’ážšáž„áŸ‹áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ”\nážáŸ’ážœáŸ‡áž…áŸ†áž“áž½áž“áž‘áž¹áž€áž”áŸ’ážšáž¶áž€áŸ‹áŸ”",
    "invalid_format_repayment": "âš ï¸ áž‘áž˜áŸ’ážšáž„áŸ‹áŸ– {example}",
    "repayment_error": "âŒ áž”áž‰áŸ’áž áž¶áŸ– {error}",
    "repayment_fail": "âš ï¸ áž‘áž˜áŸ’ážšáž„áŸ‹áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœážŸáž˜áŸ’ážšáž¶áž”áŸ‹áž–áž¶áž€áŸ’áž™áž”áž‰áŸ’áž‡áž¶ážŸáž„áž”áŸ’ážšáž¶áž€áŸ‹áŸ”",
    "error_generic": "áž˜áž¶áž“áž”áž‰áŸ’áž áž¶áž€áž¾ážáž¡áž¾áž„áž€áŸ†áž¡áž»áž„áž–áŸáž›ážŠáŸ†ážŽáž¾ážšáž€áž¶ážšáž–áž¶áž€áŸ’áž™áž”áž‰áŸ’áž‡áž¶ážšáž áŸážŸáŸ”",
    "error_parsing": "áž˜áž¶áž“áž”áž‰áŸ’áž áž¶áž€áž¾ážáž¡áž¾áž„áŸ”\nážŸáž¼áž˜áž–áž·áž“áž·ážáŸ’áž™áž˜áž¾áž›áž‘áž˜áŸ’ážšáž„áŸ‹áŸ”",
    "tx_fail": "âŒ áž˜áž·áž“áž¢áž¶áž…áž€ážáŸ‹ážáŸ’ážšáž¶áž”áŸ’ážšážáž·áž”ážáŸ’ážáž·áž€áž¶ážšáž”áž¶áž“áž‘áŸáŸ”",
    "debt_fail": "âŒ áž˜áž·áž“áž¢áž¶áž…ážšáž€áŸ’ážŸáž¶áž‘áž»áž€áž€áŸ†ážŽážáŸ‹ážáŸ’ážšáž¶áž”áž¶áž“áž‘áŸáŸ”",
    "unknown_prompt": "áž…áŸ†ážŽáž¶áž™ážáŸ’áž˜áž¸ '{description}' áž…áŸ†áž“áž½áž“ {amount_display}áŸ”\nážáž¾áž‡áž¶áž”áŸ’ážšáž—áŸáž‘áž¢áŸ’ážœáž¸?",
    "unknown_ask_custom": "ážŸáž¼áž˜ážœáž¶áž™ážˆáŸ’áž˜áŸ„áŸ‡áž”áŸ’ážšáž—áŸáž‘áž•áŸ’áž‘áž¶áž›áŸ‹ážáŸ’áž›áž½áž“ážšáž”ážŸáŸ‹áž¢áŸ’áž“áž€áŸ–",
    "unknown_fail": "ážáŸ’áž‰áž»áŸ†áž˜áž·áž“áž™áž›áŸ‹áž‘áŸáŸ”\nážŸáž¼áž˜áž•áŸ’ážáž›áŸ‹áž…áŸ†áž“áž½áž“áž‘áž¹áž€áž”áŸ’ážšáž¶áž€áŸ‹ (áž§. '!coffee 2.50')áŸ”",
    "parse_error": "âš ï¸ áž˜áž·áž“áž¢áž¶áž…áž‰áŸ‚áž€áž–áž¶áž€áŸ’áž™áž”áž‰áŸ’áž‡áž¶áž”áž¶áž“áž‘áŸáŸ”\nážŸáž¼áž˜áž–áž·áž“áž·ážáŸ’áž™áž˜áž¾áž›ážŸáž‰áŸ’áž‰áž¶ \"\" ážšáž”ážŸáŸ‹áž¢áŸ’áž“áž€áŸ– {error}",
    "success_header": "<b>âœ… áž”áž¶áž“áž€ážáŸ‹ážáŸ’ážšáž¶áŸ–</b>",
    "success_type": "  - <b>áž”áŸ’ážšáž—áŸáž‘áŸ–</b> {type}",
    "success_amount": "  - <b>áž…áŸ†áž“áž½áž“áž‘áž¹áž€áž”áŸ’ážšáž¶áž€áŸ‹áŸ–</b> {amount_display}",
    "success_category": "  - <b>áž”áŸ’ážšáž—áŸáž‘áŸ–</b> {category}",
    "success_description": "  - <b>áž€áž¶ážšáž–áž·áž–ážŽáŸŒáž“áž¶áŸ–</b> {description}",
    "success_person": "  - <b>áž”áž»áž‚áŸ’áž‚áž›áŸ–</b> {person}",
    "success_purpose": "  - <b>áž‚áŸ„áž›áž”áŸ†ážŽáž„áŸ–</b> {purpose}",
    "success_date": "  - <b>áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘áŸ–</b> {date}"
  },
  "iou": {
    "menu_header": "ðŸ¤ ážáŸ„áŸ‡áž‚áŸ’ážšáž”áŸ‹áž‚áŸ’ážšáž„áž”áŸ†ážŽáž»áž›ážšáž”ážŸáŸ‹áž¢áŸ’áž“áž€áŸ”",
    "view_header_open": "áž“áŸáŸ‡áž‚ážºáž‡áž¶ážŸáŸáž…áž€áŸ’ážáž¸ážŸáž„áŸ’ážáŸáž”áž“áŸƒáž”áŸ†ážŽáž»áž› **ážŠáŸ‚áž›áž˜áž·áž“áž‘áž¶áž“áŸ‹áž”áž¶áž“áž‘áž¼áž‘áž¶ážáŸ‹** ážšáž”ážŸáŸ‹áž¢áŸ’áž“áž€áŸ”\náž‡áŸ’ážšáž¾ážŸážšáž¾ážŸáž˜áž½áž™ážŠáž¾áž˜áŸ’áž”áž¸áž˜áž¾áž›áž–áŸážáŸŒáž˜áž¶áž“áž›áž˜áŸ’áž¢áž·ážáŸ–",
    "view_header_settled": "áž“áŸáŸ‡áž‚ážºáž‡áž¶ážŸáŸáž…áž€áŸ’ážáž¸ážŸáž„áŸ’ážáŸáž”áž“áŸƒáž”áŸ†ážŽáž»áž› **ážŠáŸ‚áž›áž”áž¶áž“áž‘áž¼áž‘áž¶ážáŸ‹/áž”áŸ„áŸ‡áž”áž„áŸ‹** ážšáž”ážŸáŸ‹áž¢áŸ’áž“áž€áŸ”\náž‡áŸ’ážšáž¾ážŸážšáž¾ážŸáž˜áž½áž™ážŠáž¾áž˜áŸ’áž”áž¸áž˜áž¾áž›áž–áŸážáŸŒáž˜áž¶áž“áž›áž˜áŸ’áž¢áž·ážáŸ–",
    "view_no_open": "áž¢áŸ’áž“áž€áž˜áž·áž“áž˜áž¶áž“áž”áŸ†ážŽáž»áž›ážŠáŸ‚áž›áž˜áž·áž“áž‘áž¶áž“áŸ‹áž”áž¶áž“áž‘áž¼áž‘áž¶ážáŸ‹áž‘áŸ!\nðŸ‘",
    "view_no_settled": "áž¢áŸ’áž“áž€áž˜áž·áž“áž˜áž¶áž“áž”áŸ†ážŽáž»áž›ážŠáŸ‚áž›áž”áž¶áž“áž‘áž¼áž‘áž¶ážáŸ‹áž‘áŸáŸ”",
    "person_header_open": "<b>áž”áŸ†ážŽáž»áž›áž˜áž·áž“áž‘áž¶áž“áŸ‹áž‘áž¼áž‘áž¶ážáŸ‹ážŸáž˜áŸ’ážšáž¶áž”áŸ‹ {person}</b> ({direction})\n\n",
    "person_header_settled": "<b>áž”áŸ†ážŽáž»áž›áž”áž¶áž“áž‘áž¼áž‘áž¶ážáŸ‹ážŸáž˜áŸ’ážšáž¶áž”áŸ‹ {person}</b> ({direction})\n\n",
    "person_direction_lent": "áž‡áŸ†áž–áž¶áž€áŸ‹áž¢áŸ’áž“áž€",
    "person_direction_borrowed": "áž¢áŸ’áž“áž€áž‡áŸ†áž–áž¶áž€áŸ‹",
    "person_direction_lent_past": "áž”áž¶áž“áž‡áŸ†áž–áž¶áž€áŸ‹áž¢áŸ’áž“áž€",
    "person_direction_borrowed_past": "áž¢áŸ’áž“áž€áž”áž¶áž“áž‡áŸ†áž–áž¶áž€áŸ‹",
    "person_fail": "âŒ ážšáž€áž˜áž·áž“ážƒáž¾áž‰áž”áŸ†ážŽáž»áž›áž˜áž·áž“áž‘áž¶áž“áŸ‹áž‘áž¼áž‘áž¶ážáŸ‹ážŸáž˜áŸ’ážšáž¶áž”áŸ‹ {person} áž‘áŸáŸ”",
    "person_fail_settled": "âŒ ážšáž€áž˜áž·áž“ážƒáž¾áž‰áž”áŸ†ážŽáž»áž›ážŠáŸ‚áž›áž”áž¶áž“áž‘áž¼áž‘áž¶ážáŸ‹ážŸáž˜áŸ’ážšáž¶áž”áŸ‹ {person} áž‘áŸáŸ”",
    "ledger_total_remaining": "<b>áž”áŸ†ážŽáž»áž›ážŸážšáž»áž”ážŠáŸ‚áž›áž“áŸ…ážŸáž›áŸ‹áŸ–</b>",
    "ledger_none": "  áž‚áŸ’áž˜áž¶áž“",
    "ledger_header": "<b>áž”áž‰áŸ’áž‡áž¸áž–áŸáž‰áž›áŸáž‰ (áž…áž¶ážŸáŸ‹áž‡áž¶áž„áž‚áŸáž˜áž»áž“)áŸ–</b>",
    "manage_header": "áž‡áŸ’ážšáž¾ážŸážšáž¾ážŸáž”áŸ†ážŽáž»áž›áž‡áž¶áž€áŸ‹áž›áž¶áž€áŸ‹ážŠáž¾áž˜áŸ’áž”áž¸áž‚áŸ’ážšáž”áŸ‹áž‚áŸ’ážšáž„áŸ–",
    "manage_fail": "âŒ ážšáž€áž˜áž·áž“ážƒáž¾áž‰áž”áŸ†ážŽáž»áž›ážŠáž¾áž˜áŸ’áž”áž¸áž‚áŸ’ážšáž”áŸ‹áž‚áŸ’ážšáž„áž‘áŸáŸ”",
    "detail_fail": "âŒ áž˜áž¶áž“áž”áž‰áŸ’áž áž¶áŸ– ážšáž€áž˜áž·áž“ážƒáž¾áž‰áž”áŸ†ážŽáž»áž›áž“áŸáŸ‡áž‘áŸáŸ”",
    "debt_details_header": "<b>áž–áŸážáŸŒáž˜áž¶áž“áž›áž˜áŸ’áž¢áž·ážáž”áŸ†ážŽáž»áž› (ážŸáŸ’ážáž¶áž“áž—áž¶áž–áŸ– {status})</b>",
    "debt_person": "<b>áž”áž»áž‚áŸ’áž‚áž›áŸ–</b> {person} ({direction})",
    "debt_direction_lent": "áž‡áŸ†áž–áž¶áž€áŸ‹áž¢áŸ’áž“áž€",
    "debt_direction_borrowed": "áž¢áŸ’áž“áž€áž‡áŸ†áž–áž¶áž€áŸ‹",
    "debt_created": "<b>áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘áž”áž„áŸ’áž€áž¾ážáŸ–</b> {date}",
    "debt_purpose": "<b>áž‚áŸ„áž›áž”áŸ†ážŽáž„áŸ–</b> {purpose}\n",
    "debt_original": "<b>áž…áŸ†áž“áž½áž“ážŠáž¾áž˜áŸ–</b> {amount} {currency}",
    "debt_remaining": "<b>ážŸáž˜ážáž»áž›áŸ’áž™ážŠáŸ‚áž›áž“áŸ…ážŸáž›áŸ‹áŸ–</b> {amount} {currency}\n",
    "debt_repayments": "<b>áž”áŸ’ážšážœážáŸ’ážáž·áž€áž¶ážšážŸáž„áž”áŸ’ážšáž¶áž€áŸ‹áŸ–</b>",
    "debt_repayment_item": "  - {amount} {currency} áž“áŸ…ážáŸ’áž„áŸƒáž‘áž¸ {date}",
    "analysis_header": "ðŸ”¬ <b>áž€áž¶ážšážœáž·áž—áž¶áž‚áž”áŸ†ážŽáž»áž›</b>",
    "analysis_loading": "áž€áŸ†áž–áž»áž„ážœáž·áž—áž¶áž‚áž”áŸ†ážŽáž»áž›...",
    "analysis_fail": "áž˜áž·áž“áž¢áž¶áž…áž’áŸ’ážœáž¾áž€áž¶ážšážœáž·áž—áž¶áž‚áž”áŸ†ážŽáž»áž›áž”áž¶áž“áž‘áŸáŸ”",
    "analysis_lent_header": "\n<b>áž˜áž“áž»ážŸáŸ’ážŸážŠáŸ‚áž›áž¢áŸ’áž“áž€áž”áž¶áž“áž¢áŸ„áž™ážáŸ’áž…áž¸áž…áŸ’ážšáž¾áž“áž‡áž¶áž„áž‚áŸáŸ–</b>",
    "analysis_lent_none": "    - áž‚áŸ’áž˜áž¶áž“áž“ážšážŽáž¶áž˜áŸ’áž“áž¶áž€áŸ‹áž‡áŸ†áž–áž¶áž€áŸ‹áž›áž»áž™áž¢áŸ’áž“áž€áž‘áŸáŸ”\n",
    "analysis_borrow_header": "\n<b>áž˜áž“áž»ážŸáŸ’ážŸážŠáŸ‚áž›áž¢áŸ’áž“áž€áž”áž¶áž“ážáŸ’áž…áž¸áž…áŸ’ážšáž¾áž“áž‡áž¶áž„áž‚áŸáŸ–</b>",
    "analysis_borrow_none": "    - áž¢áŸ’áž“áž€áž˜áž·áž“áž‡áŸ†áž–áž¶áž€áŸ‹áž›áž»áž™áž“ážšážŽáž¶áž˜áŸ’áž“áž¶áž€áŸ‹áž‘áŸáŸ”\n",
    "analysis_aging_header": "\n<b>áž”áŸ†ážŽáž»áž›áž…áž¶ážŸáŸ‹áž‡áž¶áž„áž‚áŸážŠáŸ‚áž›áž˜áž·áž“áž‘áž¶áž“áŸ‹áž”áž¶áž“áž‘áž¼áž‘áž¶ážáŸ‹ (áž¢áž¶áž™áž»â€‹áž˜áž’áŸ’áž™áž˜)áŸ–</b>",
    "analysis_aging_none": "    - áž˜áž·áž“áž˜áž¶áž“áž”áŸ†ážŽáž»áž›áž”áž¾áž€áž…áŸ†áž ážŠáž¾áž˜áŸ’áž”áž¸ážœáž·áž—áž¶áž‚áž‘áŸáŸ”\n",
    "analysis_item": "    - {person}: ${total:,.2f}",
    "analysis_aging_item": "    - {person}: {days:.0f} ážáŸ’áž„áŸƒ ({count} áž€áŸ†ážŽážáŸ‹ážáŸ’ážšáž¶)"
  },
  "analytics": {
    "report_ask_period": "ážáž¾áž¢áŸ’áž“áž€áž…áž„áŸ‹áž”áž¶áž“ážšáž”áž¶áž™áž€áž¶ážšážŽáŸážŸáž˜áŸ’ážšáž¶áž”áŸ‹ážšáž™áŸˆáž–áŸáž›ážŽáž¶?",
    "report_ask_start": "ážŸáž¼áž˜áž”áž‰áŸ’áž…áž¼áž›áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘áž…áž¶áž”áŸ‹áž•áŸ’ážáž¾áž˜ (`YYYY-MM-DD`)áŸ–",
    "report_ask_end": "áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘áž…áž¶áž”áŸ‹áž•áŸ’ážáž¾áž˜áž”áž¶áž“áž€áŸ†ážŽážáŸ‹áž‘áŸ… {date}áŸ”\náž¥áž¡áž¼ážœáž“áŸáŸ‡ ážŸáž¼áž˜áž”áž‰áŸ’áž…áž¼áž›áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘áž”áž‰áŸ’áž…áž”áŸ‹ (`YYYY-MM-DD`)áŸ–",
    "report_invalid_date": "áž‘áž˜áŸ’ážšáž„áŸ‹áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ”\nážŸáž¼áž˜áž”áŸ’ážšáž¾ `YYYY-MM-DD` áŸ”",
    "report_invalid_range": "áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ”\nážáŸ’áž„áŸƒáž”áž‰áŸ’áž…áž”áŸ‹áž˜áž·áž“áž¢áž¶áž…áž“áŸ…áž˜áž»áž“ážáŸ’áž„áŸƒáž…áž¶áž”áŸ‹áž•áŸ’ážáž¾áž˜áž”áž¶áž“áž‘áŸáŸ”",
    "report_generating": "ðŸ“ˆ áž€áŸ†áž–áž»áž„áž”áž„áŸ’áž€áž¾ážážšáž”áž¶áž™áž€áž¶ážšážŽáŸážšáž”ážŸáŸ‹áž¢áŸ’áž“áž€ážŸáž˜áŸ’ážšáž¶áž”áŸ‹ {start_date:%b %d, %Y} ážŠáž›áŸ‹ {end_date:%b %d, %Y}...",
    "report_success": "ážšáž”áž¶áž™áž€áž¶ážšážŽáŸáž”áž¶áž“áž”áž‰áŸ’áž…áž”áŸ‹!\nážáž¾â€‹áž˜áž¶áž“â€‹áž¢áŸ’ážœáž¸â€‹áž”áž“áŸ’áž‘áž¶áž”áŸ‹?",
    "report_fail": "áž˜áž·áž“áž¢áž¶áž…áž”áž„áŸ’áž€áž¾ážážšáž”áž¶áž™áž€áž¶ážšážŽáŸáž”áž¶áž“áž‘áŸáŸ”\nážšáž€áž˜áž·áž“ážƒáž¾áž‰áž‘áž·áž“áŸ’áž“áž“áŸáž™ážŸáž˜áŸ’ážšáž¶áž”áŸ‹ážšáž™áŸˆáž–áŸáž›áž“áŸáŸ‡áž‘áŸáŸ”",
    "habits_ask_period": "ðŸ§  ážáž¾áž¢áŸ’áž“áž€áž…áž„áŸ‹ážœáž·áž—áž¶áž‚áž‘áž˜áŸ’áž›áž¶áž”áŸ‹áž…áŸ†ážŽáž¶áž™ážšáž”ážŸáŸ‹áž¢áŸ’áž“áž€ážŸáž˜áŸ’ážšáž¶áž”áŸ‹ážšáž™áŸˆáž–áŸáž›ážŽáž¶?",
    "habits_no_custom": "áž‡áž½ážšáž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘áž•áŸ’áž‘áž¶áž›áŸ‹ážáŸ’áž›áž½áž“áž˜áž·áž“áž˜áž¶áž“ážŸáž˜áŸ’ážšáž¶áž”áŸ‹áž€áž¶ážšážœáž·áž—áž¶áž‚áž‘áž˜áŸ’áž›áž¶áž”áŸ‹áž‘áŸáŸ”\nážŸáž¼áž˜áž‡áŸ’ážšáž¾ážŸážšáž¾ážŸážšáž™áŸˆáž–áŸáž›ážŸáŸ’ážáž„áŸ‹ážŠáž¶ážšáŸ”",
    "habits_generating": "ðŸ§  áž€áŸ†áž–áž»áž„ážœáž·áž—áž¶áž‚áž‘áž˜áŸ’áž›áž¶áž”áŸ‹ážšáž”ážŸáŸ‹áž¢áŸ’áž“áž€...",
    "habits_fail": "ážšáž€áž˜áž·áž“ážƒáž¾áž‰áž‘áž·áž“áŸ’áž“áž“áŸáž™áž‚áŸ’ážšáž”áŸ‹áž‚áŸ’ážšáž¶áž“áŸ‹ážŠáž¾áž˜áŸ’áž”áž¸ážœáž·áž—áž¶áž‚áž‘áž˜áŸ’áž›áž¶áž”áŸ‹ážšáž”ážŸáŸ‹áž¢áŸ’áž“áž€ážŸáž˜áŸ’ážšáž¶áž”áŸ‹ážšáž™áŸˆáž–áŸáž›áž“áŸáŸ‡áž‘áŸáŸ”",
    "habits_invalid_period": "ážšáž™áŸˆáž–áŸáž›ážŠáŸ‚áž›áž”áž¶áž“áž‡áŸ’ážšáž¾ážŸážšáž¾ážŸáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ”"
  },
  "search": {
    "menu_header": "ážáž¾áž¢áŸ’áž“áž€áž…áž„áŸ‹áž’áŸ’ážœáž¾áž€áž¶ážšážŸáŸ’ážœáŸ‚áž„ážšáž€áž”áŸ’ážšáž—áŸáž‘áž¢áŸ’ážœáž¸?",
    "ask_period": "ðŸ”Ž ážŸáŸ’ážœáŸ‚áž„ážšáž€áž€áž˜áŸ’ážšáž·ážážáŸ’áž–ážŸáŸ‹\n\nážŠáŸ†áž”áž¼áž„ áž‡áŸ’ážšáž¾ážŸážšáž¾ážŸážšáž™áŸˆáž–áŸáž›ážŸáž˜áŸ’ážšáž¶áž”áŸ‹áž€áž¶ážšážŸáŸ’ážœáŸ‚áž„ážšáž€áŸ”",
    "ask_start": "ážŸáž¼áž˜áž”áž‰áŸ’áž…áž¼áž›áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘áž…áž¶áž”áŸ‹áž•áŸ’ážáž¾áž˜ (`YYYY-MM-DD`)áŸ–",
    "ask_end": "áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘áž…áž¶áž”áŸ‹áž•áŸ’ážáž¾áž˜áž”áž¶áž“áž€áŸ†ážŽážáŸ‹áž‘áŸ… {date:%Y-%m-%d}áŸ”\náž¥áž¡áž¼ážœáž“áŸáŸ‡ ážŸáž¼áž˜áž”áž‰áŸ’áž…áž¼áž›áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘áž”áž‰áŸ’áž…áž”áŸ‹ (`YYYY-MM-DD`)áŸ–",
    "invalid_date": "áž‘áž˜áŸ’ážšáž„áŸ‹áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ”\nážŸáž¼áž˜áž”áŸ’ážšáž¾ `YYYY-MM-DD` áŸ”",
    "invalid_range": "áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ”\nážáŸ’áž„áŸƒáž”áž‰áŸ’áž…áž”áŸ‹áž˜áž·áž“áž¢áž¶áž…áž“áŸ…áž˜áž»áž“ážáŸ’áž„áŸƒáž…áž¶áž”áŸ‹áž•áŸ’ážáž¾áž˜áž”áž¶áž“áž‘áŸáŸ”",
    "ask_type": "ážáž¾áž¢áŸ’áž“áž€áž…áž„áŸ‹ážŸáŸ’ážœáŸ‚áž„ážšáž€áž”áŸ’ážšáž—áŸáž‘áž”áŸ’ážšážáž·áž”ážáŸ’ážáž·áž€áž¶ážšáž¢áŸ’ážœáž¸?",
    "ask_categories": "áž”áž‰áŸ’áž…áž¼áž›áž”áŸ’ážšáž—áŸáž‘ážŠáŸ‚áž›áž¢áŸ’áž“áž€áž…áž„áŸ‹ážšáž½áž˜áž”áž‰áŸ’áž…áž¼áž› ážŠáŸ„áž™áž”áŸ†áž”áŸ‚áž€ážŠáŸ„áž™ážŸáž‰áŸ’áž‰áž¶áž€áŸ’áž”áŸ€ážŸ (áž§. áž¢áž¶áž áž¶ážš, áž—áŸážŸáž‡áŸ’áž‡áŸˆ)áŸ”\n\náž¬áž…áž»áž… áž†áŸ’áž›áž„áž€áž¶ážáŸ‹ ážŠáž¾áž˜áŸ’áž”áž¸ážšáž½áž˜áž”áž‰áŸ’áž…áž¼áž›áž‚áŸ’ážšáž”áŸ‹áž”áŸ’ážšáž—áŸáž‘áž‘áž¶áŸ†áž„áž¢ážŸáŸ‹áŸ”",
    "ask_keywords": "áž”áž‰áŸ’áž…áž¼áž›áž–áž¶áž€áŸ’áž™áž‚áž“áŸ’áž›áž¹áŸ‡ážŠáž¾áž˜áŸ’áž”áž¸ážŸáŸ’ážœáŸ‚áž„ážšáž€áž€áŸ’áž“áž»áž„áž€áž¶ážšáž–áž·áž–ážŽáŸŒáž“áž¶ ážŠáŸ„áž™áž”áŸ†áž”áŸ‚áž€ážŠáŸ„áž™ážŸáž‰áŸ’áž‰áž¶áž€áŸ’áž”áŸ€ážŸ (áž§. áž€áž¶áž áŸ’ážœáŸ, áž¢áž¶áž áž¶ážšážáŸ’áž„áŸƒážáŸ’ážšáž„áŸ‹)áŸ”\n\náž¬áž…áž»áž… áž†áŸ’áž›áž„áž€áž¶ážáŸ‹ ážŠáž¾áž˜áŸ’áž”áž¸áž€áž»áŸ†áž±áŸ’áž™ážáŸ’ážšáž„ážáž¶áž˜áž–áž¶áž€áŸ’áž™áž‚áž“áŸ’áž›áž¹áŸ‡áŸ”",
    "ask_logic": "ážáž¾áž€áž¶ážšáž–áž·áž–ážŽáŸŒáž“áž¶áž‚áž½ážšážáŸ‚áž˜áž¶áž“áž–áž¶áž€áŸ’áž™áž‚áž“áŸ’áž›áž¹áŸ‡ **áž‘áž¶áŸ†áž„áž¢ážŸáŸ‹** áž“áŸáŸ‡ (AND) áž¬ **ážŽáž¶áž˜áž½áž™** áž€áŸ’áž“áž»áž„áž…áŸ†ážŽáŸ„áž˜áž–áž½áž€ážœáž¶ (OR)?",
    "searching": "ðŸ”Ž áž€áŸ†áž–áž»áž„â€‹ážŸáŸ’ážœáŸ‚áž„ážšáž€...",
    "no_results": "ážšáž€áž˜áž·áž“ážƒáž¾áž‰áž”áŸ’ážšážáž·áž”ážáŸ’ážáž·áž€áž¶ážšážŠáŸ‚áž›ážáŸ’ážšáž¼ážœáž“áž¹áž„áž›áž€áŸ’ážážážŽáŸ’ážŒážšáž”ážŸáŸ‹áž¢áŸ’áž“áž€áž‘áŸáŸ”",
    "one_result": "ážšáž€ážƒáž¾áž‰ 1 áž”áŸ’ážšážáž·áž”ážáŸ’ážáž·áž€áž¶ážšážŠáŸ‚áž›ážáŸ’ážšáž¼ážœáž‚áŸ’áž“áž¶áŸ–",
    "many_results": "ážšáž€ážƒáž¾áž‰ {count} áž”áŸ’ážšážáž·áž”ážáŸ’ážáž·áž€áž¶ážšážŠáŸ‚áž›ážáŸ’ážšáž¼ážœáž‚áŸ’áž“áž¶áŸ”\náž‡áŸ’ážšáž¾ážŸážšáž¾ážŸáž˜áž½áž™ážŠáž¾áž˜áŸ’áž”áž¸áž‚áŸ’ážšáž”áŸ‹áž‚áŸ’ážšáž„áŸ–"
  },
  "categories": {
    "Food": "ðŸ’¸ áž¢áž¶áž áž¶ážš",
    "Drink": "â˜•ï¸ áž—áŸážŸáž‡áŸ’áž‡áŸˆ",
    "Transport": "ðŸš— ážŠáŸ†ážŽáž¾ážš",
    "Shopping": "ðŸ›ï¸ áž‘áž·áž‰áž‘áŸ†áž“áž·áž‰",
    "Bills": "ðŸ§¾ ážœáž·áž€áŸáž™áž”áŸážáŸ’ážš",
    "Utilities": "ðŸ’¡ áž§áž”áž€ážšážŽáŸáž”áŸ’ážšáž¾áž”áŸ’ážšáž¶ážŸáŸ‹",
    "Entertainment": "ðŸŽ¬ áž€áž˜áŸ’ážŸáž¶áž“áŸ’áž",
    "Personal Care": "ðŸ§´ áž•áŸ’áž‘áž¶áž›áŸ‹ážáŸ’áž›áž½áž“",
    "Work": "ðŸ’¼ áž€áž¶ážšáž„áž¶ážš",
    "Alcohol": "ðŸº áž‚áŸ’ážšáž¿áž„ážŸáŸ’ážšážœáž¹áž„",
    "For Others": "ðŸ‘¥ ážŸáž˜áŸ’ážšáž¶áž”áŸ‹áž¢áŸ’áž“áž€ážŠáž‘áŸƒ",
    "Health": "ðŸ©º ážŸáž»ážáž—áž¶áž–",
    "Investment": "ðŸ“ˆ ážœáž·áž“áž·áž™áŸ„áž‚",
    "Forgot": "ðŸ¤” áž—áŸ’áž›áŸáž…",
    "Rent": "ðŸ  ážáŸ’áž›áŸƒážˆáŸ’áž“áž½áž›áž•áŸ’áž‘áŸ‡",
    "Subscriptions": "ðŸ”„ áž€áž¶ážšáž‡áž¶ážœ",
    "Insurance": "ðŸ›¡ï¸ áž’áž¶áž“áž¶ážšáŸ‰áž¶áž”áŸ‹ážšáž„",
    "Education": "ðŸŽ“ áž€áž¶ážšáž¢áž”áŸ‹ážšáŸ†",
    "Gifts": "ðŸŽ áž€áž¶ážŠáž¼",
    "Donations": "â¤ï¸ áž¢áŸ†ážŽáŸ„áž™",
    "Family": "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦ áž‚áŸ’ážšáž½ážŸáž¶ážš",
    "Travel": "âœˆï¸ áž€áž¶ážšáž’áŸ’ážœáž¾ážŠáŸ†ážŽáž¾ážš",
    "Pets": "ðŸ¾ ážŸážáŸ’ážœáž…áž·áž‰áŸ’áž…áž¹áž˜",
    "Electronics": "ðŸ“± áž‚áŸ’ážšáž¿áž„áž¢áŸáž¡áž·áž…ážáŸ’ážšáž¼áž“áž·áž€",
    "Car Maintenance": "ðŸ› ï¸ ážáŸ‚áž‘áž¶áŸ†áž¡áž¶áž“",
    "Salary": "ðŸ’° áž”áŸ’ážšáž¶áž€áŸ‹ážáŸ‚",
    "Bonus": "ðŸŽ‰ áž”áŸ’ážšáž¶áž€áŸ‹ážšáž„áŸ’ážœáž¶áž“áŸ‹",
    "Freelance": "ðŸ’» áž¯áž€ážšáž¶áž‡áŸ’áž™",
    "Commission": "ðŸ¤ áž€áž˜áŸ’ážšáŸƒáž‡áž¾áž„ážŸáž¶ážš",
    "Allowance": "ðŸ§‘â€ðŸŽ“ áž”áŸ’ážšáž¶áž€áŸ‹áž§áž”ážáŸ’ážáž˜áŸ’áž—",
    "Gift": "ðŸŽ áž€áž¶ážŠáž¼",
    "Investment Income": "ðŸ“ˆ áž…áŸ†ážŽáž¼áž›ážœáž·áž“áž·áž™áŸ„áž‚",
    "Other Income": "áž…áŸ†ážŽáž¼áž›áž•áŸ’ážŸáŸáž„áŸ—"
  }
}

============================================================

==================== FILE: telegram_bot/utils/__init__.py ====================
# --- Start of new file: telegram_bot/utils/__init__.py ---
# This file intentionally left blank
# --- End of new file ---

============================================================

==================== FILE: telegram_bot/utils/i18n.py ====================
# --- Start of new file: telegram_bot/utils/i18n.py ---
import json
import os
from telegram.ext import ContextTypes

# In-memory cache for translations
translations = {}
SUPPORTED_LANGUAGES = ['en', 'km']
DEFAULT_LANGUAGE = 'en'


def load_translations():
    """
    Loads all translation files from the 'locales' directory into memory.
    """
    global translations
    if translations:
        return  # Already loaded

    locales_dir = os.path.join(
        os.path.dirname(os.path.dirname(__file__)), 'locales'
    )
    print(f"Loading translations from: {locales_dir}")

    for lang in SUPPORTED_LANGUAGES:
        file_path = os.path.join(locales_dir, f'{lang}.json')
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                translations[lang] = json.load(f)
                print(f"Successfully loaded '{lang}' locale.")
        except FileNotFoundError:
            print(f"Warning: Translation file not found for '{lang}'")
        except json.JSONDecodeError:
            print(f"Error: Could not decode JSON for '{lang}'")

    if DEFAULT_LANGUAGE not in translations:
        raise RuntimeError(
            f"Default language '{DEFAULT_LANGUAGE}' file is missing or invalid."
        )


def t(key: str, context: ContextTypes.DEFAULT_TYPE, **kwargs) -> str:
    """
    Translates a given key into the user's preferred language.

    Args:
        key: The dot-separated key (e.g., "common.welcome").
        context: The bot's context, used to find the user's profile.
        **kwargs: Variables to format into the string.

    Returns:
        The translated and formatted string.
    """
    if not translations:
        load_translations()

    # 1. Get user's language from cached profile
    lang = DEFAULT_LANGUAGE
    if context.user_data and 'user_profile' in context.user_data:
        lang = (
            context.user_data['user_profile']
            .get('settings', {})
            .get('language', DEFAULT_LANGUAGE)
        )

    if lang not in SUPPORTED_LANGUAGES:
        lang = DEFAULT_LANGUAGE

    # 2. Navigate the dot-separated key
    try:
        keys = key.split('.')
        temp_translation = translations.get(lang, translations[DEFAULT_LANGUAGE])
        for k in keys:
            temp_translation = temp_translation[k]

        # 3. Format the string
        return temp_translation.format(**kwargs)

    except (KeyError, TypeError):
        # Fallback: return the key itself
        print(f"Translation key not found: '{key}' for lang '{lang}'")
        return key
    except Exception as e:
        print(f"Error during translation of key '{key}': {e}")
        return key

# --- End of new file ---

============================================================

==================== FILE: web_service/Dockerfile ====================
# Use an official Python runtime as a parent image
FROM python:3.11-slim

# Set the timezone for the container.
ENV TZ=Asia/Phnom_Penh
RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ > /etc/timezone

# Set the working directory inside the container
WORKDIR /app

# Copy the requirements file from the repository root
COPY requirements.txt .

# Install dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy the web_service directory contents to /app
COPY web_service/ .

# Make port 8000 available to the world outside this container
EXPOSE 8000

# Set environment variables
ENV PYTHONPATH=/app
ENV FLASK_APP=run.py

# Run the application using the run.py file directly
CMD ["python", "run.py"]


============================================================

==================== FILE: web_service/__init__.py ====================


============================================================

==================== FILE: web_service/app/__init__.py ====================
# --- web_service/app/__init__.py (FULL) ---

import certifi
import io
import os
import requests
import matplotlib.pyplot as plt
import logging
from flask import Flask, jsonify, g, current_app
from pymongo import MongoClient
from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.triggers.cron import CronTrigger
from .config import Config
from datetime import datetime, time, timedelta, date
from zoneinfo import ZoneInfo
from bson import ObjectId

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
log = logging.getLogger(__name__)

PHNOM_PENH_TZ = ZoneInfo("Asia/Phnom_Penh")
UTC_TZ = ZoneInfo("UTC")
FINANCIAL_TRANSACTION_CATEGORIES = [
    'Loan Lent', 'Debt Repayment', 'Loan Received', 'Debt Settled', 'Initial Balance'
]

MONGO_CONNECTION_ARGS = {
    "tls": True,
    "serverSelectionTimeoutMS": 30000,
    "connectTimeoutMS": 20000,
    "socketTimeoutMS": 20000,
    "tlsCAFile": certifi.where(),
}


def send_telegram_message(chat_id, text, token, parse_mode='HTML'):
    """A simple function to send a message via the Telegram API."""
    url = f"https://api.telegram.org/bot{token}/sendMessage"
    payload = {'chat_id': chat_id, 'text': text, 'parse_mode': parse_mode}
    try:
        response = requests.post(url, json=payload, timeout=20)
        response.raise_for_status()
    except Exception as e:
        log.warning(f"Failed to send scheduled message to {chat_id}: {e}")


def send_telegram_photo(chat_id, photo_bytes, token, caption=""):
    """Sends a photo from bytes via the Telegram API."""
    url = f"https://api.telegram.org/bot{token}/sendPhoto"
    files = {'photo': ('report_chart.png', photo_bytes, 'image/png')}
    data = {'chat_id': chat_id, 'caption': caption}
    try:
        response = requests.post(url, data=data, files=files, timeout=30)
        response.raise_for_status()
    except Exception as e:
        log.warning(f"Failed to send scheduled photo to {chat_id}: {e}")


def get_report_data(start_date_local_obj, end_date_local_obj, db):
    """Internal logic to fetch detailed report data."""
    aware_start_local = datetime.combine(start_date_local_obj, time.min, tzinfo=PHNOM_PENH_TZ)
    aware_end_local = datetime.combine(end_date_local_obj, time.max, tzinfo=PHNOM_PENH_TZ)
    start_date_utc = aware_start_local.astimezone(UTC_TZ)
    end_date_utc = aware_end_local.astimezone(UTC_TZ)

    add_fields_stage = {
        '$addFields': {
            'amount_in_usd': {
                '$cond': {
                    'if': {'$eq': ['$currency', 'USD']},
                    'then': '$amount',
                    'else': {
                        '$let': {
                            'vars': {'rate': {'$ifNull': ['$exchangeRateAtTime', 4100.0]}},
                            'in': {'$cond': {'if': {'$gt': ['$$rate', 0]}, 'then': {'$divide': ['$amount', '$$rate']},
                                             'else': {'$divide': ['$amount', 4100.0]}}}
                        }
                    }
                }
            }
        }
    }

    start_balance_pipeline = [
        {'$match': {'timestamp': {'$lt': start_date_utc}}},
        add_fields_stage,
        {'$group': {'_id': '$type', 'totalUSD': {'$sum': '$amount_in_usd'}}}
    ]
    start_balance_data = list(db.transactions.aggregate(start_balance_pipeline))
    start_income = next((item['totalUSD'] for item in start_balance_data if item['_id'] == 'income'), 0)
    start_expense = next((item['totalUSD'] for item in start_balance_data if item['_id'] == 'expense'), 0)
    balance_at_start_usd = start_income - start_expense

    operational_pipeline = [
        {'$match': {'timestamp': {'$gte': start_date_utc, '$lte': end_date_utc},
                    'categoryId': {'$nin': FINANCIAL_TRANSACTION_CATEGORIES}}},
        add_fields_stage,
        {'$group': {'_id': {'type': '$type', 'category': '$categoryId'}, 'total': {'$sum': '$amount_in_usd'}}},
        {'$sort': {'total': -1}}
    ]
    operational_data = list(db.transactions.aggregate(operational_pipeline))

    report = {
        "startDate": start_date_local_obj.isoformat(),
        "endDate": end_date_local_obj.isoformat(),
        "summary": {"totalIncomeUSD": 0, "totalExpenseUSD": 0, "netSavingsUSD": 0,
                    "balanceAtStartUSD": balance_at_start_usd},
        "expenseBreakdown": []
    }

    for item in operational_data:
        if item['_id']['type'] == 'income':
            report['summary']['totalIncomeUSD'] += item['total']
        elif item['_id']['type'] == 'expense':
            report['summary']['totalExpenseUSD'] += item['total']
            report['expenseBreakdown'].append({'category': item['_id']['category'], 'totalUSD': item['total']})
    report['summary']['netSavingsUSD'] = report['summary']['totalIncomeUSD'] - report['summary']['totalExpenseUSD']
    return report


def format_scheduled_report_message(data):
    summary = data.get('summary', {})
    start_date = datetime.fromisoformat(data['startDate']).strftime('%b %d, %Y')
    end_date = datetime.fromisoformat(data['endDate']).strftime('%b %d, %Y')

    header = f"ðŸ—“ï¸ <b>Scheduled Financial Report</b>\n<i>{start_date} to {end_date}</i>\n\n"
    income = summary.get('totalIncomeUSD', 0)
    expense = summary.get('totalExpenseUSD', 0)
    net = summary.get('netSavingsUSD', 0)
    summary_text = (
        f"<b>Summary (in USD):</b>\n"
        f"â¬†ï¸ Income: ${income:,.2f}\n"
        f"â¬‡ï¸ Expense: ${expense:,.2f}\n"
        f"<b>Net: ${net:,.2f}</b> {'âœ…' if net >= 0 else 'ðŸ”»'}\n\n"
    )
    expense_breakdown = data.get('expenseBreakdown', [])
    expense_text = "<b>Top Expenses:</b>\n"
    if expense_breakdown:
        for item in expense_breakdown[:3]:
            expense_text += f"    - {item['category']}: ${item['totalUSD']:,.2f}\n"
    else:
        expense_text += "    - No expenses recorded.\n"
    return header + summary_text + expense_text


def create_pie_chart_from_data(data, start_date, end_date):
    expense_breakdown = data.get('expenseBreakdown', [])
    total_expense = data.get('summary', {}).get('totalExpenseUSD', 0)
    if not expense_breakdown or total_expense == 0:
        return None

    threshold = 4.0
    new_labels, new_sizes, other_total = [], [], 0
    if total_expense > 0:
        for item in expense_breakdown:
            percentage = (item['totalUSD'] / total_expense) * 100
            if percentage < threshold:
                other_total += item['totalUSD']
            else:
                new_labels.append(item['category'])
                new_sizes.append(item['totalUSD'])
    if other_total > 0:
        new_labels.append('Other')
        new_sizes.append(other_total)

    labels, sizes = new_labels, new_sizes
    date_range_str = f"{start_date.strftime('%b %d, %Y')} to {end_date.strftime('%b %d, %Y')}"

    fig, ax = plt.subplots(figsize=(7, 6))
    ax.set_title('Expense Breakdown', pad=20)
    plt.suptitle(date_range_str, y=0.93, fontsize=10)
    ax.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=90)
    ax.axis('equal')
    buf = io.BytesIO()
    plt.savefig(buf, format='png', bbox_inches='tight')
    plt.close(fig)
    buf.seek(0)
    return buf.getvalue()


def _send_report_job(period_name, start_date, end_date, db, token, chat_id):
    """Generic helper to generate and send a report."""
    report_data = get_report_data(start_date, end_date, db)
    if report_data and report_data.get('summary', {}).get('totalExpenseUSD', 0) > 0:
        message = format_scheduled_report_message(report_data)
        send_telegram_message(chat_id, message, token)
        pie_chart_bytes = create_pie_chart_from_data(report_data, start_date, end_date)
        if pie_chart_bytes:
            send_telegram_photo(chat_id, pie_chart_bytes, token)
    else:
        message = f"ðŸ“Š No significant activity recorded for the {period_name} ({start_date.strftime('%b %d')} - {end_date.strftime('%b %d')})."
        send_telegram_message(chat_id, message, token)


def run_scheduled_report(period):
    """Main function called by scheduler to run a report for a given period."""
    try:
        client = MongoClient(Config.MONGODB_URI, **MONGO_CONNECTION_ARGS)
        db = client[Config.DB_NAME]
        token = Config.TELEGRAM_TOKEN
    except Exception as e:
        log.error(f"Failed to create MongoClient for scheduled job: {e}", exc_info=True)
        return

    try:
        users_to_report = db.users.find({
            "settings.report_chat_id": {"$exists": True, "$ne": None},
            "subscription_status": "active"
        })
    except Exception as e:
        log.error(f"Scheduled job failed to query users: {e}", exc_info=True)
        client.close()
        return

    for user in users_to_report:
        chat_id = user['settings']['report_chat_id']
        log.info(f"Generating {period} report for user {user['name']} (ChatID: {chat_id})...")

    chat_id = Config.TELEGRAM_CHAT_ID
    if not token or not chat_id:
        client.close()
        return

    today = datetime.now(PHNOM_PENH_TZ).date()
    if period == 'weekly':
        end_date = today - timedelta(days=today.weekday() + 1)
        start_date = end_date - timedelta(days=6)
        _send_report_job('previous week', start_date, end_date, db, token, chat_id)
    elif period == 'monthly':
        end_date = today.replace(day=1) - timedelta(days=1)
        start_date = end_date.replace(day=1)
        _send_report_job('previous month', start_date, end_date, db, token, chat_id)
    elif period == 'semesterly':
        if today.month == 1:
            end_date = today.replace(year=today.year - 1, month=12, day=31)
            start_date = today.replace(year=today.year - 1, month=7, day=1)
            _send_report_job('last semester', start_date, end_date, db, token, chat_id)
        elif today.month == 7:
            end_date = today.replace(month=6, day=30)
            start_date = today.replace(month=1, day=1)
            _send_report_job('first semester', start_date, end_date, db, token, chat_id)
    elif period == 'yearly':
        end_date = today.replace(year=today.year - 1, month=12, day=31)
        start_date = today.replace(year=today.year - 1, month=1, day=1)
        _send_report_job('previous year', start_date, end_date, db, token, chat_id)

    client.close()


def send_daily_reminder_job():
    try:
        client = MongoClient(Config.MONGODB_URI, **MONGO_CONNECTION_ARGS)
        db = client[Config.DB_NAME]
    except Exception as e:
        log.error(f"Failed to create MongoClient for daily job: {e}", exc_info=True)
        return

    token = Config.TELEGRAM_TOKEN
    chat_id = Config.TELEGRAM_CHAT_ID
    if not token or not chat_id:
        client.close()
        return

    now_in_phnom_penh = datetime.now(PHNOM_PENH_TZ)
    today_start_local_aware = datetime.combine(now_in_phnom_penh.date(), time.min, tzinfo=PHNOM_PENH_TZ)
    today_start_utc = today_start_local_aware.astimezone(ZoneInfo("UTC"))

    try:
        count = db.transactions.count_documents({'timestamp': {'$gte': today_start_utc}})
        if count == 0:
            message = "Hey! ìžŠì§€ë§ˆ! (Don't forget!)\n\nLooks like you haven't logged any transactions today. Take a moment to log your activity! âœï¸"
            send_telegram_message(chat_id, message, token, parse_mode='Markdown')
        else:
            pass
    except Exception as e:
        log.error(f"Daily reminder job failed to query/send: {e}", exc_info=True)

    client.close()


def get_db():
    """
    Connects to the specific database.
    Uses Flask's 'g' to reuse the connection per-request.
    """
    if 'db_client' not in g:
        uri = current_app.config['MONGODB_URI']
        try:
            g.db_client = MongoClient(uri, **MONGO_CONNECTION_ARGS)
            g.db = g.db_client[current_app.config['DB_NAME']]
        except Exception as e:
            log.error(f"Failed to create MongoClient: {e}", exc_info=True)
            raise e
    return g.db


def close_db(e=None):
    """Closes the database connection on app context teardown."""
    client = g.pop('db_client', None)
    if client is not None:
        client.close()
        g.pop('db', None)


def create_app():
    app = Flask(__name__)
    app.config.from_object(Config)

    app.config['MONGODB_URI'] = Config.MONGODB_URI
    app.config['DB_NAME'] = Config.DB_NAME
    app.config['TELEGRAM_TOKEN'] = Config.TELEGRAM_TOKEN

    app.teardown_appcontext(close_db)

    scheduler = BackgroundScheduler(daemon=True, timezone='Asia/Phnom_Penh')
    scheduler.add_job(send_daily_reminder_job, trigger=CronTrigger(hour=21, minute=0), id='daily_reminder', replace_existing=True)
    scheduler.add_job(run_scheduled_report, args=['weekly'], trigger=CronTrigger(day_of_week='mon', hour=8, minute=0), id='weekly_report', replace_existing=True)
    scheduler.add_job(run_scheduled_report, args=['monthly'], trigger=CronTrigger(day=1, hour=8, minute=30), id='monthly_report', replace_existing=True)
    scheduler.add_job(run_scheduled_report, args=['semesterly'], trigger=CronTrigger(month='1,7', day=1, hour=9, minute=0), id='semesterly_report', replace_existing=True)
    scheduler.add_job(run_scheduled_report, args=['yearly'], trigger=CronTrigger(month=1, day=1, hour=9, minute=30), id='yearly_report', replace_existing=True)
    scheduler.start()
    app.scheduler = scheduler

    from .settings.routes import settings_bp
    from .analytics.routes import analytics_bp
    from .transactions.routes import transactions_bp
    from .debts.routes import debts_bp
    from .summary.routes import summary_bp
    from .reminders.routes import reminders_bp
    from .auth.routes import auth_bp

    app.register_blueprint(settings_bp)
    app.register_blueprint(analytics_bp)
    app.register_blueprint(transactions_bp)
    app.register_blueprint(debts_bp)
    app.register_blueprint(summary_bp)
    app.register_blueprint(reminders_bp)
    app.register_blueprint(auth_bp)

    @app.route("/health")
    def health_check():
        return jsonify({"status": "ok"})

    @app.route("/__egress_ip")
    def egress_ip():
        """
        Returns the public egress IP of the running container.
        """
        tries = [
            ("https://api.ipify.org?format=json", "json", "ip"),
            ("https://ifconfig.me/ip", "text", None),
            ("https://httpbin.org/ip", "json", "origin"),
        ]
        for url, mode, key in tries:
            try:
                r = requests.get(url, timeout=5)
                r.raise_for_status()
                if mode == "json":
                    data = r.json()
                    val = data.get(key, "")
                    ip = val.split(",")[0].strip() if isinstance(val, str) else val
                    if ip:
                        return jsonify({"ip": ip, "source": url.split("//")[1].split("/")[0]})
                else:
                    ip = (r.text or "").strip()
                    if ip:
                        return jsonify({"ip": ip, "source": url.split("//")[1].split("/")[0]})
            except Exception as e:
                log.warning(f"Egress IP check failed for {url}: {e}")
                continue
        return jsonify({"error": "Unable to determine egress IP"}), 502

    @app.route("/__db_ping")
    def db_ping():
        """
        Pings MongoDB using the same connection args the app uses.
        """
        uri = current_app.config.get("MONGODB_URI")
        dbname = current_app.config.get("DB_NAME")
        if not uri or not dbname:
            return jsonify({"ok": False, "error": "DB config missing"}), 500

        try:
            client = MongoClient(uri, **MONGO_CONNECTION_ARGS)
            admin_ok = client.admin.command("ping").get("ok", 0) == 1
            db = client[dbname]
            db_ok = db.command("ping").get("ok", 0) == 1

            try:
                colls = db.list_collection_names()
            except Exception as e:
                log.warning(f"Could not list collections: {e}")
                colls = []

            payload = {
                "ok": admin_ok and db_ok,
                "admin_ping": admin_ok,
                "db_ping": db_ok,
                "db_name": dbname,
                "collections_count": len(colls),
                "collections": sorted(colls)[:25],
            }
            client.close()
            status = 200 if payload["ok"] else 500
            return jsonify(payload), status
        except Exception as e:
            return jsonify({"ok": False, "error": str(e)}), 500

    return app

============================================================

==================== FILE: web_service/app/analytics/__init__.py ====================


============================================================

==================== FILE: web_service/app/analytics/routes.py ====================
# --- Start of modified file: web_service/app/analytics/routes.py ---
"""
Handles all analytics and report generation endpoints.
All endpoints are multi-tenant and require a valid user_id.
"""
import io
from flask import Blueprint, Response, request, jsonify
from datetime import datetime, timedelta, time
from zoneinfo import ZoneInfo
import matplotlib.pyplot as plt
import re
from app import get_db
from app.utils.auth import get_user_id_from_request
from app.utils.currency import get_live_usd_to_khr_rate

analytics_bp = Blueprint('analytics', __name__, url_prefix='/analytics')

FINANCIAL_TRANSACTION_CATEGORIES = [
    'Loan Lent',
    'Debt Repayment',
    'Loan Received',
    'Debt Settled',
    'Initial Balance' # Kept for v1 data, but excluded from new reports
]

PHNOM_PENH_TZ = ZoneInfo("Asia/Phnom_Penh")
UTC_TZ = ZoneInfo("UTC")


def _get_user_financial_base(db, user_id):
    """
    Helper to get the user's initial balance in USD and their preferred rate.
    """
    user = db.users.find_one(
        {'_id': user_id},
        {'settings': 1}
    )
    if not user:
        raise Exception("User not found")

    settings = user.get('settings', {})

    # Get initial balances
    initial_balances = settings.get('initial_balances', {})
    initial_usd = initial_balances.get('USD', 0)
    initial_khr = initial_balances.get('KHR', 0)

    # Get rate
    rate_preference = settings.get('rate_preference', 'live')
    rate = 4100.0
    if rate_preference == 'fixed':
        rate = settings.get('fixed_rate', 4100.0)
    else:
        rate = get_live_usd_to_khr_rate()

    # Calculate total initial balance in USD
    initial_balance_in_usd = initial_usd + (initial_khr / rate)

    return initial_balance_in_usd, rate


def get_date_ranges_for_search():
    """Helper for analytics endpoints to get UTC date ranges."""
    today = datetime.now(PHNOM_PENH_TZ).date()
    start_of_week = today - timedelta(days=today.weekday())
    start_of_month = today.replace(day=1)
    end_of_last_week = start_of_week - timedelta(days=1)
    start_of_last_week = end_of_last_week - timedelta(days=6)

    def create_utc_range(start_local, end_local):
        aware_start = datetime.combine(start_local, time.min, tzinfo=PHNOM_PENH_TZ)
        aware_end = datetime.combine(end_local, time.max, tzinfo=PHNOM_PENH_TZ)
        return aware_start.astimezone(UTC_TZ), aware_end.astimezone(UTC_TZ)

    return {
        "today": create_utc_range(today, today),
        "this_week": create_utc_range(start_of_week, start_of_week + timedelta(days=6)),
        "last_week": create_utc_range(start_of_last_week, end_of_last_week),
        "this_month": create_utc_range(start_of_month,
                                       (start_of_month.replace(day=28) + timedelta(days=4)).replace(day=1) - timedelta(
                                           days=1))
    }


@analytics_bp.route('/search', methods=['POST'])
def search_transactions():
    """Performs an advanced search and sums up matching transactions for a user."""
    params = request.json
    db = get_db()

    user_id, error = get_user_id_from_request()
    if error: return error

    match_stage = {'user_id': user_id}

    date_filter = {}
    if params.get('period'):
        ranges = get_date_ranges_for_search()
        if params['period'] in ranges:
            start_utc, end_utc = ranges[params['period']]
            date_filter['$gte'] = start_utc
            date_filter['$lte'] = end_utc
    elif params.get('start_date') and params.get('end_date'):
        start_local = datetime.fromisoformat(params['start_date']).date()
        end_local = datetime.fromisoformat(params['end_date']).date()
        aware_start = datetime.combine(start_local, time.min, tzinfo=PHNOM_PENH_TZ)
        aware_end = datetime.combine(end_local, time.max, tzinfo=PHNOM_PENH_TZ)
        date_filter['$gte'] = aware_start.astimezone(UTC_TZ)
        date_filter['$lte'] = aware_end.astimezone(UTC_TZ)

    if date_filter:
        match_stage['timestamp'] = date_filter
    if params.get('transaction_type'):
        match_stage['type'] = params['transaction_type']
    if params.get('categories'):
        categories_regex = [re.compile(f'^{re.escape(c.strip())}$', re.IGNORECASE) for c in params['categories']]
        match_stage['categoryId'] = {'$in': categories_regex}
    if params.get('keywords'):
        keywords = params['keywords']
        keyword_logic = params.get('keyword_logic', 'OR').upper()
        if keyword_logic == 'AND':
            match_stage['$and'] = [{'description': re.compile(k, re.IGNORECASE)} for k in keywords]
        else:
            regex_str = '|'.join([re.escape(k) for k in keywords])
            match_stage['description'] = re.compile(regex_str, re.IGNORECASE)

    pipeline = []
    if match_stage:
        pipeline.append({'$match': match_stage})

    pipeline.append({
        '$group': {
            '_id': '$currency',
            'totalAmount': {'$sum': '$amount'},
            'count': {'$sum': 1},
            'minAmount': {'$min': '$amount'},
            'maxAmount': {'$max': '$amount'},
            'minDate': {'$min': '$timestamp'},
            'maxDate': {'$max': '$timestamp'}
        }
    })

    results = list(db.transactions.aggregate(pipeline))

    if not results:
        return jsonify({'total_count': 0, 'totals_by_currency': []})

    overall_min_date = None
    overall_max_date = None

    summary = {
        'total_count': 0,
        'totals_by_currency': []
    }

    for res in results:
        currency = res['_id']
        count = res['count']
        total = res['totalAmount']

        if not overall_min_date or res['minDate'] < overall_min_date:
            overall_min_date = res['minDate']
        if not overall_max_date or res['maxDate'] > overall_max_date:
            overall_max_date = res['maxDate']

        summary['total_count'] += count
        summary['totals_by_currency'].append({
            'currency': currency,
            'count': count,
            'total': total,
            'avg': total / count,
            'min': res['minAmount'],
            'max': res['maxAmount']
        })

    summary['earliest_log_utc'] = overall_min_date.isoformat() if overall_min_date else None
    summary['latest_log_utc'] = overall_max_date.isoformat() if overall_max_date else None

    return jsonify(summary)


@analytics_bp.route('/report/detailed', methods=['GET'])
def get_detailed_report():
    """Generates a detailed report for the authenticated user."""
    db = get_db()

    user_id, error = get_user_id_from_request()
    if error: return error

    start_date_str = request.args.get('start_date')
    end_date_str = request.args.get('end_date')

    try:
        if start_date_str and end_date_str:
            start_date_local_obj = datetime.fromisoformat(start_date_str).date()
            end_date_local_obj = datetime.fromisoformat(end_date_str).date()
            aware_start_local = datetime.combine(start_date_local_obj, time.min, tzinfo=PHNOM_PENH_TZ)
            aware_end_local = datetime.combine(end_date_local_obj, time.max, tzinfo=PHNOM_PENH_TZ)
            start_date_utc = aware_start_local.astimezone(UTC_TZ)
            end_date_utc = aware_end_local.astimezone(UTC_TZ)
        else:
            end_date_utc = datetime.now(UTC_TZ)
            start_date_utc = end_date_utc - timedelta(days=30)
            start_date_local_obj = (end_date_utc - timedelta(days=30)).astimezone(PHNOM_PENH_TZ).date()
            end_date_local_obj = end_date_utc.astimezone(PHNOM_PENH_TZ).date()
    except (ValueError, TypeError):
        return jsonify({"error": "Invalid date format. Use YYYY-MM-DD."}), 400

    # --- THIS IS THE FIX ---
    try:
        initial_balance_in_usd, user_rate = _get_user_financial_base(db, user_id)
    except Exception as e:
        return jsonify({"error": f"Could not load user settings: {str(e)}"}), 404
    # --- END FIX ---

    user_match = {'user_id': user_id}

    add_fields_stage = {
        '$addFields': {
            'amount_in_usd': {
                '$cond': {
                    'if': {'$eq': ['$currency', 'USD']},
                    'then': '$amount',
                    'else': {
                        '$let': {
                            'vars': {'rate': {'$ifNull': ['$exchangeRateAtTime', user_rate]}}, # Use user's rate
                            'in': {'$cond': {'if': {'$gt': ['$$rate', 0]}, 'then': {'$divide': ['$amount', '$$rate']},
                                             'else': {'$divide': ['$amount', user_rate]}}}
                        }
                    }
                }
            }
        }
    }

    # --- Balance at Start Calculation ---
    start_balance_pipeline = [
        {'$match': {'timestamp': {'$lt': start_date_utc}, **user_match}},
        add_fields_stage,
        {'$group': {'_id': '$type', 'totalUSD': {'$sum': '$amount_in_usd'}}}
    ]
    start_balance_data = list(db.transactions.aggregate(start_balance_pipeline))
    start_income = next((item['totalUSD'] for item in start_balance_data if item['_id'] == 'income'), 0)
    start_expense = next((item['totalUSD'] for item in start_balance_data if item['_id'] == 'expense'), 0)

    # --- THIS IS THE FIX ---
    # The starting balance is the Initial Balance + all transactions before the start date
    balance_at_start_usd = initial_balance_in_usd + start_income - start_expense
    # --- END FIX ---

    # --- Pipelines for the selected period ---
    date_range_match = {'timestamp': {'$gte': start_date_utc, '$lte': end_date_utc}}

    # Operational data (Exclude financial categories)
    operational_pipeline = [
        {'$match': {**date_range_match, 'categoryId': {'$nin': FINANCIAL_TRANSACTION_CATEGORIES}, **user_match}},
        add_fields_stage,
        {'$group': {'_id': {'type': '$type', 'category': '$categoryId'}, 'total': {'$sum': '$amount_in_usd'}}},
        {'$sort': {'total': -1}}
    ]

    # Financial data
    financial_pipeline = [
        {'$match': {**date_range_match, 'categoryId': {'$in': FINANCIAL_TRANSACTION_CATEGORIES}, **user_match}},
        add_fields_stage,
        {'$group': {'_id': '$categoryId', 'total': {'$sum': '$amount_in_usd'}}}
    ]

    # Total cash flow (Used for calculating end balance correctly)
    total_flow_pipeline = [
        {'$match': {**date_range_match, **user_match}},
        add_fields_stage,
        {'$group': {'_id': '$type', 'totalUSD': {'$sum': '$amount_in_usd'}}}
    ]

    # Spending Over Time
    spending_over_time_pipeline = [
        {'$match': {**date_range_match, 'type': 'expense', 'categoryId': {'$nin': FINANCIAL_TRANSACTION_CATEGORIES}, **user_match}},
        add_fields_stage,
        {
            '$project': {
                'date': {'$dateToString': {'format': '%Y-%m-%d', 'date': '$timestamp', 'timezone': 'Asia/Phnom_Penh'}},
                'amount_in_usd': '$amount_in_usd'
            }
        },
        {'$group': {'_id': '$date', 'total_spent_usd': {'$sum': '$amount_in_usd'}}},
        {'$sort': {'_id': 1}},
        {'$project': {'_id': 0, 'date': '$_id', 'total_spent_usd': '$total_spent_usd'}}
    ]

    # Daily Expense Stats
    daily_stats_pipeline = [
        {'$match': {**date_range_match, 'type': 'expense', 'categoryId': {'$nin': FINANCIAL_TRANSACTION_CATEGORIES}, **user_match}},
        add_fields_stage,
        {
            '$group': {
                '_id': {'$dateToString': {'format': '%Y-%m-%d', 'date': '$timestamp', 'timezone': 'Asia/Phnom_Penh'}},
                'total_spent_usd': {'$sum': '$amount_in_usd'}
            }
        },
        {'$sort': {'total_spent_usd': -1}},
    ]

    # Top Expense Item
    top_expense_pipeline = [
        {'$match': {**date_range_match, 'type': 'expense', 'categoryId': {'$nin': FINANCIAL_TRANSACTION_CATEGORIES}, **user_match}},
        add_fields_stage,
        {'$sort': {'amount_in_usd': -1}},
        {'$limit': 1},
        {
            '$project': {
                '_id': 0,
                'description': '$description',
                'category': '$categoryId',
                'amount_usd': '$amount_in_usd',
                'date': {'$dateToString': {'format': '%Y-%m-%d', 'date': '$timestamp', 'timezone': 'Asia/Phnom_Penh'}}
            }
        }
    ]

    # --- Execute All Pipelines ---
    operational_data = list(db.transactions.aggregate(operational_pipeline))
    financial_data = list(db.transactions.aggregate(financial_pipeline))
    total_flow_data = list(db.transactions.aggregate(total_flow_pipeline))
    spending_over_time_data = list(db.transactions.aggregate(spending_over_time_pipeline))
    daily_stats_data = list(db.transactions.aggregate(daily_stats_pipeline))
    top_expense_data = list(db.transactions.aggregate(top_expense_pipeline))

    # --- Assemble Report ---
    report = {
        "startDate": start_date_local_obj.isoformat(),
        "endDate": end_date_local_obj.isoformat(),
        "summary": {
            "totalIncomeUSD": 0, "totalExpenseUSD": 0, "netSavingsUSD": 0,
            "balanceAtStartUSD": balance_at_start_usd, "balanceAtEndUSD": 0
        },
        "financialSummary": {"totalLentUSD": 0, "totalBorrowedUSD": 0, "totalRepaidToYouUSD": 0,
                             "totalYouRepaidUSD": 0},
        "incomeBreakdown": [],
        "expenseBreakdown": [],
        "spendingOverTime": spending_over_time_data,
        "expenseInsights": {
            "topExpenseItem": top_expense_data[0] if top_expense_data else None,
            "mostExpensiveDay": daily_stats_data[0] if daily_stats_data else None,
            "leastExpensiveDay": daily_stats_data[-1] if daily_stats_data and (len(daily_stats_data) > 1 or daily_stats_data[0]['total_spent_usd'] > 0) else None
        }
    }

    # Populate Operational Summary
    for item in operational_data:
        if item['_id']['type'] == 'income':
            report['summary']['totalIncomeUSD'] += item['total']
            report['incomeBreakdown'].append({'category': item['_id']['category'], 'totalUSD': item['total']})
        elif item['_id']['type'] == 'expense':
            report['summary']['totalExpenseUSD'] += item['total']
            report['expenseBreakdown'].append({'category': item['_id']['category'], 'totalUSD': item['total']})
    report['summary']['netSavingsUSD'] = report['summary']['totalIncomeUSD'] - report['summary']['totalExpenseUSD']

    # Populate Financial Summary
    for item in financial_data:
        category_map = {
            'Loan Lent': 'totalLentUSD', 'Loan Received': 'totalBorrowedUSD',
            'Debt Settled': 'totalRepaidToYouUSD', 'Debt Repayment': 'totalYouRepaidUSD'
        }
        if item['_id'] in category_map:
            report['financialSummary'][category_map[item['_id']]] += item['total']

    # Calculate correct Ending Balance
    total_income_in_period = next((item['totalUSD'] for item in total_flow_data if item['_id'] == 'income'), 0)
    total_expense_in_period = next((item['totalUSD'] for item in total_flow_data if item['_id'] == 'expense'), 0)
    report['summary']['balanceAtEndUSD'] = balance_at_start_usd + total_income_in_period - total_expense_in_period

    return jsonify(report)


@analytics_bp.route('/habits', methods=['GET'])
def get_spending_habits():
    """Analyzes spending habits for the authenticated user."""
    db = get_db()

    user_id, error = get_user_id_from_request()
    if error: return error

    start_date_str = request.args.get('start_date')
    end_date_str = request.args.get('end_date')

    try:
        if start_date_str and end_date_str:
            start_date_local_obj = datetime.fromisoformat(start_date_str).date()
            end_date_local_obj = datetime.fromisoformat(end_date_str).date()
            aware_start_local = datetime.combine(start_date_local_obj, time.min, tzinfo=PHNOM_PENH_TZ)
            aware_end_local = datetime.combine(end_date_local_obj, time.max, tzinfo=PHNOM_PENH_TZ)
            start_date_utc = aware_start_local.astimezone(UTC_TZ)
            end_date_utc = aware_end_local.astimezone(UTC_TZ)
        else:
            end_date_utc = datetime.now(UTC_TZ)
            start_date_utc = end_date_utc - timedelta(days=30)
    except (ValueError, TypeError):
        return jsonify({"error": "Invalid date format."}), 400

    try:
        _, user_rate = _get_user_financial_base(db, user_id)
    except Exception as e:
        return jsonify({"error": f"Could not load user settings: {str(e)}"}), 404

    user_match = {'user_id': user_id}

    add_fields_stage = {
        '$addFields': {
            'amount_in_usd': {
                '$cond': {
                    'if': {'$eq': ['$currency', 'USD']},
                    'then': '$amount',
                    'else': {
                        '$let': {
                            'vars': {'rate': {'$ifNull': ['$exchangeRateAtTime', user_rate]}},
                            'in': {'$cond': {'if': {'$gt': ['$$rate', 0]}, 'then': {'$divide': ['$amount', '$$rate']},
                                             'else': {'$divide': ['$amount', user_rate]}}}
                        }
                    }
                }
            }
        }
    }

    day_of_week_pipeline = [
        {'$match': {'timestamp': {'$gte': start_date_utc, '$lte': end_date_utc}, 'type': 'expense', **user_match}},
        add_fields_stage,
        {'$group': {
            '_id': {'$dayOfWeek': {'date': '$timestamp', 'timezone': 'Asia/Phnom_Penh'}},
            'totalAmount': {'$sum': '$amount_in_usd'}
        }},
        {'$sort': {'_id': 1}},
        {'$project': {
            '_id': 0,
            'day': {'$switch': {'branches': [
                {'case': {'$eq': ["$_id", 1]}, 'then': 'Sunday'},
                {'case': {'$eq': ["$_id", 2]}, 'then': 'Monday'},
                {'case': {'$eq': ["$_id", 3]}, 'then': 'Tuesday'},
                {'case': {'$eq': ["$_id", 4]}, 'then': 'Wednesday'},
                {'case': {'$eq': ["$_id", 5]}, 'then': 'Thursday'},
                {'case': {'$eq': ["$_id", 6]}, 'then': 'Friday'},
                {'case': {'$eq': ["$_id", 7]}, 'then': 'Saturday'}
            ]}},
            'total': '$totalAmount'
        }}
    ]

    keywords_pipeline = [
        {'$match': {
            'timestamp': {'$gte': start_date_utc, '$lte': end_date_utc},
            'type': 'expense',
            'description': {'$exists': True, '$ne': ''},
            **user_match
        }},
        {'$group': {
            '_id': {'category': '$categoryId', 'keyword': {'$toLower': '$description'}},
            'count': {'$sum': 1}
        }},
        {'$sort': {'count': -1}},
        {'$group': {
            '_id': '$_id.category',
            'topKeywordsWithCount': {'$push': {'keyword': '$_id.keyword', 'count': '$count'}}
        }},
        {'$project': {
            '_id': 0, 'category': '$_id',
            'topKeywords': {'$slice': ['$topKeywordsWithCount.keyword', 3]}
        }}
    ]

    habits = {
        'byDayOfWeek': list(db.transactions.aggregate(day_of_week_pipeline)),
        'keywordsByCategory': list(db.transactions.aggregate(keywords_pipeline))
    }
    return jsonify(habits)
# --- End of modified file ---

============================================================

==================== FILE: web_service/app/auth/__init__.py ====================


============================================================

==================== FILE: web_service/app/auth/routes.py ====================
# --- Start of file: web_service/app/auth/routes.py ---

from flask import Blueprint, request, jsonify
from datetime import datetime
from bson import ObjectId
from app import get_db
from zoneinfo import ZoneInfo
import logging

log = logging.getLogger(__name__)

auth_bp = Blueprint('auth', __name__, url_prefix='/auth')
UTC_TZ = ZoneInfo("UTC")

# --- ADMIN CONSTANTS REMOVED ---
# All users are now treated equally upon creation.

DEFAULT_EXPENSE_CATEGORIES = [
    "Food", "Drink", "Transport", "Shopping", "Bills", "Utilities",
    "Entertainment", "Personal Care", "Work", "Alcohol", "For Others",
    "Health", "Investment", "Forgot"
]
DEFAULT_INCOME_CATEGORIES = [
    "Salary", "Bonus", "Freelance", "Commission", "Allowance", "Gift",
    "Investment"
]


def get_default_settings_for_user():
    """
    Generates the default user profile document for any new user.
    All users start as 'user' and 'inactive'.
    """
    # No more admin check. Everyone gets the same default document.
    return {
        "name_en": None,
        "name_km": None,
        "role": "user",
        "subscription_status": "inactive",
        "settings": {
            "language": None,
            "currency_mode": None,
            "primary_currency": None,
            "rate_preference": "live",
            "fixed_rate": 4100,
            "notification_chat_ids": {
                "reminder": None,
                "report": None
            },
            "initial_balances": {"USD": 0, "KHR": 0},
            "categories": {
                "expense": DEFAULT_EXPENSE_CATEGORIES,
                "income": DEFAULT_INCOME_CATEGORIES
            }
        }
    }


def serialize_user(user):
    """Serializes user document for JSON, converting ObjectId."""
    if '_id' in user:
        user['_id'] = str(user['_id'])
    return user


@auth_bp.route('/find_or_create', methods=['POST'])
def find_or_create_user():
    """
    This is the primary authentication endpoint for the bot.
    It finds a user by their telegram_id or creates them if they don't exist.
    Access is gated *only* by subscription_status.
    """
    try:
        db = get_db()
    except Exception as e:
        return jsonify({"error": "Failed to connect to database", "details": str(e)}), 500

    data = request.json
    telegram_user_id = data.get('telegram_user_id')

    if not telegram_user_id:
        return jsonify({"error": "telegram_user_id is required"}), 400

    telegram_user_id = str(telegram_user_id)
    user = None

    try:
        user = db.users.find_one({"telegram_user_id": telegram_user_id})
    except Exception as e:
        return jsonify({"error": "Database query failed", "details": str(e)}), 500

    if not user:
        # Get the standard default profile for a new user
        default_profile = get_default_settings_for_user()

        new_user_doc = {
            "telegram_user_id": telegram_user_id,
            "created_at": datetime.now(UTC_TZ),
            "onboarding_complete": False,
            **default_profile
        }

        try:
            result = db.users.insert_one(new_user_doc)
            user = db.users.find_one({"_id": result.inserted_id})
        except Exception as e:
            return jsonify({"error": "Database insert failed", "details": str(e)}), 500

    if not user:
        return jsonify({"error": "Failed to find or create user"}), 500

    # --- MODIFIED ACCESS CHECK ---
    # We no longer check for 'admin' role. All bot access, for all users,
    # is gated *only* by the subscription_status.
    if user['subscription_status'] != 'active':
        error_msg = (
            "ðŸš« Subscription not active.\n"
            "ðŸš« áž€áž¶ážšáž‡áž¶ážœ (Subscription) áž˜áž·áž“áž‘áž¶áž“áŸ‹ážŠáŸ†ážŽáž¾ážšáž€áž¶ážšáž‘áŸáŸ”\n\n"
            "ážŸáž¼áž˜áž‘áž¶áž€áŸ‹áž‘áž„ @pr0meth4us ážŠáž¾áž˜áŸ’áž”áž¸áž’áŸ’ážœáž¾áž€áž¶ážšáž‡áž¶ážœ áž“áž·áž„áž”áŸ’ážšáž¾áž”áŸ’ážšáž¶ážŸáŸ‹ Bot áž“áŸáŸ‡áŸ”\n"
            "For subscription info, please contact: @pr0meth4us"
        )
        return jsonify({"error": error_msg}), 403
    # --- END MODIFICATION ---

    return jsonify(serialize_user(user))
# --- End of file ---

============================================================

==================== FILE: web_service/app/config.py ====================
# --- web_service/app/config.py (FULL) ---

import os

class Config:
    SECRET_KEY = os.getenv("SECRET_KEY")
    MONGODB_URI = os.getenv("MONGODB_URI", "").strip()
    DB_NAME = os.getenv("DB_NAME", "expTracker").strip()
    EXCHANGERATE_API_KEY = os.getenv("EXCHANGERATE_API_KEY", "").strip()
    TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN", "").strip()
    TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID", "").strip()

    @staticmethod
    def validate():
        missing = []
        if not Config.MONGODB_URI:
            missing.append("MONGODB_URI")
        if not Config.DB_NAME:
            missing.append("DB_NAME")
        if not Config.EXCHANGERATE_API_KEY:
            missing.append("EXCHANGERATE_API_KEY")
        if missing:
            print(f"[Config] Missing env vars: {', '.join(missing)}")

============================================================

==================== FILE: web_service/app/debts/__init__.py ====================


============================================================

==================== FILE: web_service/app/debts/routes.py ====================
# --- Start of modified file: web_service/app/debts/routes.py ---
"""
Handles all API endpoints related to IOU/Debt management.
All endpoints are multi-tenant and require a valid user_id.
"""
from flask import Blueprint, request, jsonify
from datetime import datetime
from bson import ObjectId
import re
from zoneinfo import ZoneInfo
from app.utils.currency import get_live_usd_to_khr_rate
from app import get_db
# --- MODIFICATION: Import the new auth helper ---
from app.utils.auth import get_user_id_from_request

debts_bp = Blueprint('debts', __name__, url_prefix='/debts')
UTC_TZ = ZoneInfo("UTC")


def serialize_debt(doc):
    """Serializes a debt document from MongoDB for JSON responses."""
    if '_id' in doc:
        doc['_id'] = str(doc['_id'])
    if 'user_id' in doc:
        doc['user_id'] = str(doc['user_id'])
    if 'created_at' in doc and isinstance(doc['created_at'], datetime):
        doc['created_at'] = doc['created_at'].isoformat()
    if 'associated_transaction_id' in doc and isinstance(doc['associated_transaction_id'], ObjectId):
        doc['associated_transaction_id'] = str(doc['associated_transaction_id'])
    if 'repayments' in doc:
        for rep in doc['repayments']:
            if 'date' in rep and isinstance(rep['date'], datetime):
                rep['date'] = rep['date'].isoformat()
    return doc


def get_db_rate(db, user_id):
    """
    Helper to fetch the stored KHR rate from a user's settings.
    This is now user-specific.
    """
    # Note: This logic will be fully enabled in the Settings refactor.
    # For now, we'll assume a global setting or a simple fallback.
    settings = db.settings.find_one({'user_id': user_id, '_id': 'config'})
    if settings and 'khr_to_usd_rate' in settings:
        rate = float(settings['khr_to_usd_rate'])
        if rate > 0:
            return rate
    return 4100.0  # Default fallback


@debts_bp.route('/', methods=['POST'])
def add_debt():
    """Adds a new debt for the authenticated user."""
    db = get_db()

    # --- MODIFICATION: Authenticate user ---
    user_id, error = get_user_id_from_request()
    if error: return error
    # ---

    data = request.json
    if not all(k in data for k in ['type', 'person', 'amount', 'currency']):
        return jsonify({'error': 'Missing required fields'}), 400

    try:
        amount = float(data['amount'])
    except ValueError:
        return jsonify({'error': 'Amount must be a number'}), 400

    timestamp_str = data.get('timestamp')
    created_at = datetime.fromisoformat(timestamp_str) if timestamp_str else datetime.now(UTC_TZ)
    account_name = f"{data['currency']} Account"

    tx_data = {
        "user_id": user_id, # <-- MODIFICATION: Add user_id
        "amount": amount,
        "currency": data['currency'],
        "accountName": account_name,
        "timestamp": created_at,
        "description": f"Loan {data['type']} {data['person']}"
    }

    if data['type'] == 'lent':
        tx_data['type'], tx_data['categoryId'] = 'expense', 'Loan Lent'
    else:
        tx_data['type'], tx_data['categoryId'] = 'income', 'Loan Received'

    tx_result = db.transactions.insert_one(tx_data)
    tx_id = tx_result.inserted_id

    debt = {
        "user_id": user_id, # <-- MODIFICATION: Add user_id
        "type": data['type'],
        "person": data['person'].strip().title(),
        "originalAmount": amount,
        "remainingAmount": amount,
        "currency": data['currency'],
        "status": "open",
        "purpose": data.get("purpose", ""),
        "repayments": [],
        "created_at": created_at,
        "associated_transaction_id": tx_id
    }

    result = db.debts.insert_one(debt)
    return jsonify({'message': 'Debt recorded', 'id': str(result.inserted_id)}), 201


@debts_bp.route('/', methods=['GET'])
def get_open_debts():
    """Fetches and groups open debts for the authenticated user."""
    db = get_db()

    # --- MODIFICATION: Authenticate user ---
    user_id, error = get_user_id_from_request()
    if error: return error
    # ---

    pipeline = [
        {'$match': {'status': 'open', 'user_id': user_id}}, # <-- MODIFICATION
        {'$group': {
            '_id': {'person_normalized': {'$toLower': '$person'}, 'currency': '$currency', 'type': '$type'},
            'person_display': {'$first': '$person'},
            'totalAmount': {'$sum': '$remainingAmount'},
            'count': {'$sum': 1}
        }},
        {'$group': {
            '_id': {'person_normalized': '$_id.person_normalized', 'type': '$_id.type'},
            'person_display': {'$first': '$person_display'},
            'totals': {'$push': {'currency': '$_id.currency', 'total': '$totalAmount', 'count': '$count'}}
        }},
        {'$project': {
            '_id': 0,
            'person': '$person_display',
            'type': '$_id.type',
            'totals': '$totals'
        }},
        {'$sort': {'person': 1}}
    ]
    grouped_debts = list(db.debts.aggregate(pipeline))
    return jsonify(grouped_debts)


# --- NEW EXPORT ENDPOINT ---
@debts_bp.route('/export/open', methods=['GET'])
def get_open_debts_export_list():
    """Fetches a simple flat list of all open debts for export."""
    db = get_db()
    user_id, error = get_user_id_from_request()
    if error: return error

    query_filter = {
        'status': 'open',
        'user_id': user_id
    }
    debts = list(db.debts.find(query_filter).sort('created_at', 1))
    return jsonify([serialize_debt(d) for d in debts])
# --- END NEW ENDPOINT ---


@debts_bp.route('/list/settled', methods=['GET'])
def get_settled_debts_grouped():
    """Fetches and groups settled OR canceled debts for the authenticated user."""
    db = get_db()

    # --- MODIFICATION: Authenticate user ---
    user_id, error = get_user_id_from_request()
    if error: return error
    # ---

    pipeline = [
        {'$match': {
            'status': {'$in': ['settled', 'canceled']},
            'user_id': user_id  # <-- MODIFICATION
        }},
        {'$group': {
            '_id': {'person_normalized': {'$toLower': '$person'}, 'currency': '$currency', 'type': '$type'},
            'person_display': {'$first': '$person'},
            'totalAmount': {'$sum': '$originalAmount'},
            'count': {'$sum': 1}
        }},
        {'$group': {
            '_id': {'person_normalized': '$_id.person_normalized', 'type': '$_id.type'},
            'person_display': {'$first': '$person_display'},
            'totals': {'$push': {'currency': '$_id.currency', 'total': '$totalAmount', 'count': '$count'}}
        }},
        {'$project': {
            '_id': 0,
            'person': '$person_display',
            'type': '$_id.type',
            'totals': '$totals'
        }},
        {'$sort': {'person': 1}}
    ]
    grouped_debts = list(db.debts.aggregate(pipeline))
    return jsonify(grouped_debts)


@debts_bp.route('/<debt_id>', methods=['GET'])
def get_debt_details(debt_id):
    """Fetches details for a single debt owned by the authenticated user."""
    db = get_db()

    # --- MODIFICATION: Authenticate user ---
    user_id, error = get_user_id_from_request()
    if error: return error
    # ---

    debt = db.debts.find_one({
        '_id': ObjectId(debt_id),
        'user_id': user_id # <-- MODIFICATION
    })

    if not debt:
        return jsonify({'error': 'Debt not found or access denied'}), 404
    return jsonify(serialize_debt(debt))


@debts_bp.route('/person/<person_name>/<currency>', methods=['GET'])
def get_debts_by_person_and_currency(person_name, currency):
    """Fetches debts by person/currency for the authenticated user."""
    db = get_db()

    # --- MODIFICATION: Authenticate user ---
    user_id, error = get_user_id_from_request()
    if error: return error
    # ---

    query_filter = {
        'person': re.compile(f'^{re.escape(person_name)}$', re.IGNORECASE),
        'currency': currency,
        'status': 'open',
        'user_id': user_id # <-- MODIFICATION
    }
    debts = list(db.debts.find(query_filter).sort('created_at', 1))
    return jsonify([serialize_debt(d) for d in debts])


@debts_bp.route('/person/<person_name>/all', methods=['GET'])
def get_all_debts_by_person(person_name):
    """Fetches all open debts for a person, for the authenticated user."""
    db = get_db()

    # --- MODIFICATION: Authenticate user ---
    user_id, error = get_user_id_from_request()
    if error: return error
    # ---

    query_filter = {
        'person': re.compile(f'^{re.escape(person_name)}$', re.IGNORECASE),
        'status': 'open',
        'user_id': user_id # <-- MODIFICATION
    }
    debts = list(db.debts.find(query_filter).sort('created_at', 1))
    return jsonify([serialize_debt(d) for d in debts])


@debts_bp.route('/person/<person_name>/all/settled', methods=['GET'])
def get_all_settled_debts_by_person(person_name):
    """Fetches all settled debts for a person, for the authenticated user."""
    db = get_db()

    # --- MODIFICATION: Authenticate user ---
    user_id, error = get_user_id_from_request()
    if error: return error
    # ---

    query_filter = {
        'person': re.compile(f'^{re.escape(person_name)}$', re.IGNORECASE),
        'status': {'$in': ['settled', 'canceled']},
        'user_id': user_id # <-- MODIFICATION
    }
    debts = list(db.debts.find(query_filter).sort('created_at', 1))
    return jsonify([serialize_debt(d) for d in debts])


@debts_bp.route('/person/<payment_currency>/repay', methods=['POST'])
def record_lump_sum_repayment(payment_currency):
    """Handles a lump-sum repayment for the authenticated user."""
    data = request.json
    db = get_db()

    # --- MODIFICATION: Authenticate user ---
    user_id, error = get_user_id_from_request()
    if error: return error
    # ---

    if 'amount' not in data or 'type' not in data or 'person' not in data:
        return jsonify({'error': 'Repayment amount, type, and person are required'}), 400

    debt_type = data['type']
    person_name = data['person']

    if debt_type not in ['lent', 'borrowed']:
        return jsonify({'error': "Invalid debt type, must be 'lent' or 'borrowed'"}), 400

    try:
        payment_amount = float(data['amount'])
        if payment_amount <= 0: return jsonify({'error': 'Amount must be a positive number'}), 400
    except (ValueError, TypeError):
        return jsonify({'error': 'Amount must be a number'}), 400

    timestamp_str = data.get('timestamp')
    payment_time_utc = datetime.fromisoformat(timestamp_str) if timestamp_str else datetime.now(UTC_TZ)

    # --- CROSS-CURRENCY LOGIC (Now user-specific) ---
    query_filter = {
        'person': re.compile(f'^{re.escape(person_name)}$', re.IGNORECASE),
        'currency': payment_currency,
        'status': 'open',
        'type': debt_type,
        'user_id': user_id # <-- MODIFICATION
    }
    debts_to_process = list(db.debts.find(query_filter).sort('created_at', 1))

    debt_currency = payment_currency
    converted_payment_amount = payment_amount

    if not debts_to_process:
        alternate_currency = 'USD' if payment_currency == 'KHR' else 'KHR'
        query_filter['currency'] = alternate_currency
        alternate_debts = list(db.debts.find(query_filter).sort('created_at', 1))

        if not alternate_debts:
            return jsonify({'error': f'No open {debt_type} debts found for {person_name} in any currency'}), 404

        debts_to_process = alternate_debts
        debt_currency = alternate_currency

        # TODO: This should use the user's rate preference
        rate = get_live_usd_to_khr_rate()

        if payment_currency == 'KHR' and debt_currency == 'USD':
            converted_payment_amount = payment_amount / rate
        elif payment_currency == 'USD' and debt_currency == 'KHR':
            converted_payment_amount = payment_amount * rate
        else:
            return jsonify({'error': 'Currency conversion error'}), 500

    # --- REPAYMENT AND INTEREST LOGIC ---
    total_remaining_debt = sum(d['remainingAmount'] for d in debts_to_process)
    interest_amount = 0
    amount_to_apply_to_principal = converted_payment_amount

    if converted_payment_amount > total_remaining_debt + 0.001:
        interest_amount = converted_payment_amount - total_remaining_debt
        amount_to_apply_to_principal = total_remaining_debt

        if debt_type == 'lent':
            interest_tx_type, interest_category = "income", "Loan Interest"
            interest_desc = f"Interest from {person_name}"
        else:
            interest_tx_type, interest_category = "expense", "Interest Expense"
            interest_desc = f"Interest paid to {person_name}"

        interest_tx = {
            "user_id": user_id, # <-- MODIFICATION
            "type": interest_tx_type,
            "amount": interest_amount,
            "currency": debt_currency,
            "categoryId": interest_category,
            "accountName": f"{debt_currency} Account",
            "description": interest_desc,
            "timestamp": payment_time_utc
        }
        db.transactions.insert_one(interest_tx)

    amount_left_to_apply = amount_to_apply_to_principal
    for debt in debts_to_process:
        if amount_left_to_apply <= 0: break
        repayment_for_this_debt = min(amount_left_to_apply, debt['remainingAmount'])
        new_remaining = debt['remainingAmount'] - repayment_for_this_debt
        new_status = 'settled' if new_remaining <= 0.001 else 'open'

        db.debts.update_one(
            {'_id': debt['_id'], 'user_id': user_id}, # <-- MODIFICATION
            {
                '$inc': {'remainingAmount': -repayment_for_this_debt},
                '$push': {'repayments': {'amount': repayment_for_this_debt, 'date': payment_time_utc}},
                '$set': {'status': new_status}
            }
        )
        amount_left_to_apply -= repayment_for_this_debt

    tx_category = 'Debt Settled' if debt_type == 'lent' else 'Debt Repayment'
    tx_type = 'income' if debt_type == 'lent' else 'expense'
    tx_desc = f"Repayment from {person_name}" if debt_type == 'lent' else f"Repayment to {person_name}"

    tx = {
        "user_id": user_id, # <-- MODIFICATION
        "type": tx_type,
        "amount": payment_amount,
        "currency": payment_currency,
        "categoryId": tx_category,
        "accountName": f"{payment_currency} Account",
        "description": tx_desc,
        "timestamp": payment_time_utc
    }
    db.transactions.insert_one(tx)

    payment_format = ",.0f" if payment_currency == 'KHR' else ",.2f"
    debt_format = ",.0f" if debt_currency == 'KHR' else ",.2f"
    final_message = f"âœ… Repayment of {payment_amount:{payment_format}} {payment_currency} recorded for {person_name}."

    if debt_currency != payment_currency:
        final_message += f"\n(Converted to {converted_payment_amount:{debt_format}} {debt_currency} and applied to debt)."
    if interest_amount > 0:
        if debt_type == 'lent':
            final_message += f"\nThe debt of {total_remaining_debt:{debt_format}} {debt_currency} is now settled. The extra {interest_amount:{debt_format}} {debt_currency} was recorded as 'Loan Interest' income."
        else:
            final_message += f"\nThe debt of {total_remaining_debt:{debt_format}} {debt_currency} is now settled. The extra {interest_amount:{debt_format}} {debt_currency} was recorded as 'Interest Expense'."

    return jsonify({'message': final_message})


@debts_bp.route('/<debt_id>/cancel', methods=['POST'])
def cancel_debt(debt_id):
    """Cancels a debt and reverses the initial transaction for the authenticated user."""
    db = get_db()

    # --- MODIFICATION: Authenticate user ---
    user_id, error = get_user_id_from_request()
    if error: return error
    # ---

    try:
        debt = db.debts.find_one({
            '_id': ObjectId(debt_id),
            'user_id': user_id # <-- MODIFICATION
        })
        if not debt:
            return jsonify({'error': 'Debt not found or access denied'}), 404

        if debt['status'] == 'canceled':
            return jsonify({'error': 'Debt is already canceled'}), 400

        tx_id = debt.get('associated_transaction_id')
        if not tx_id:
            return jsonify({'error': 'Cannot cancel debt: No associated transaction found.'}), 500

        original_tx = db.transactions.find_one({
            '_id': ObjectId(tx_id),
            'user_id': user_id # <-- MODIFICATION
        })
        if not original_tx:
            return jsonify({'error': 'Cannot cancel debt: Original transaction not found.'}), 500

        reverse_type = 'income' if original_tx['type'] == 'expense' else 'expense'
        reverse_desc = f"Reversal for Canceled Debt: {original_tx['description']}"

        reverse_tx = {
            "user_id": user_id, # <-- MODIFICATION
            "type": reverse_type,
            "amount": original_tx['amount'],
            "currency": original_tx['currency'],
            "categoryId": "Canceled Debt",
            "accountName": original_tx['accountName'],
            "description": reverse_desc,
            "timestamp": datetime.now(UTC_TZ)
        }
        db.transactions.insert_one(reverse_tx)

        db.debts.update_one(
            {'_id': ObjectId(debt_id), 'user_id': user_id}, # <-- MODIFICATION
            {'$set': {'status': 'canceled', 'remainingAmount': 0}}
        )

        return jsonify({'message': 'Debt canceled and transaction reversed.'})
    except Exception as e:
        return jsonify({'error': f'An error occurred: {str(e)}'}), 500


@debts_bp.route('/<debt_id>', methods=['PUT'])
def update_debt(debt_id):
    """Updates the person or purpose of a debt for the authenticated user."""
    db = get_db()

    # --- MODIFICATION: Authenticate user ---
    user_id, error = get_user_id_from_request()
    if error: return error
    # ---

    data = request.json
    if not data or not any(k in data for k in ['person', 'purpose']):
        return jsonify({'error': 'No valid fields (person, purpose) provided for update.'}), 400

    update_fields = {}
    if 'person' in data:
        update_fields['person'] = data['person'].strip().title()
    if 'purpose' in data:
        update_fields['purpose'] = data['purpose'].strip()

    result = db.debts.update_one(
        {'_id': ObjectId(debt_id), 'user_id': user_id}, # <-- MODIFICATION
        {'$set': update_fields}
    )

    if result.matched_count == 0:
        return jsonify({'error': 'Debt not found or access denied'}), 404

    return jsonify({'message': 'Debt updated successfully'})


@debts_bp.route('/analysis', methods=['GET'])
def get_debt_analysis():
    """Generates a debt analysis for the authenticated user."""
    db = get_db()

    # --- MODIFICATION: Authenticate user ---
    user_id, error = get_user_id_from_request()
    if error: return error
    # ---

    now = datetime.now(UTC_TZ)

    # Base match stage for all pipelines
    base_match = {'status': 'open', 'user_id': user_id}

    # --- Pipeline 1: Concentration (Top people) ---
    concentration_pipeline = [
        {'$match': base_match},
        {'$group': {
            '_id': {'person_normalized': {'$toLower': '$person'}, 'type': '$type'},
            'person_display': {'$first': '$person'},
            'totalAmount': {'$sum': '$remainingAmount'}
        }},
        {'$sort': {'totalAmount': -1}},
        {'$project': {'_id': 0, 'person': '$person_display', 'type': '$_id.type', 'total': '$totalAmount'}}
    ]

    # --- Pipeline 2: Aging (Oldest debts) ---
    aging_pipeline = [
        {'$match': base_match},
        {'$project': {
            'person': '$person',
            'age_in_days': {'$divide': [{'$subtract': [now, '$created_at']}, 1000 * 60 * 60 * 24]}
        }},
        {'$group': {
            '_id': {'$toLower': '$person'}, 'person_display': {'$first': '$person'},
            'averageAgeDays': {'$avg': '$age_in_days'}, 'count': {'$sum': 1}
        }},
        {'$project': {'_id': '$person_display', 'averageAgeDays': '$averageAgeDays', 'count': '$count'}},
        {'$sort': {'averageAgeDays': -1}}
    ]

    # --- Pipeline 3: Overview (Total Owed vs. Total Lent in USD) ---
    # TODO: This should use the user's rate preference
    rate = get_live_usd_to_khr_rate()
    overview_pipeline = [
        {'$match': base_match},
        {'$addFields': {
            'amount_in_usd': {
                '$cond': {
                    'if': {'$eq': ['$currency', 'USD']},
                    'then': '$remainingAmount',
                    'else': {'$divide': ['$remainingAmount', rate]}
                }
            }
        }},
        {'$group': {
            '_id': '$type',
            'total_usd': {'$sum': '$amount_in_usd'}
        }}
    ]

    # --- Execute Pipelines ---
    concentration_data = list(db.debts.aggregate(concentration_pipeline))
    aging_data = list(db.debts.aggregate(aging_pipeline))
    overview_data = list(db.debts.aggregate(overview_pipeline))

    # --- Format Response ---
    total_lent_usd = next((item['total_usd'] for item in overview_data if item['_id'] == 'lent'), 0)
    total_borrowed_usd = next((item['total_usd'] for item in overview_data if item['_id'] == 'borrowed'), 0)

    analysis = {
        'concentration': concentration_data,
        'aging': aging_data,
        'overview_usd': {
            'total_lent_usd': total_lent_usd,
            'total_borrowed_usd': total_borrowed_usd
        }
    }
    return jsonify(analysis)
# --- End of modified file ---

============================================================

==================== FILE: web_service/app/reminders/__init__.py ====================


============================================================

==================== FILE: web_service/app/reminders/routes.py ====================
# --- Start of modified file: web_service/app/reminders/routes.py ---
"""
Handles scheduling reminders for users.
All endpoints are multi-tenant and require a valid user_id.
"""
from flask import Blueprint, request, jsonify, current_app
from datetime import datetime
from app import send_telegram_message, get_db
# --- MODIFICATION: Import the new auth helper ---
from app.utils.auth import get_user_id_from_request

reminders_bp = Blueprint('reminders', __name__, url_prefix='/reminders')


@reminders_bp.route('/', methods=['POST'])
def add_reminder():
    """Schedules a new reminder for the authenticated user."""
    db = get_db()
    data = request.json

    # --- MODIFICATION: Authenticate user ---
    user_id, error = get_user_id_from_request()
    if error: return error
    # ---

    if not all(k in data for k in ['purpose', 'reminder_datetime', 'chat_id']):
        return jsonify({'error': 'Missing required fields'}), 400

    try:
        reminder_datetime = datetime.fromisoformat(data['reminder_datetime'])
    except ValueError:
        return jsonify({'error': 'Invalid datetime format'}), 400

    scheduler = current_app.scheduler
    token = current_app.config['TELEGRAM_TOKEN']
    message_text = f"ðŸ”” Reminder:\n\n{data['purpose']}"

    # Schedule a one-off job to send the reminder at the specified time
    scheduler.add_job(
        send_telegram_message,
        trigger='date',
        run_date=reminder_datetime,
        args=[data['chat_id'], message_text, token],
        id=f"reminder_{user_id}_{datetime.now().timestamp()}",  # Unique job ID
        name=f"Reminder for user {user_id}"
    )

    # --- MODIFICATION: Log the reminder in the database ---
    # This isn't strictly necessary for scheduling, but good for tracking.
    db.reminders.insert_one({
        "user_id": user_id,
        "purpose": data['purpose'],
        "chat_id": data['chat_id'],
        "reminder_datetime": reminder_datetime,
        "created_at": datetime.now()
    })
    # ---

    print(f"Scheduled a reminder for user {user_id} at {reminder_datetime}")
    return jsonify({'message': 'Reminder scheduled successfully'}), 201
# --- End of modified file ---

============================================================

==================== FILE: web_service/app/settings/__init__.py ====================


============================================================

==================== FILE: web_service/app/settings/routes.py ====================
# --- Start of file: web_service/app/settings/routes.py ---
"""
Handles user-specific settings.
All endpoints are multi-tenant and require a valid user_id.
"""
from flask import Blueprint, request, jsonify
from app.utils.currency import get_live_usd_to_khr_rate
from app import get_db
from app.utils.auth import get_user_id_from_request

settings_bp = Blueprint('settings', __name__, url_prefix='/settings')


@settings_bp.route('/', methods=['GET'])
def get_user_settings():
    """Fetches all settings for the authenticated user."""
    db = get_db()
    user_id, error = get_user_id_from_request()
    if error:
        return error

    user = db.users.find_one({'_id': user_id}, {'_id': 0, 'settings': 1, 'name_en': 1, 'name_km': 1})
    if not user:
        return jsonify({'error': 'User not found'}), 404

    return jsonify(user)


@settings_bp.route('/balance', methods=['POST'])
def update_initial_balance():
    """Updates the initial balance for a specific currency for a user."""
    db = get_db()
    user_id, error = get_user_id_from_request()
    if error:
        return error

    data = request.json
    if 'currency' not in data or 'amount' not in data:
        return jsonify({'error': 'Currency and amount are required'}), 400

    try:
        currency = str(data['currency']).upper()
        amount = float(data['amount'])
    except (ValueError, TypeError):
        return jsonify({'error': 'Invalid currency or amount format'}), 400

    update_key = f"settings.initial_balances.{currency}"
    result = db.users.update_one(
        {'_id': user_id},
        {'$set': {update_key: amount}}
    )

    if result.matched_count == 0:
        return jsonify({'error': 'User not found'}), 404

    return jsonify({
        'message': f'Initial balance for {currency} updated to {amount}'
    })


@settings_bp.route('/category', methods=['POST'])
def add_user_category():
    """Adds a new custom category for a user."""
    db = get_db()
    user_id, error = get_user_id_from_request()
    if error:
        return error

    data = request.json
    if 'type' not in data or 'name' not in data:
        return jsonify({'error': 'Type (expense/income) and name are required'}), 400

    category_type = data['type']
    category_name = data['name'].strip().title()

    if category_type not in ['expense', 'income']:
        return jsonify({'error': 'Invalid type'}), 400
    if not category_name:
        return jsonify({'error': 'Category name cannot be empty'}), 400

    update_key = f"settings.categories.{category_type}"
    result = db.users.update_one(
        {'_id': user_id},
        {'$addToSet': {update_key: category_name}}
    )

    if result.matched_count == 0:
        return jsonify({'error': 'User not found'}), 404

    return jsonify({
        'message': f'Category "{category_name}" added.'
    })


@settings_bp.route('/category', methods=['DELETE'])
def remove_user_category():
    """Removes a custom category for a user."""
    db = get_db()
    user_id, error = get_user_id_from_request()
    if error:
        return error

    data = request.json
    if 'type' not in data or 'name' not in data:
        return jsonify({'error': 'Type (expense/income) and name are required'}), 400

    category_type = data['type']
    category_name = data['name']

    if category_type not in ['expense', 'income']:
        return jsonify({'error': 'Invalid type'}), 400

    update_key = f"settings.categories.{category_type}"
    result = db.users.update_one(
        {'_id': user_id},
        {'$pull': {update_key: category_name}}
    )

    if result.matched_count == 0:
        return jsonify({'error': 'User not found'}), 404

    if result.modified_count == 0:
        return jsonify({'error': 'Category not found or not removed'}), 400

    return jsonify({
        'message': f'Category "{category_name}" removed.'
    })


@settings_bp.route('/rate', methods=['POST'])
def update_khr_rate():
    """Updates the user-specific fixed exchange rate."""
    data = request.json
    db = get_db()

    user_id, error = get_user_id_from_request()
    if error:
        return error

    if 'rate' not in data:
        return jsonify({'error': 'Rate is required'}), 400

    try:
        new_rate = float(data['rate'])
    except ValueError:
        return jsonify({'error': 'Rate must be a number'}), 400

    db.users.update_one(
        {'_id': user_id},
        {'$set': {
            'settings.rate_preference': 'fixed',
            'settings.fixed_rate': new_rate
        }}
    )

    return jsonify({
        'message': f'Exchange rate preference updated to fixed rate: {new_rate}'
    })


@settings_bp.route('/rate', methods=['GET'])
def get_khr_rate():
    """
    Fetches the KHR exchange rate based on the user's preference.
    """
    db = get_db()
    user_id, error = get_user_id_from_request()
    if error:
        return error

    user = db.users.find_one({'_id': user_id})
    if not user:
        return jsonify({'error': 'User not found'}), 404

    user_settings = user.get('settings', {})
    preference = user_settings.get('rate_preference', 'live')

    if preference == 'fixed':
        fixed_rate = user_settings.get('fixed_rate', 4100.0)
        return jsonify({'rate': fixed_rate, 'source': 'fixed'})

    live_rate = get_live_usd_to_khr_rate()
    return jsonify({'rate': live_rate, 'source': 'live'})


@settings_bp.route('/mode', methods=['POST'])
def update_user_mode():
    """
    Sets the user's currency mode, language, and names during onboarding.
    """
    db = get_db()
    user_id, error = get_user_id_from_request()
    if error:
        return error

    data = request.json
    mode = data.get('mode')
    name_en = data.get('name_en')

    if not mode or mode not in ['single', 'dual']:
        return jsonify({'error': 'Invalid mode. Must be "single" or "dual".'}), 400

    if not name_en:
        return jsonify({'error': 'name_en is required.'}), 400

    update_payload = {
        'settings.currency_mode': mode,
        'name_en': name_en
    }

    if mode == 'single':
        primary_currency = data.get('primary_currency')
        if not primary_currency:
            return jsonify({'error': 'primary_currency is required for single mode.'}), 400

        update_payload['settings.language'] = 'en'
        update_payload['settings.primary_currency'] = primary_currency.upper()

    elif mode == 'dual':
        language = data.get('language')
        name_km = data.get('name_km')
        if not language or language not in ['en', 'km']:
            return jsonify({'error': 'Invalid language for dual mode.'}), 400
        if not name_km:
            return jsonify({'error': 'name_km is required for dual mode.'}), 400

        update_payload['settings.language'] = language
        update_payload['name_km'] = name_km
        update_payload['settings.primary_currency'] = 'USD' # Default for dual

    result = db.users.update_one(
        {'_id': user_id},
        {'$set': update_payload}
    )

    if result.matched_count == 0:
        return jsonify({'error': 'User not found'}), 404

    return jsonify({'message': f'User mode set to {mode}.'})


@settings_bp.route('/complete_onboarding', methods=['POST'])
def complete_onboarding():
    """Marks the user's onboarding as complete."""
    db = get_db()
    user_id, error = get_user_id_from_request()
    if error:
        return error

    result = db.users.update_one(
        {'_id': user_id},
        {'$set': {'onboarding_complete': True}}
    )

    if result.matched_count == 0:
        return jsonify({'error': 'User not found'}), 404

    return jsonify({'message': 'Onboarding complete.'})

============================================================

==================== FILE: web_service/app/summary/__init__.py ====================


============================================================

==================== FILE: web_service/app/summary/routes.py ====================
# --- web_service/app/summary/routes.py (FULL) ---
"""
Handles the main summary endpoint for the bot.
All endpoints are multi-tenant and require a valid user_id.
"""
from flask import Blueprint, jsonify
from datetime import datetime, time, date, timedelta
from zoneinfo import ZoneInfo
from app import get_db
from app.utils.auth import get_user_id_from_request
from app.utils.currency import get_live_usd_to_khr_rate  # <-- ADD THIS IMPORT

summary_bp = Blueprint('summary', __name__, url_prefix='/summary')

FINANCIAL_TRANSACTION_CATEGORIES = [
    'Loan Lent',
    'Debt Repayment',
    'Loan Received',
    'Debt Settled'
]

PHNOM_PENH_TZ = ZoneInfo("Asia/Phnom_Penh")
UTC_TZ = ZoneInfo("UTC")


def create_utc_range(start_date_local, end_date_local):
    """Converts local start/end dates into a timezone-aware UTC range."""
    aware_start_dt = datetime.combine(
        start_date_local, time.min, tzinfo=PHNOM_PENH_TZ
    )
    aware_end_dt = datetime.combine(
        end_date_local, time.max, tzinfo=PHNOM_PENH_TZ
    )
    return aware_start_dt.astimezone(UTC_TZ), aware_end_dt.astimezone(UTC_TZ)


def get_date_ranges():
    """Helper function to get start and end datetimes for various periods."""
    today = datetime.now(PHNOM_PENH_TZ).date()

    start_of_week = today - timedelta(days=today.weekday())
    end_of_week = start_of_week + timedelta(days=6)
    end_of_last_week = start_of_week - timedelta(days=1)
    start_of_last_week = end_of_last_week - timedelta(days=6)
    start_of_month = today.replace(day=1)
    next_month = start_of_month.replace(day=28) + timedelta(days=4)
    end_of_month = next_month - timedelta(days=next_month.day)
    end_of_last_month = start_of_month - timedelta(days=1)
    start_of_last_month = end_of_last_month.replace(day=1)

    return {
        "today": create_utc_range(today, today),
        "this_week": create_utc_range(start_of_week, end_of_week),
        "last_week": create_utc_range(start_of_last_week, end_of_last_week),
        "this_month": create_utc_range(start_of_month, end_of_month),
        "last_month": create_utc_range(start_of_last_month, end_of_last_month),
    }


def calculate_period_summary(start_date, end_date, db, user_id, user_rate):
    """Helper to run aggregation for a specific time period for a user."""
    pipeline = [
        {'$match': {
            'timestamp': {'$gte': start_date, '$lte': end_date},
            'categoryId': {'$nin': FINANCIAL_TRANSACTION_CATEGORIES},
            'user_id': user_id
        }},
        {
            '$addFields': {
                'amount_in_usd': {
                    '$cond': {
                        'if': {'$eq': ['$currency', 'USD']},
                        'then': '$amount',
                        'else': {
                            '$let': {
                                'vars': {'rate': {'$ifNull': [
                                    '$exchangeRateAtTime', user_rate
                                ]}},
                                'in': {'$cond': {
                                    'if': {'$gt': ['$$rate', 0]},
                                    'then': {'$divide': ['$amount', '$$rate']},
                                    'else': {'$divide': ['$amount', user_rate]}
                                }}
                            }
                        }
                    }
                }
            }
        },
        {
            '$group': {
                '_id': {'type': '$type', 'currency': '$currency'},
                'total': {'$sum': '$amount'},
                'totalUSD': {'$sum': '$amount_in_usd'}
            }
        }
    ]
    results = list(db.transactions.aggregate(pipeline))

    period_summary = {
        'income': {}, 'expense': {}, 'net_usd': 0
    }
    total_income_usd = 0
    total_expense_usd = 0

    for item in results:
        trans_type = item['_id']['type']
        currency = item['_id']['currency']
        if trans_type in period_summary:
            period_summary[trans_type][currency] = item['total']

        if trans_type == 'income':
            total_income_usd += item['totalUSD']
        elif trans_type == 'expense':
            total_expense_usd += item['totalUSD']

    period_summary['net_usd'] = total_income_usd - total_expense_usd
    return period_summary


@summary_bp.route('/detailed', methods=['GET'])
def get_detailed_summary():
    """Generates the detailed summary for the authenticated user."""
    db = get_db()
    user_id, error = get_user_id_from_request()
    if error:
        return error

    # 1. Get User's Settings (Initial Balances, Mode, Currencies)
    user = db.users.find_one(
        {'_id': user_id},
        {'settings': 1}
    )
    if not user:
        return jsonify({'error': 'User not found'}), 404

    settings = user.get('settings', {})
    initial_balances = settings.get('initial_balances', {})
    mode = settings.get('currency_mode', 'dual')

    currencies_to_track = []
    if mode == 'single':
        currencies_to_track.append(settings.get('primary_currency', 'USD'))
    else:
        currencies_to_track = ['USD', 'KHR']

    # 2. Calculate Total Transaction Flow (Income & Expense)
    pipeline_transactions = [
        {'$match': {
            'user_id': user_id,
            'currency': {'$in': currencies_to_track}
        }},
        {'$group': {
            '_id': {'type': '$type', 'currency': '$currency'},
            'total': {'$sum': '$amount'}
        }}
    ]
    tx_results = list(db.transactions.aggregate(pipeline_transactions))

    # 3. Calculate Balances
    final_balances = {}
    for currency in currencies_to_track:
        initial = initial_balances.get(currency, 0)
        income = next((r['total'] for r in tx_results if r['_id']['type'] == 'income' and r['_id']['currency'] == currency), 0)
        expense = next((r['total'] for r in tx_results if r['_id']['type'] == 'expense' and r['_id']['currency'] == currency), 0)
        final_balances[currency] = initial + income - expense

    # 4. Calculate Debts
    pipeline_debts = [
        {'$match': {
            'status': 'open',
            'user_id': user_id,
            'currency': {'$in': currencies_to_track}
        }},
        {'$group': {
            '_id': {'type': '$type', 'currency': '$currency'},
            'totalAmount': {'$sum': '$remainingAmount'}
        }}
    ]
    debt_results = list(db.debts.aggregate(pipeline_debts))

    debts_owed_to_you = [
        {'total': d['totalAmount'], '_id': d['_id']['currency']}
        for d in debt_results if d['_id']['type'] == 'lent'
    ]
    debts_owed_by_you = [
        {'total': d['totalAmount'], '_id': d['_id']['currency']}
        for d in debt_results if d['_id']['type'] == 'borrowed'
    ]

    # 5. Calculate Period Summaries

    # Get user's rate for period calculations
    rate_preference = settings.get('rate_preference', 'live')
    user_rate = 4100.0
    if rate_preference == 'fixed':
        user_rate = settings.get('fixed_rate', 4100.0)
    else:
        user_rate = get_live_usd_to_khr_rate() # Simplified for summary

    date_ranges = get_date_ranges()
    period_summaries = {}
    for period, (start_utc, end_utc) in date_ranges.items():
        period_summaries[period] = calculate_period_summary(
            start_utc, end_utc, db, user_id, user_rate
        )

    # 6. Combine all data
    summary = {
        'balances': final_balances,
        'debts_owed_by_you': debts_owed_by_you,
        'debts_owed_to_you': debts_owed_to_you,
        'periods': period_summaries
    }

    return jsonify(summary)

# --- End of file ---

============================================================

==================== FILE: web_service/app/transactions/__init__.py ====================


============================================================

==================== FILE: web_service/app/transactions/routes.py ====================
# --- Start of modified file: web_service/app/transactions/routes.py ---

from flask import Blueprint, request, jsonify
from datetime import datetime, time, timedelta
from bson import ObjectId
from app.utils.currency import get_live_usd_to_khr_rate
import re
from zoneinfo import ZoneInfo
from app import get_db  # <-- IMPORT THE NEW FUNCTION

transactions_bp = Blueprint('transactions', __name__, url_prefix='/transactions')

PHNOM_PENH_TZ = ZoneInfo("Asia/Phnom_Penh")
UTC_TZ = ZoneInfo("UTC")


# --- NEW: Helper to get user_id and check for it ---
def get_user_id_from_request():
    """
    Gets user_id from request.json or request.args.
    Returns (user_id, error_response)
    """
    user_id = None
    if request.is_json:
        user_id = request.json.get('user_id')

    if not user_id:
        user_id = request.args.get('user_id')

    if not user_id:
        return None, (jsonify({'error': 'user_id is required'}), 401) # 401 Unauthorized

    try:
        # Validate that it's a proper ObjectId
        return ObjectId(user_id), None
    except Exception:
        return None, (jsonify({'error': 'Invalid user_id format'}), 400)


def get_date_ranges_for_search():
    """Helper to get UTC date ranges for search queries."""
    today = datetime.now(PHNOM_PENH_TZ).date()
    start_of_week = today - timedelta(days=today.weekday())
    start_of_month = today.replace(day=1)
    end_of_last_week = start_of_week - timedelta(days=1)
    start_of_last_week = end_of_last_week - timedelta(days=6)

    def create_utc_range(start_local, end_local):
        aware_start = datetime.combine(start_local, time.min, tzinfo=PHNOM_PENH_TZ)
        aware_end = datetime.combine(end_local, time.max, tzinfo=PHNOM_PENH_TZ)
        return aware_start.astimezone(UTC_TZ), aware_end.astimezone(UTC_TZ)

    return {
        "today": create_utc_range(today, today),
        "this_week": create_utc_range(start_of_week, start_of_week + timedelta(days=6)),
        "last_week": create_utc_range(start_of_last_week, end_of_last_week),
        "this_month": create_utc_range(start_of_month,
                                       (start_of_month.replace(day=28) + timedelta(days=4)).replace(day=1) - timedelta(
                                           days=1))
    }


def serialize_tx(tx):
    """
    Serializes a transaction document from MongoDB for JSON responses.
    Converts ObjectId and datetime to JSON-friendly string formats.
    """
    if '_id' in tx:
        tx['_id'] = str(tx['_id'])
    if 'timestamp' in tx and isinstance(tx['timestamp'], datetime):
        tx['timestamp'] = tx['timestamp'].isoformat()

    # --- MODIFICATION: Also serialize user_id if present ---
    if 'user_id' in tx:
        tx['user_id'] = str(tx['user_id'])

    return tx


@transactions_bp.route('/', methods=['POST'])
def add_transaction():
    """Adds a transaction for an authenticated user."""
    db = get_db()

    # --- MODIFICATION: Authenticate user ---
    user_id, error = get_user_id_from_request()
    if error: return error
    # ---

    data = request.json
    if not all(k in data for k in ['type', 'amount', 'currency', 'categoryId', 'accountName']):
        return jsonify({'error': 'Missing required fields'}), 400

    timestamp_str = data.get('timestamp')
    timestamp = datetime.fromisoformat(timestamp_str) if timestamp_str else datetime.now(UTC_TZ)

    tx = {
        "user_id": user_id, # <-- MODIFICATION: Add user_id
        "type": data['type'],
        "amount": float(data['amount']),
        "currency": data['currency'],
        "categoryId": data['categoryId'].strip().title(),
        "accountName": data['accountName'],
        "description": data.get('description', ''),
        "timestamp": timestamp
    }

    if tx['currency'] == 'KHR':
        tx['exchangeRateAtTime'] = get_live_usd_to_khr_rate()

    result = db.transactions.insert_one(tx)
    return jsonify({'message': 'Transaction added', 'id': str(result.inserted_id)}), 201


@transactions_bp.route('/recent', methods=['GET'])
def get_recent_transactions():
    """Fetches recent transactions for an authenticated user."""
    db = get_db()

    # --- MODIFICATION: Authenticate user ---
    user_id, error = get_user_id_from_request()
    if error: return error
    # ---

    limit = int(request.args.get('limit', 20))

    # --- MODIFICATION: Query is now user-specific ---
    txs = list(db.transactions.find({'user_id': user_id}).sort('timestamp', -1).limit(limit))
    # ---

    return jsonify([serialize_tx(tx) for tx in txs])


@transactions_bp.route('/search', methods=['POST'])
def search_transactions():
    """Performs an advanced search for an authenticated user."""
    params = request.json
    db = get_db()

    # --- MODIFICATION: Authenticate user ---
    user_id, error = get_user_id_from_request()
    if error: return error
    # ---

    # --- MODIFICATION: Add user_id to match_stage ---
    match_stage = {'user_id': user_id}
    # ---

    date_filter = {}
    if params.get('period'):
        ranges = get_date_ranges_for_search()
        if params['period'] in ranges:
            start_utc, end_utc = ranges[params['period']]
            date_filter['$gte'] = start_utc
            date_filter['$lte'] = end_utc
    elif params.get('start_date') and params.get('end_date'):
        start_local = datetime.fromisoformat(params['start_date']).date()
        end_local = datetime.fromisoformat(params['end_date']).date()
        aware_start = datetime.combine(start_local, time.min, tzinfo=PHNOM_PENH_TZ)
        aware_end = datetime.combine(end_local, time.max, tzinfo=PHNOM_PENH_TZ)
        date_filter['$gte'] = aware_start.astimezone(UTC_TZ)
        date_filter['$lte'] = aware_end.astimezone(UTC_TZ)

    if date_filter:
        match_stage['timestamp'] = date_filter

    if params.get('transaction_type'):
        match_stage['type'] = params['transaction_type']

    if params.get('categories'):
        categories_regex = [re.compile(f'^{re.escape(c.strip())}$', re.IGNORECASE) for c in params['categories']]
        match_stage['categoryId'] = {'$in': categories_regex}

    if params.get('keywords'):
        keywords = params['keywords']
        keyword_logic = params.get('keyword_logic', 'OR').upper()

        if keyword_logic == 'AND':
            match_stage['$and'] = [{'description': re.compile(k, re.IGNORECASE)} for k in keywords]
        else:
            regex_str = '|'.join([re.escape(k) for k in keywords])
            match_stage['description'] = re.compile(regex_str, re.IGNORECASE)

    results = list(db.transactions.find(match_stage).sort('timestamp', -1).limit(50))
    return jsonify([serialize_tx(tx) for tx in results])


@transactions_bp.route('/<tx_id>', methods=['GET'])
def get_transaction(tx_id):
    """Fetches a single transaction for an authenticated user."""
    db = get_db()

    # --- MODIFICATION: Authenticate user ---
    user_id, error = get_user_id_from_request()
    if error: return error
    # ---

    try:
        # --- MODIFICATION: Query is now user-specific ---
        transaction = db.transactions.find_one({'_id': ObjectId(tx_id), 'user_id': user_id})
        # ---

        if transaction:
            return jsonify(serialize_tx(transaction))
        else:
            return jsonify({'error': 'Transaction not found or access denied'}), 404
    except Exception as e:
        return jsonify({'error': str(e)}), 400


@transactions_bp.route('/<tx_id>', methods=['PUT'])
def update_transaction(tx_id):
    """Updates a transaction for an authenticated user."""
    data = request.json
    db = get_db()

    # --- MODIFICATION: Authenticate user ---
    user_id, error = get_user_id_from_request()
    if error: return error
    # ---

    if not data:
        return jsonify({'error': 'No update data provided'}), 400

    update_fields = {}
    allowed_fields = ['amount', 'categoryId', 'description', 'timestamp']

    for field in allowed_fields:
        if field in data:
            if field == 'amount':
                try:
                    update_fields[field] = float(data[field])
                except (ValueError, TypeError):
                    return jsonify({'error': 'Invalid amount format'}), 400
            elif field == 'categoryId':
                update_fields[field] = data[field].strip().title()
            elif field == 'timestamp':
                try:
                    update_fields[field] = datetime.fromisoformat(data[field])
                except (ValueError, TypeError):
                    return jsonify({'error': 'Invalid timestamp format'}), 400
            else:
                update_fields[field] = data[field]

    if not update_fields:
        return jsonify({'error': 'No valid fields to update'}), 400

    try:
        # --- MODIFICATION: Query is now user-specific ---
        result = db.transactions.update_one(
            {'_id': ObjectId(tx_id), 'user_id': user_id},
            {'$set': update_fields}
        )
        # ---

        if result.matched_count:
            return jsonify({'message': 'Transaction updated successfully'})
        else:
            return jsonify({'error': 'Transaction not found or access denied'}), 404
    except Exception as e:
        return jsonify({'error': str(e)}), 500


@transactions_bp.route('/<tx_id>', methods=['DELETE'])
def delete_transaction(tx_id):
    """Deletes a transaction for an authenticated user."""
    db = get_db()

    # --- MODIFICATION: Authenticate user ---
    # Note: user_id for DELETE comes from JSON body, not query param
    user_id, error = get_user_id_from_request()
    if error: return error
    # ---

    try:
        # --- MODIFICATION: Query is now user-specific ---
        result = db.transactions.delete_one({'_id': ObjectId(tx_id), 'user_id': user_id})
        # ---

        if result.deleted_count:
            return jsonify({'message': 'Transaction deleted'})
        else:
            return jsonify({'error': 'Transaction not found or access denied'}), 404
    except Exception as e:
        return jsonify({'error': str(e)}), 400
# --- End of modified file ---

============================================================

==================== FILE: web_service/app/utils/__init__.py ====================


============================================================

==================== FILE: web_service/app/utils/auth.py ====================
# --- Start of new file: web_service/app/utils/auth.py ---
"""
Reusable authentication utility functions for the web service.
"""
from flask import request, jsonify
from bson import ObjectId


def get_user_id_from_request():
    """
    Gets the user_id from the request body (JSON) or query parameters.

    This function ensures a 'user_id' is present and valid in all
    user-specific API calls.

    Returns:
        tuple: (user_id_obj, None) on success, or (None, error_response) on failure.
    """
    user_id_str = None
    if request.is_json:
        user_id_str = request.json.get('user_id')

    if not user_id_str:
        user_id_str = request.args.get('user_id')

    if not user_id_str:
        # 401 Unauthorized is the appropriate code for missing credentials
        return None, (jsonify({'error': 'user_id is required'}), 401)

    try:
        # Validate that it's a proper ObjectId and return the object
        user_id_obj = ObjectId(user_id_str)
        return user_id_obj, None
    except Exception:
        # 400 Bad Request for malformed ID
        return None, (jsonify({'error': 'Invalid user_id format'}), 400)
# --- End of new file ---

============================================================

==================== FILE: web_service/app/utils/currency.py ====================
import requests
from flask import current_app
from cachetools import cached, TTLCache

# Cache the API response for 1 hour (3600 seconds) to avoid excessive API calls
@cached(cache=TTLCache(maxsize=1, ttl=3600))
def get_live_usd_to_khr_rate():
    """
    Fetches the live USD to KHR exchange rate from the API.
    The result is cached for 1 hour.
    """
    api_key = current_app.config.get('EXCHANGERATE_API_KEY')
    if not api_key:
        print("âš ï¸ EXCHANGERATE_API_KEY not set. Using default rate of 4100.")
        return 4100.0

    url = f"https://v6.exchangerate-api.com/v6/{api_key}/latest/USD"
    try:
        response = requests.get(url, timeout=5)
        response.raise_for_status()
        data = response.json()
        if data.get('result') == 'success':
            rate = data.get('conversion_rates', {}).get('KHR')
            if rate:
                print(f"âœ… Live rate fetched: 1 USD = {rate} KHR")
                return float(rate)
    except requests.exceptions.RequestException as e:
        print(f"âŒ Could not fetch exchange rate: {e}")

    # Fallback to a default rate if API fails
    print("âš ï¸ Using default rate of 4100 due to API failure.")
    return 4100.0

============================================================

==================== FILE: web_service/run.py ====================
import os
from pathlib import Path
from dotenv import load_dotenv
from app import create_app

PROJECT_ROOT = Path(__file__).resolve().parent.parent
ENV_PATH = PROJECT_ROOT / '.env'

load_dotenv(ENV_PATH, override=True)

app = create_app()

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8000, debug=True)

============================================================

